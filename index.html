<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=4.0, user-scalable=yes">
<title>87 Highland Lane — Secure Ops Center</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #05080D;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'JetBrains Mono', monospace;
    overflow-x: hidden;
    overflow-y: auto;
    touch-action: manipulation;
    padding: 0;
  }
  .facility-shell {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 12px;
    width: min(820px, 100%);
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(5, 8, 13, 0.92);
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.55);
  }
  #canvas-viewport {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    width: 100%;
    touch-action: pan-x pan-y pinch-zoom;
  }
  canvas {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    display: block;
    width: auto;
    height: auto;
    transform-origin: top left;
  }
  .mobile-toolbar {
    display: none;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 8px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(10, 14, 20, 0.9);
    color: #C0C8D4;
  }
  .zoom-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #zoom-reset {
    font-weight: 600;
  }
  .toolbar-btn {
    background: #0A0E14;
    border: 1px solid rgba(255, 255, 255, 0.18);
    color: #C0C8D4;
    font-size: 10px;
    letter-spacing: 0.08em;
    padding: 6px 10px;
    border-radius: 8px;
    text-transform: uppercase;
    cursor: pointer;
  }
  .toolbar-btn:hover,
  .toolbar-btn:focus-visible {
    border-color: #00CC66;
    color: #00CC66;
  }
  #zoom-readout {
    font-size: 11px;
    color: #5A6A7A;
    min-width: 48px;
    text-align: center;
  }
  @media (max-width: 720px) {
    body {
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 18px 12px 32px;
    }
    .facility-shell {
      width: 100%;
      max-width: 100%;
      gap: 10px;
    }
    #canvas-viewport {
      max-height: calc(100vh - 150px);
      overflow: auto;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .mobile-toolbar {
      display: flex;
      position: sticky;
      top: 0;
      z-index: 5;
      backdrop-filter: blur(10px);
    }
  }
</style>
</head>
<body>
<div class="facility-shell">
  <div class="mobile-toolbar">
    <button class="toolbar-btn" data-jump="map">MAP</button>
    <div class="zoom-controls">
      <button class="toolbar-btn" data-zoom="out" aria-label="Zoom out">−</button>
      <span id="zoom-readout">100%</span>
      <button class="toolbar-btn" data-zoom="in" aria-label="Zoom in">+</button>
      <button class="toolbar-btn" id="zoom-reset" aria-label="Reset zoom">RESET</button>
    </div>
    <button class="toolbar-btn" data-jump="status">STATUS</button>
  </div>
  <div id="canvas-viewport">
    <canvas id="game"></canvas>
  </div>
</div>
<script>
// ============================================================
//  87 HIGHLAND LANE — SECURE OPS CENTER
//  Retro pixel-art spy facility for AI agent visualization
// ============================================================

const canvas = document.getElementById('game');
const canvasViewport = document.getElementById('canvas-viewport');
const zoomReadout = document.getElementById('zoom-readout');
const zoomResetBtn = document.getElementById('zoom-reset');
const ctx = canvas.getContext('2d');
const TARGET_WIDTH = 800;
const TARGET_HEIGHT = 1400; // Increased for 2-row quarters layout
canvas.width = TARGET_WIDTH;
canvas.height = TARGET_HEIGHT;
ctx.imageSmoothingEnabled = false;

const zoomButtons = document.querySelectorAll('[data-zoom]');
const jumpButtons = document.querySelectorAll('[data-jump]');
const displayModeMedia = window.matchMedia('(display-mode: standalone)');
let baseScale = 1;
let userZoom = 1;
const MIN_ZOOM = 0.55;
const MAX_ZOOM = 1.6;
let lastTapTime = 0;
let lastTapPos = null;
let pinchActive = false;
let pinchStartDistance = 0;
let pinchStartZoom = 1;
let standaloneMode = displayModeMedia.matches || !!window.navigator.standalone || !!document.fullscreenElement;
const TAP_SLOP = 8;

let tapCandidate = false;
let tapCanvasPos = null;
let tapZone = null;
let panGestureEnabled = false;
let panActive = false;
let panStartClient = null;
let panStartScroll = null;

function updateStandaloneMode() {
  standaloneMode = displayModeMedia.matches || !!window.navigator.standalone || !!document.fullscreenElement;
  if (canvasViewport) {
    canvasViewport.style.touchAction = standaloneMode ? 'none' : 'pan-x pan-y pinch-zoom';
  }
}

function clampZoom(value) {
  return Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, value));
}

function applyZoom(options = {}) {
  const totalScale = baseScale * userZoom;
  canvas.style.width = Math.floor(TARGET_WIDTH * totalScale) + 'px';
  canvas.style.height = Math.floor(TARGET_HEIGHT * totalScale) + 'px';
  if (zoomReadout) {
    zoomReadout.textContent = Math.round(userZoom * 100) + '%';
  }
  if (canvasViewport) {
    const allowScroll = userZoom > 1.02;
    if (allowScroll) {
      canvasViewport.style.overflow = 'auto';
    } else if (window.innerWidth > 720) {
      canvasViewport.style.overflow = 'hidden';
      if (options.resetScroll !== false) {
        canvasViewport.scrollTop = 0;
        canvasViewport.scrollLeft = 0;
      }
    } else {
      canvasViewport.style.overflow = 'auto';
      if (options.resetScroll !== false) {
        canvasViewport.scrollTop = 0;
        canvasViewport.scrollLeft = 0;
      }
    }
  }
}

function updateCanvasScale() {
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;
  const scaleX = windowWidth / TARGET_WIDTH;
  const scaleY = windowHeight / TARGET_HEIGHT;
  baseScale = Math.min(scaleX, scaleY, 1);
  applyZoom({ resetScroll: false });
}

updateStandaloneMode();
updateCanvasScale();
window.addEventListener('resize', () => {
  updateStandaloneMode();
  updateCanvasScale();
});
if (displayModeMedia.addEventListener) {
  displayModeMedia.addEventListener('change', updateStandaloneMode);
} else if (displayModeMedia.addListener) {
  displayModeMedia.addListener(updateStandaloneMode);
}
document.addEventListener('fullscreenchange', updateStandaloneMode);
document.addEventListener('visibilitychange', updateStandaloneMode);

zoomButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    const dir = btn.dataset.zoom;
    const delta = dir === 'in' ? 0.15 : -0.15;
    userZoom = clampZoom(userZoom + delta);
    applyZoom({ resetScroll: userZoom <= 1.01 });
  });
});

if (zoomResetBtn) {
  zoomResetBtn.addEventListener('click', () => {
    userZoom = 1;
    applyZoom({ resetScroll: true });
  });
}

function jumpToSection(section) {
  if (!canvasViewport) return;
  const behavior = 'smooth';
  if (section === 'map') {
    canvasViewport.scrollTo({ top: 0, behavior });
  } else if (section === 'status') {
    const maxScroll = canvasViewport.scrollHeight - canvasViewport.clientHeight;
    canvasViewport.scrollTo({ top: Math.max(maxScroll, 0), behavior });
  }
}

jumpButtons.forEach(btn => {
  btn.addEventListener('click', () => jumpToSection(btn.dataset.jump));
});


function detectDoubleTap(x, y) {
  if (window.innerWidth > 720) return;
  if (y >= BAR_Y - 12) {
    lastTapTime = 0;
    lastTapPos = null;
    return;
  }
  const now = Date.now();
  const isClose = lastTapPos ? Math.hypot(lastTapPos.x - x, lastTapPos.y - y) < 25 : false;
  if (now - lastTapTime < 280 && isClose) {
    userZoom = userZoom > 1.05 ? 1 : 1.35;
    applyZoom({ resetScroll: userZoom <= 1.01 });
    lastTapTime = 0;
    lastTapPos = null;
  } else {
    lastTapTime = now;
    lastTapPos = { x, y };
  }
}

function distanceBetweenTouches(touches) {
  if (touches.length < 2) return 1;
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy) || 1;
}

function clampScrollValue(value, max) {
  if (max <= 0) return 0;
  return Math.min(Math.max(value, 0), max);
}

function resetTouchInteraction() {
  tapCandidate = false;
  tapCanvasPos = null;
  tapZone = null;
  panGestureEnabled = false;
  panActive = false;
  panStartClient = null;
  panStartScroll = null;
}

// ===== CANVAS CLICK HANDLING FOR MOBILE STATUS BAR =====
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mouseX = (e.clientX - rect.left) * scaleX;
  const mouseY = (e.clientY - rect.top) * scaleY;
  handleStatusBarClick(mouseX, mouseY);
});

// Mouse move for quarter item hover detection
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  mouseCanvasPos.x = (e.clientX - rect.left) * scaleX;
  mouseCanvasPos.y = (e.clientY - rect.top) * scaleY;
  
  // Check for quarter item hover
  hoveredQuarterItem = null;
  for (const item of quarterItemPositions) {
    if (mouseCanvasPos.x >= item.x && mouseCanvasPos.x <= item.x + item.width &&
        mouseCanvasPos.y >= item.y && mouseCanvasPos.y <= item.y + item.height) {
      hoveredQuarterItem = item;
      break;
    }
  }
});

// Touch support for mobile
canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length >= 2) {
    resetTouchInteraction();
    pinchActive = true;
    pinchStartDistance = distanceBetweenTouches(e.touches);
    pinchStartZoom = userZoom;
    e.preventDefault();
    return;
  }

  const touch = e.touches[0];
  if (!touch) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const canvasX = (touch.clientX - rect.left) * scaleX;
  const canvasY = (touch.clientY - rect.top) * scaleY;

  tapZone = canvasY >= BAR_Y ? 'status' : 'map';
  tapCanvasPos = { x: canvasX, y: canvasY };
  tapCandidate = true;
  panActive = false;
  panGestureEnabled = standaloneMode || userZoom > 1.02;
  panStartClient = { x: touch.clientX, y: touch.clientY };
  panStartScroll = canvasViewport ? { left: canvasViewport.scrollLeft, top: canvasViewport.scrollTop } : { left: 0, top: 0 };

  if (panGestureEnabled) {
    e.preventDefault();
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  if (pinchActive && e.touches.length === 2) {
    e.preventDefault();
    const distance = distanceBetweenTouches(e.touches);
    if (distance > 0 && pinchStartDistance > 0) {
      const scale = distance / pinchStartDistance;
      userZoom = clampZoom(pinchStartZoom * scale);
      applyZoom({ resetScroll: false });
    }
    return;
  }

  if (e.touches.length !== 1 || !panStartClient) return;
  const touch = e.touches[0];
  const dx = touch.clientX - panStartClient.x;
  const dy = touch.clientY - panStartClient.y;

  if (!panActive && Math.hypot(dx, dy) > TAP_SLOP) {
    panActive = true;
    tapCandidate = false;
  }

  if (!panGestureEnabled || !panActive || !canvasViewport) return;

  e.preventDefault();
  const maxLeft = canvasViewport.scrollWidth - canvasViewport.clientWidth;
  const maxTop = canvasViewport.scrollHeight - canvasViewport.clientHeight;
  canvasViewport.scrollLeft = clampScrollValue(panStartScroll.left - dx, maxLeft);
  canvasViewport.scrollTop = clampScrollValue(panStartScroll.top - dy, maxTop);
}, { passive: false });

function endPinchIfNeeded(e) {
  if (pinchActive && e.touches.length < 2) {
    pinchActive = false;
    pinchStartDistance = 0;
  }
}

canvas.addEventListener('touchend', (e) => {
  const wasPinch = pinchActive;
  endPinchIfNeeded(e);
  if (wasPinch) {
    resetTouchInteraction();
    return;
  }

  if (!tapCandidate || panActive || !tapCanvasPos) {
    resetTouchInteraction();
    return;
  }

  if (tapZone === 'status') {
    handleStatusBarClick(tapCanvasPos.x, tapCanvasPos.y);
  } else {
    detectDoubleTap(tapCanvasPos.x, tapCanvasPos.y);
  }
  resetTouchInteraction();
}, { passive: false });

canvas.addEventListener('touchcancel', (e) => {
  endPinchIfNeeded(e);
  resetTouchInteraction();
}, { passive: false });

// Keyboard input for add task modal
window.addEventListener('keydown', (e) => {
  if (!addTaskModal.active) return;

  // Handle Enter key to submit
  if (e.key === 'Enter') {
    if (addTaskModal.taskText.trim()) {
      addTaskModal.active = false;
      if (addTaskModal.onSubmit) {
        addTaskModal.onSubmit(addTaskModal.taskText.trim(), addTaskModal.selectedAssignee);
      }
    }
    e.preventDefault();
    return;
  }

  // Handle Escape key to cancel
  if (e.key === 'Escape') {
    addTaskModal.active = false;
    if (addTaskModal.onCancel) addTaskModal.onCancel();
    e.preventDefault();
    return;
  }

  // Handle backspace
  if (e.key === 'Backspace') {
    addTaskModal.taskText = addTaskModal.taskText.slice(0, -1);
    e.preventDefault();
    return;
  }

  // Handle regular character input (single characters only, not modifiers)
  if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
    if (addTaskModal.taskText.length < 50) {
      addTaskModal.taskText += e.key;
    }
    e.preventDefault();
    return;
  }
});

const POLL_INTERVAL = 5000; // 5 seconds

// ===== PALETTE =====
const C = {
  bg:'#0D1117',
  floor1:'#7A5C28', floor2:'#8B6914', floor3:'#6B4F1A', floorLine:'#5A4210', floorDark:'#4A3808',
  wall:'#1A2030', wallTop:'#222E3E', wallTrim:'#2E3A4E', wallInner:'#151D2A', wallAccent:'#3A4A5E',
  desk:'#4A3728', deskTop:'#5C4A38', deskLeg:'#3A2A1C',
  monitor:'#0A1020', monScreen:'#003060', monGlow:'#0055AA', monBright:'#0088DD',
  chair:'#2A2A35', chairSeat:'#35354A',
  green:'#00CC66', red:'#CC3333', amber:'#FFAA00',
  // Flint
  fHair:'#2A1808', fSkin:'#D4A574', fSkinS:'#C09060', fEye:'#1A1A2E',
  fJacket:'#2A3A5C', fJacketD:'#1E2E4A', fAccent:'#FF8C00',
  fPants:'#2A2A38', fBoots:'#1A1A20', fBelt:'#3A3A2A',
  // Cipher (cyan)
  cHair:'#1A1A2A', cSkin:'#D4A574', cSkinS:'#C09060', cEye:'#1A1A2E',
  cJacket:'#1E3A4A', cJacketD:'#152A3A', cAccent:'#00D4FF',
  cPants:'#2A2A38', cBoots:'#1A1A20', cBelt:'#2A3A4A',
  // Lucky
  lW:'#F0E8D8', lB:'#2A2018', lBr:'#8B6F4E', lNose:'#1A1410', lTongue:'#E87070',
  // Vera (warm wood tones)
  vHair:'#3D2817', vSkin:'#D4A574', vSkinS:'#C09060', vEye:'#1A1A2E',
  vJacket:'#5C4A38', vJacketD:'#4A3728', vAccent:'#D4A574',
  vPants:'#3A3028', vBoots:'#2A2018', vBelt:'#4A3A2A',
  vSucculent:'#4CAF50', vSucculentD:'#2E7D32', vPot:'#8D6E63',
  // Furniture
  couch:'#3A2A40', couchL:'#4A3A50', couchD:'#2A1A30',
  shelf:'#3A3040', book1:'#8B2020', book2:'#204080', book3:'#206020', book4:'#806020',
  fridge:'#B0B8C0', fridgeD:'#8090A0',
  coffee:'#2A2A2A', coffeePot:'#604020',
  cabinet:'#5C4A38', cabinetD:'#4A3828',
  wb:'#E0E0D8', wbBorder:'#707070',
  pingpong:'#206030', ppNet:'#D0D0D0', ppLeg:'#5A5A5A',
  cooler:'#8098A8', coolerJug:'#A0C8D8',
  bean1:'#7A2828', bean2:'#28487A',
  plant:'#2E7D32', plantL:'#4CAF50', plantD:'#1B5E20', pot:'#795548', potD:'#5D4037',
  corridorBase:'#3A2F1C', corridorAccent:'#B8863B', corridorHighlight:'#8C6A2B',
  corridorCross:'#2C3642', corridorCrossLine:'#5F7DA2',
  corridorLoop:'#2B2420', corridorLoopRail:'#FFB347',
  corridorMedallion:'#5C4A38', corridorMedallionInset:'#C89B3C',
  radio:'#3A3A3A', radioAnt:'#808080', radioLight:'#CC3333',
  clipboard:'#C8B890', clipMetal:'#A0A0A0', clipText:'#6A6040',
  // UI
  hdrBg:'#080C12', hdrText:'#00CC66', hdrDim:'#005530', hdrBorder:'#1A2A1A',
  barBg:'#0A0E14', barBorder:'#1E2A3A', barText:'#C0C8D4', barDim:'#5A6A7A',
  namePlate:'#1A1A20', namePlateText:'#C0C8D4',
  tile:'#182028',
};

// ===== LAYOUT =====
const HDR_H = 30;
const ROOM_Y = 40;
const ROOM_H = 160;
const ROOM_GAP = 20;
const POD_Y = 380, POD_W = 172, POD_H = 142, POD_GAP = 20;
const LOUNGE_X = 10, LOUNGE_W = 780;
const LOUNGE_Y = 540, LOUNGE_H = 200;

// Floor 2 (Quarters) — below ops floor
const FLOOR_SEP_Y = 760;
const FLOOR2_Y = 800;
const QUARTER_H = 150;
const QUARTER_W = 230;
const QUARTER_GAP = 18;
// Quarters row 1 (3 quarters) + row 2 (1 quarter) = need more space
const QUARTERS_ROW2_Y = FLOOR2_Y + QUARTER_H + 30; // Second row for Vera
const BAR_H = 220;
const BAR_Y = QUARTERS_ROW2_Y + QUARTER_H + 20; // 20px gap after quarters

// Newspaper spot for Lucky's heartbeat run
const NEWSPAPER_SPOT = { x: LOUNGE_X + LOUNGE_W - 140, y: LOUNGE_Y + LOUNGE_H - 30 };

// Heartbeat detection
let heartbeatRecent = false;
let lastHeartbeatProcessedAt = 0;

// Meeting state with location
let meetingActive = false;
let meetingLocation = 'galley'; // 'galley' | 'briefing' | 'command'

// Status board tabs
let statusTab = 'agents'; // 'agents' | 'todos' | 'activity'
let modalOpen = false; // Modal overlay state

// Confirmation modal state
let confirmModal = {
  active: false,
  text: '',
  onYes: null,
  onNo: null
};

// Tooltip state for quarter items
let hoveredQuarterItem = null;
let mouseCanvasPos = { x: 0, y: 0 };

// Add Task modal state
let addTaskModal = {
  active: false,
  taskText: '',
  selectedAssignee: '',
  agents: ['Flint', 'Cipher'],
  onSubmit: null,
  onCancel: null,
  inputPos: { x: 0, y: 0, width: 0, height: 0 },
  dropdownPos: { x: 0, y: 0, width: 0, height: 0 },
  yesPos: { x: 0, y: 0, width: 0, height: 0 },
  noPos: { x: 0, y: 0, width: 0, height: 0 }
};

const ROOM_LAYOUT = [
  { name:'R&D LAB', x:40, y:ROOM_Y, w:360, h:ROOM_H },
  { name:'COMMAND', x:420, y:ROOM_Y, w:340, h:ROOM_H },
  { name:'GALLEY',  x:40, y:ROOM_Y + ROOM_H + ROOM_GAP, w:360, h:ROOM_H },
  { name:'BRIEFING', x:420, y:ROOM_Y + ROOM_H + ROOM_GAP, w:340, h:ROOM_H }
];

const ROOMS = ROOM_LAYOUT.map(room => ({
  ...room,
  doorW: 46,
  doorX: room.x + (room.w - 46) / 2
}));

// ===== COLLISION DETECTION =====
const COLLISION_BOXES = [];

// Build collision boxes from rooms (walls only, not interior)
function initCollisionBoxes() {
  COLLISION_BOXES.length = 0;
  
  // Add room walls (perimeter of each room) - thinner walls with door gaps
  ROOMS.forEach(room => {
    // Top wall (with door gap in center)
    const doorGap = 40;
    const doorStart = room.x + room.w/2 - doorGap/2;
    // Left of door
    if (room.x < doorStart) {
      COLLISION_BOXES.push({ x: room.x, y: room.y - 2, w: doorStart - room.x, h: 4 });
    }
    // Right of door
    if (room.x + room.w > doorStart + doorGap) {
      COLLISION_BOXES.push({ x: doorStart + doorGap, y: room.y - 2, w: (room.x + room.w) - (doorStart + doorGap), h: 4 });
    }
    // Bottom wall (with door gap)
    const doorGapBottom = 50;
    const doorStartB = room.x + room.w/2 - doorGapBottom/2;
    if (room.x < doorStartB) {
      COLLISION_BOXES.push({ x: room.x, y: room.y + room.h - 2, w: doorStartB - room.x, h: 4 });
    }
    if (room.x + room.w > doorStartB + doorGapBottom) {
      COLLISION_BOXES.push({ x: doorStartB + doorGapBottom, y: room.y + room.h - 2, w: (room.x + room.w) - (doorStartB + doorGapBottom), h: 4 });
    }
    // Left wall
    COLLISION_BOXES.push({ x: room.x - 2, y: room.y, w: 4, h: room.h });
    // Right wall
    COLLISION_BOXES.push({ x: room.x + room.w - 2, y: room.y, w: 4, h: room.h });
  });
  
  // Add pod collision boxes (thinner - just edges, not blocking)
  PODS.forEach((pod, i) => {
    COLLISION_BOXES.push({ x: pod.x, y: pod.y, w: pod.w, h: 2 }); // Pod top
    COLLISION_BOXES.push({ x: pod.x, y: pod.y + pod.h - 2, w: pod.w, h: 2 }); // Pod bottom
    COLLISION_BOXES.push({ x: pod.x - 2, y: pod.y, w: 2, h: pod.h }); // Pod left
    COLLISION_BOXES.push({ x: pod.x + pod.w, y: pod.y, w: 2, h: pod.h }); // Pod right
  });
  
  // Add corridor walls (thinner)
  const { spine } = CORRIDOR_SEGMENTS;
  COLLISION_BOXES.push({ x: spine.x - 2, y: spine.y, w: 2, h: spine.h });
  COLLISION_BOXES.push({ x: spine.x + spine.w, y: spine.y, w: 2, h: spine.h });
  
  // Add room furniture collision boxes (desks, couches, tables)
  // R&D Lab - workbench at r.x+30, r.y+20 = 70, 60
  COLLISION_BOXES.push({ x: 70, y: 60, w: 100, h: 22 });
  // Command room - big desk at r.x+30, r.y+20 = 450, 60; couch at r.x+160, r.y+60 = 580, 100
  COLLISION_BOXES.push({ x: 450, y: 60, w: 100, h: 22 });
  COLLISION_BOXES.push({ x: 580, y: 100, w: 70, h: 25 });
  // Galley - counter at r.x+15, r.y+60 = 55, 280
  COLLISION_BOXES.push({ x: 55, y: 280, w: 140, h: 16 });
  // Briefing room - table at r.x+60, r.y+40 = 480, 260
  COLLISION_BOXES.push({ x: 480, y: 260, w: 120, h: 22 });
  // Lounge - matched to render positions (LOUNGE_X=10, LOUNGE_Y=540)
  // Couch drawn at: LOUNGE_X+20=30, LOUNGE_Y+150=690
  COLLISION_BOXES.push({ x: 30, y: 690, w: 80, h: 25 });
  // Ping pong drawn at: LOUNGE_X+320=330, LOUNGE_Y+60=600
  COLLISION_BOXES.push({ x: 330, y: 600, w: 70, h: 36 });
  // Coffee table drawn at: LOUNGE_X+30=40, LOUNGE_Y+110=650
  COLLISION_BOXES.push({ x: 40, y: 650, w: 40, h: 24 });
  
  // Add collision boxes for Scout & Vera's desks (custom positions from AGENTS array)
  // Scout: deskPos { x: 375, y: 155 }, Vera: deskPos { x: 465, y: 155 }
  // Desk size ~80x18, chair offset by y+30
  const scoutDesk = AGENTS.find(a => a.name === 'Scout')?.deskPos;
  const veraDesk = AGENTS.find(a => a.name === 'Vera')?.deskPos;
  if (scoutDesk) {
    COLLISION_BOXES.push({ x: scoutDesk.x - 40, y: scoutDesk.y - 10, w: 80, h: 18 }); // Scout's desk
    COLLISION_BOXES.push({ x: scoutDesk.x - 40, y: scoutDesk.y + 18, w: 18, h: 8 }); // Scout's chair
  }
  if (veraDesk) {
    COLLISION_BOXES.push({ x: veraDesk.x - 40, y: veraDesk.y - 10, w: 80, h: 18 }); // Vera's desk
    COLLISION_BOXES.push({ x: veraDesk.x - 40, y: veraDesk.y + 18, w: 18, h: 8 }); // Vera's chair
  }
}

// Check if a point collides with any obstacle
function checkCollision(x, y, radius = 8) {
  for (const box of COLLISION_BOXES) {
    if (x + radius > box.x && x - radius < box.x + box.w &&
        y + radius > box.y && y - radius < box.y + box.h) {
      return true;
    }
  }
  return false;
}

// Find a valid position near target, avoiding collisions
function findValidPosition(targetX, targetY, radius = 8) {
  // If target is valid, return it
  if (!checkCollision(targetX, targetY, radius)) {
    return { x: targetX, y: targetY };
  }
  
  // Search in expanding circles
  for (let r = 20; r < 200; r += 20) {
    for (let angle = 0; angle < 360; angle += 45) {
      const rad = angle * Math.PI / 180;
      const testX = targetX + Math.cos(rad) * r;
      const testY = targetY + Math.sin(rad) * r;
      if (!checkCollision(testX, testY, radius)) {
        return { x: testX, y: testY };
      }
    }
  }
  
  // Fallback: return target anyway (better than stuck)
  return { x: targetX, y: targetY };
}

function podPos(col) {
  return {
    x: 40 + col * (POD_W + POD_GAP),
    y: POD_Y,
    w: POD_W, h: POD_H
  };
}

const PODS = [];
for (let c = 0; c < 4; c++) PODS.push(podPos(c));

// Quarters (all four)
const QUARTERS = [
  { agent: 'Flint', label: "FLINT'S QUARTERS", x: 20, y: FLOOR2_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 72, y: FLOOR2_Y + 60 } },
  { agent: 'Cipher', label: "CIPHER'S QUARTERS", x: 20 + (QUARTER_W + QUARTER_GAP), y: FLOOR2_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 20 + (QUARTER_W + QUARTER_GAP) + 140, y: FLOOR2_Y + 58 } },
  { agent: 'Scrub', label: "SCRUB'S QUARTERS", x: 20 + 2 * (QUARTER_W + QUARTER_GAP), y: FLOOR2_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 20 + 2 * (QUARTER_W + QUARTER_GAP) + 60, y: FLOOR2_Y + 62 } },
  { agent: 'Scout', label: "SCOUT'S QUARTERS", x: 20, y: QUARTERS_ROW2_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 20 + 60, y: QUARTERS_ROW2_Y + 62 } },
  { agent: 'Vera', label: "VERA'S QUARTERS", x: 20 + (QUARTER_W + QUARTER_GAP), y: QUARTERS_ROW2_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 20 + (QUARTER_W + QUARTER_GAP) + 140, y: QUARTERS_ROW2_Y + 58 } }
];

const CORRIDOR_SPINE_WIDTH = 48;
const CORRIDOR_SEGMENTS = (() => {
  const spineX = ((ROOMS[0].x + ROOMS[0].w) + ROOMS[1].x) / 2 - CORRIDOR_SPINE_WIDTH / 2;
  const spineY = ROOM_Y - 10;
  const spineH = (LOUNGE_Y + LOUNGE_H + 12) - spineY;
  const spine = { x: spineX, y: spineY, w: CORRIDOR_SPINE_WIDTH, h: spineH };
  const crossWidth = (ROOMS[1].x + ROOMS[1].w) - ROOMS[0].x;
  const crossHeight = 32;
  const upperCross = { x: ROOMS[0].x, y: ROOM_Y + ROOM_H / 2 - crossHeight / 2, w: crossWidth, h: crossHeight };
  const lowerCross = { x: ROOMS[2].x, y: ROOMS[2].y + ROOM_H / 2 - crossHeight / 2, w: crossWidth, h: crossHeight };
  const inset = 16;
  const loopLeft = PODS[0].x - inset;
  const loopTop = POD_Y - inset;
  const loopRight = PODS[PODS.length - 1].x + POD_W + inset;
  const podLoop = { x: loopLeft, y: loopTop, w: loopRight - loopLeft, h: POD_H + inset * 2, inset, radius: 18 };
  const loungeBulb = { x: spineX + CORRIDOR_SPINE_WIDTH / 2, y: LOUNGE_Y - 30, radius: 30 };
  return { spine, upperCross, lowerCross, podLoop, loungeBulb };
})();

const CORRIDOR_PLANTS = (() => {
  const { spine, loungeBulb } = CORRIDOR_SEGMENTS;
  const spineLeft = spine.x;
  const spineRight = spine.x + spine.w;
  const base = [
    { cx: spineLeft + 6, cy: ROOM_Y + 60, size: 1.3, rotation: -12 },
    { cx: spineRight - 6, cy: ROOM_Y + 60, size: 1.3, rotation: 12 },
    { cx: spineLeft + 6, cy: ROOMS[2].y + 70, size: 1.3, rotation: -8 },
    { cx: spineRight - 6, cy: ROOMS[2].y + 70, size: 1.3, rotation: 8 },
    { cx: spineLeft + 10, cy: POD_Y - 4, size: 1.4, tiers: 2 },
    { cx: spineRight - 10, cy: POD_Y - 4, size: 1.4, tiers: 2 },
    { cx: spineLeft + 10, cy: POD_Y + POD_H + 24, size: 1.4, tiers: 2 },
    { cx: spineRight - 10, cy: POD_Y + POD_H + 24, size: 1.4, tiers: 2 },
  ];
  const ringRadius = loungeBulb.radius - 10;
  const ring = [0, 90, 180, 270].map((deg) => {
    const rad = deg * Math.PI / 180;
    return {
      cx: loungeBulb.x + Math.cos(rad) * ringRadius,
      cy: loungeBulb.y + Math.sin(rad) * ringRadius,
      size: 1,
      rotation: deg + 45,
      medallionRadius: 9
    };
  });
  return [...base, ...ring];
})();

// ===== SCALABLE MEETING LOCATIONS =====
const MEETING_LOCATIONS = {
  galley: {
    positions: [
      { x: 120, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 160, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 200, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 240, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 140, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
      { x: 280, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
    ]
  },
  briefing: {
    positions: [
      { x: 500, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 540, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 580, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 620, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 520, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
      { x: 660, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
    ]
  },
  command: {
    positions: [
      { x: ROOMS[1].x + 60, y: ROOMS[1].y + 40 },
      { x: ROOMS[1].x + 100, y: ROOMS[1].y + 50 },
      { x: ROOMS[1].x + 80, y: ROOMS[1].y + 80 },
      { x: ROOMS[1].x + 140, y: ROOMS[1].y + 70 },
      { x: ROOMS[1].x + 40, y: ROOMS[1].y + 100 },
      { x: ROOMS[1].x + 180, y: ROOMS[1].y + 60 },
    ]
  },
  lounge: {
    positions: [
      { x: LOUNGE_X + 60, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 150, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 240, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 330, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 420, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 510, y: LOUNGE_Y + 80 },
    ]
  }
};

// Legacy support - individual named positions for galley
const GALLEY_POSITIONS = {
  'Flint': { x: 120, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
  'Cipher': { x: 160, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
  'Lucky': { x: 200, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 }
};

// Custom desk positions for agents without pods
const CUSTOM_DESK_POSITIONS = {
  // Scout & Vera share office - positions set in AGENTS array
};

// Desk center positions (where agents sit)
function deskCenter(pod) { return { x: pod.x + pod.w/2, y: pod.y + 52 }; }

// ===== AGENTS CONFIG (Flint + Cipher only for now) =====
const AGENTS = [
  {
    name:'Flint', role:'Director', color:'#FF8C00', podIndex:0,
    deskItems:['radio','clipboard'],
    quartersItems:['bed'],
    companion:{ name:'Lucky', type:'boston_terrier' },
    status:'idle',
    level:5, exp:1125, nextLevel:1500, expProgress:0.75,
    idleLocations: ['pod', 'quarters', 'briefing', 'galley']
  },
  {
    name:'Cipher', role:'Systems', color:'#00D4FF', podIndex:1,
    deskItems:['rubberDuck','energyDrink'],
    quartersItems:['bed'],
    companion:null,
    status:'idle',
    level:2, exp:500, nextLevel:750, expProgress:0.66,
    idleLocations: ['pod', 'quarters', 'rec']
  },
  {
    name:'Scrub', role:'Security', color:'#8B0000', podIndex:2,
    deskItems:['evidenceBag','shredder','blacklight','sanitizerSpray'],
    quartersItems:['bed'],
    companion:null,
    status:'idle',
    level:1, exp:0, nextLevel:500, expProgress:0,
    idleLocations: ['pod', 'quarters', 'briefing', 'corridor']
  },
  {
    name:'Scout', role:'Researcher', color:'#9B59B6', podIndex:-1,
    deskItems:['notebook','coffee'],
    quartersItems:['bed'],
    deskPos: { x: 160, y: 280 },
    companion:null,
    status:'idle',
    level:1, exp:0, nextLevel:500, expProgress:0,
    idleLocations: ['desk', 'quarters', 'rec', 'briefing']
  },
  {
    name:'Vera', role:'Interior Designer', color:'#D4A574', podIndex:-1,
    deskItems:['succulent','sketchbook'],
    quartersItems:['bed'],
    deskPos: { x: 560, y: 280 },
    companion:null,
    status:'idle',
    level:1, exp:0, nextLevel:500, expProgress:0,
    idleLocations: ['desk', 'quarters', 'rec', 'galley']
  }
];

// ===== OFFSCREEN BG =====

// ===== DRAWING HELPERS =====
function rect(c, x, y, w, h, col) { c.fillStyle = col; c.fillRect(x|0, y|0, w|0, h|0); }
function strokeRect(c, x, y, w, h, col, lw) {
  c.strokeStyle = col; c.lineWidth = lw||1;
  c.strokeRect((x|0)+0.5, (y|0)+0.5, w|0, h|0);
}

function drawExpBar(ctx, x, y, width, height, progress, color, isMaxLevel) {
  // Clamp progress to 0-1 range
  progress = Math.max(0, Math.min(1, progress));

  // Background
  rect(ctx, x, y, width, height, '#1A1A20');

  // Border
  strokeRect(ctx, x, y, width, height, '#2A2A2A', 1);

  // Fill based on progress
  const fillWidth = (width - 2) * progress; // -2 for border padding
  if (fillWidth > 0) {
    // Use gold color for max level, otherwise use agent color
    const fillColor = isMaxLevel ? '#FFAA00' : color;
    rect(ctx, x + 1, y + 1, fillWidth, height - 2, fillColor);
  }
}

function drawLevelBadge(ctx, x, y, level, color) {
  // Format: "Lv.{level}"
  const text = `Lv.${level}`;

  // Font setup
  ctx.font = '9px "JetBrains Mono"';
  const textMetrics = ctx.measureText(text);
  const textWidth = textMetrics.width;
  const paddingX = 6;
  const paddingY = 2;
  const badgeWidth = textWidth + paddingX * 2;
  const badgeHeight = 12;

  // Create dark tint of agent color for background
  // Parse hex color and darken it
  const darkColor = darkenColor(color, 0.4);

  // Draw pill background
  ctx.fillStyle = darkColor;
  ctx.beginPath();
  const radius = badgeHeight / 2;
  ctx.roundRect(x, y, badgeWidth, badgeHeight, radius);
  ctx.fill();

  // Draw text centered
  ctx.fillStyle = color;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + paddingX, y + badgeHeight / 2 + 0.5);

  // Return badge width for positioning
  return badgeWidth;
}

// Helper to darken a hex color
function darkenColor(color, factor) {
  // Handle hex colors
  if (color.startsWith('#')) {
    let hex = color.slice(1);
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);

    const newR = Math.floor(r * factor);
    const newG = Math.floor(g * factor);
    const newB = Math.floor(b * factor);

    return `rgb(${newR}, ${newG}, ${newB})`;
  }
  return color;
}

// ===== DRAW WOOD FLOOR =====
function drawFloor(c, x, y, w, h) {
  const colors = [C.floor1, C.floor2, C.floor3, C.floor2, C.floor1, C.floor3];
  const plankH = 10;
  for (let py = y; py < y + h; py += plankH) {
    const ci = ((py / plankH) | 0) % colors.length;
    rect(c, x, py, w, Math.min(plankH, y+h-py), colors[ci]);
    rect(c, x, py, w, 1, C.floorLine);
    // Plank joints
    const offset = ((py / plankH) | 0) % 2 === 0 ? 0 : 60;
    for (let px = x + offset; px < x + w; px += 120) {
      rect(c, px, py, 1, Math.min(plankH, y+h-py), C.floorLine);
    }
  }
}

// ===== DRAW WALLS =====
function drawWalls(c, room) {
  const { x, y, w, h, doorX, doorW } = room;
  const t = 5; // wall thickness
  // Floor first
  drawFloor(c, x+t, y+t, w-t*2, h-t*2);
  // Walls
  rect(c, x, y, w, t, C.wallTop);       // top
  rect(c, x, y, t, h, C.wall);          // left
  rect(c, x+w-t, y, t, h, C.wall);      // right
  // Bottom wall with door
  rect(c, x, y+h-t, doorX - x, t, C.wallTop);
  rect(c, doorX + doorW, y+h-t, (x+w) - (doorX+doorW), t, C.wallTop);
  // Trim line
  rect(c, x, y+t, w, 1, C.wallTrim);
  // Room label (make it more visible)
  c.fillStyle = '#5A7A9A';
  c.font = 'bold 10px "JetBrains Mono"';
  c.fillText(room.name, x + 10, y + 14);
}

// ===== FURNITURE DRAWING =====
function drawDesk(c, x, y, w, h) {
  rect(c, x, y, w, h, C.deskTop);
  rect(c, x, y+h, w, 2, C.desk);
  // Legs
  rect(c, x+2, y+h, 3, 8, C.deskLeg);
  rect(c, x+w-5, y+h, 3, 8, C.deskLeg);
}

function drawMonitor(c, x, y, on) {
  rect(c, x, y, 30, 24, C.monitor);
  rect(c, x+2, y+2, 26, 18, on ? C.monScreen : '#0A0A15');
  if (on) {
    // Scan lines
    for (let i = 0; i < 18; i += 3) {
      rect(c, x+2, y+2+i, 26, 1, C.monGlow);
    }
    // Text cursor blink
    rect(c, x+6, y+12, 8, 2, C.monBright);
  }
  // Stand
  rect(c, x+12, y+24, 6, 4, C.monitor);
  rect(c, x+8, y+27, 14, 2, C.monitor);
}

function drawChair(c, x, y) {
  rect(c, x, y, 18, 4, C.chairSeat);
  rect(c, x+2, y-10, 14, 10, C.chair);
  rect(c, x+1, y+4, 3, 6, C.chair);
  rect(c, x+14, y+4, 3, 6, C.chair);
}

function drawNamePlate(c, x, y, name, status) {
  rect(c, x, y, 60, 12, C.namePlate);
  rect(c, x+2, y+2, 6, 8, status === 'working' ? C.green : C.red);
  c.fillStyle = C.namePlateText;
  c.font = '7px "JetBrains Mono"';
  c.fillText(name, x + 12, y + 9);
}

function drawRadio(c, x, y) {
  rect(c, x, y, 14, 10, C.radio);
  rect(c, x+2, y+2, 10, 5, '#2A2A2A');
  rect(c, x+5, y+1, 1, -8, C.radioAnt);
  rect(c, x+5, y-8, 3, 2, C.radioAnt);
  rect(c, x+10, y+3, 2, 2, C.radioLight);
}

function drawClipboard(c, x, y) {
  rect(c, x, y, 12, 16, C.clipboard);
  rect(c, x+3, y-2, 6, 3, C.clipMetal);
  // Text lines
  for (let i = 0; i < 4; i++) {
    rect(c, x+2, y+4+i*3, 8, 1, C.clipText);
  }
}

function drawRubberDuck(c, x, y) {
  // Duck body (yellow)
  rect(c, x+2, y+6, 10, 6, '#FFD700');
  rect(c, x+4, y+4, 6, 2, '#FFD700');
  // Head
  rect(c, x+8, y+2, 6, 5, '#FFD700');
  // Beak (orange)
  rect(c, x+13, y+3, 3, 2, '#FF8C00');
  // Eye
  rect(c, x+10, y+3, 1, 1, '#1A1A2E');
  // Wing
  rect(c, x+4, y+8, 4, 3, '#FFC800');
}

function drawEnergyDrink(c, x, y) {
  // Can body (silver with cyan accent)
  rect(c, x+2, y+2, 8, 14, '#C0C0C0');
  rect(c, x+2, y+4, 8, 10, '#00D4FF');
  // Rim
  rect(c, x+2, y, 8, 2, '#A0A0A0');
  // Lightning bolt
  rect(c, x+4, y+6, 2, 4, '#FFFFFF');
  rect(c, x+5, y+7, 2, 3, '#FFFFFF');
}

function drawSucculent(c, x, y) {
  // Terracotta pot
  rect(c, x+2, y+10, 10, 6, C.vPot || '#8D6E63');
  rect(c, x+1, y+9, 12, 2, C.vPot || '#8D6E63');
  // Soil
  rect(c, x+3, y+8, 8, 2, '#5D4037');
  // Succulent leaves (rosette pattern)
  rect(c, x+4, y+4, 6, 5, C.vSucculent || '#4CAF50');
  rect(c, x+3, y+5, 2, 3, C.vSucculentD || '#2E7D32');
  rect(c, x+9, y+5, 2, 3, C.vSucculentD || '#2E7D32');
  rect(c, x+5, y+3, 4, 2, '#66BB6A'); // lighter center
  rect(c, x+6, y+2, 2, 2, '#81C784'); // top highlight
}

function drawSketchbook(c, x, y) {
  // Book body (cream/tan)
  rect(c, x+1, y+4, 12, 10, '#E8DCC8');
  // Spine
  rect(c, x, y+4, 2, 10, '#C8B890');
  // Cover lines (sketch marks)
  rect(c, x+3, y+6, 8, 1, '#B0A080');
  rect(c, x+3, y+8, 6, 1, '#B0A080');
  rect(c, x+3, y+10, 7, 1, '#B0A080');
  // Pencil resting on top
  rect(c, x+2, y+2, 10, 2, '#FFD54F');
  rect(c, x+11, y+2, 2, 2, '#F5A0A0'); // eraser
  rect(c, x+1, y+2, 2, 2, '#808080');  // tip
}

function drawWorkbench(c, x, y) {
  drawDesk(c, x, y, 100, 20);
  // Tools
  rect(c, x+10, y+2, 16, 3, '#808080'); // wrench
  rect(c, x+30, y+3, 12, 2, '#A0A0A0'); // screwdriver
  rect(c, x+50, y+1, 8, 8, '#505060');  // multimeter
  rect(c, x+52, y+3, 4, 4, '#003030');
  rect(c, x+70, y+2, 6, 6, '#404050');  // component
  rect(c, x+80, y+4, 14, 3, '#606070'); // pliers
}

function drawOscilloscope(c, x, y) {
  rect(c, x, y, 30, 24, '#303040');
  rect(c, x+3, y+3, 24, 14, '#001810');
  // Wave
  for (let i = 0; i < 20; i += 2) {
    const wy = y + 10 + Math.sin(i * 0.8) * 4;
    rect(c, x+5+i, wy|0, 2, 1, '#00FF80');
  }
  // Knobs
  rect(c, x+6, y+19, 4, 4, '#505060');
  rect(c, x+14, y+19, 4, 4, '#505060');
  rect(c, x+22, y+19, 4, 4, '#505060');
}

function drawShelf(c, x, y, w) {
  rect(c, x, y, w, 50, C.shelf);
  // Books - deterministic widths (no Math.random to prevent twitching)
  const bookWidthsTop = [6, 5, 7, 5, 6, 5, 7];
  const books = [C.book1,C.book2,C.book3,C.book4,C.book1,C.book2,C.book3];
  let bx = x + 3;
  for (let i = 0; i < books.length; i++) {
    const bw = bookWidthsTop[i % bookWidthsTop.length];
    if (bx + bw > x + w - 3) break;
    rect(c, bx, y+3, bw, 20, books[i]);
    bx += bw + 2;
  }
  rect(c, x, y+25, w, 2, C.wallTrim);
  // Lower shelf books - deterministic widths
  const bookWidthsBottom = [6, 5, 6, 7, 5];
  bx = x + 3;
  for (let i = 0; i < 5; i++) {
    const bw = bookWidthsBottom[i];
    rect(c, bx, y+28, bw, 18, [C.book3,C.book4,C.book1,C.book2,C.book3][i]);
    bx += bw + 2;
  }
}

function drawCouch(c, x, y, w) {
  rect(c, x, y+6, w, 18, C.couch);
  rect(c, x+2, y+8, w-4, 12, C.couchL);
  rect(c, x, y, 6, 24, C.couchD); // arm
  rect(c, x+w-6, y, 6, 24, C.couchD); // arm
  rect(c, x, y-4, w, 6, C.couch); // back
  // Cushion lines
  rect(c, x+w/3|0, y+8, 1, 12, C.couchD);
  rect(c, x+(w*2/3)|0, y+8, 1, 12, C.couchD);
}

function drawFridge(c, x, y) {
  rect(c, x, y, 24, 50, C.fridge);
  rect(c, x, y, 24, 2, C.fridgeD);
  rect(c, x, y+28, 24, 2, C.fridgeD);
  rect(c, x+20, y+8, 2, 16, C.fridgeD);
  rect(c, x+20, y+34, 2, 12, C.fridgeD);
}

function drawCoffeeMachine(c, x, y) {
  rect(c, x, y, 16, 20, C.coffee);
  rect(c, x+2, y+2, 12, 8, '#1A1A1A');
  rect(c, x+4, y+12, 8, 6, C.coffeePot);
  rect(c, x+12, y+4, 3, 3, C.red); // light
}

function drawCabinet(c, x, y, w) {
  rect(c, x, y, w, 30, C.cabinet);
  rect(c, x, y, w, 2, C.cabinetD);
  // Doors
  const dw = (w-6)/3;
  for (let i = 0; i < 3; i++) {
    const dx = x+3+i*(dw+1);
    rect(c, dx, y+4, dw-1, 22, C.cabinetD);
    rect(c, dx+dw/2-1|0, y+14, 2, 4, '#808080');
  }
}

function drawWhiteboard(c, x, y) {
  rect(c, x, y, 80, 50, C.wbBorder);
  rect(c, x+3, y+3, 74, 44, C.wb);
  // Scribbles
  for (let i = 0; i < 5; i++) {
    rect(c, x+8+i*12, y+10+i*6, 20, 1, '#4040A0');
  }
  rect(c, x+10, y+20, 30, 15, 'rgba(200,60,60,0.3)');
  // Marker tray
  rect(c, x+10, y+50, 60, 4, C.wbBorder);
  rect(c, x+15, y+49, 6, 3, '#CC3333');
  rect(c, x+24, y+49, 6, 3, '#3333CC');
  rect(c, x+33, y+49, 6, 3, '#33CC33');
}

function drawPingPong(c, x, y) {
  // Table
  rect(c, x, y, 70, 36, C.pingpong);
  rect(c, x, y, 70, 2, '#184828');
  rect(c, x, y+34, 70, 2, '#184828');
  rect(c, x, y, 2, 36, '#184828');
  rect(c, x+68, y, 2, 36, '#184828');
  // Center line
  rect(c, x+34, y, 2, 36, C.ppNet);
  // Legs
  rect(c, x+5, y+36, 4, 10, C.ppLeg);
  rect(c, x+61, y+36, 4, 10, C.ppLeg);
}

function drawWaterCooler(c, x, y) {
  rect(c, x, y+14, 14, 26, C.cooler);
  rect(c, x+1, y, 12, 16, C.coolerJug);
  rect(c, x+4, y+2, 6, 10, '#C0E0F0');
  rect(c, x+6, y+30, 2, 4, '#606060');
  // Cup
  rect(c, x+16, y+34, 5, 5, '#E0E0E0');
}

function drawBeanBag(c, x, y, col) {
  // Oval-ish shape
  rect(c, x+2, y, 16, 4, col);
  rect(c, x, y+4, 20, 10, col);
  rect(c, x+2, y+14, 16, 4, col);
}

function drawPlant(c, x, y, size) {
  const s = size || 1;
  // Pot
  rect(c, x+2*s, y+10*s, 8*s, 8*s, C.pot);
  rect(c, x+1*s, y+10*s, 10*s, 2*s, C.potD);
  rect(c, x+3*s, y+18*s, 6*s, 2*s, C.potD);
  // Leaves
  rect(c, x+4*s, y+4*s, 4*s, 6*s, C.plant);
  rect(c, x+1*s, y+2*s, 3*s, 5*s, C.plantL);
  rect(c, x+8*s, y+3*s, 3*s, 4*s, C.plantL);
  rect(c, x+5*s, y, 2*s, 4*s, C.plantD);
}

function drawBed(c, x, y, width = 90, orientation = 'left') {
  const height = 36;
  rect(c, x, y, width, height, '#1A1F2A');
  rect(c, x+4, y+4, width-8, height-12, '#2A3140');
  rect(c, x+6, y+height-14, width-12, 10, '#0F141E');
  const pillowW = 26;
  if (orientation === 'left') {
    rect(c, x+6, y+6, pillowW, 12, '#C9CED6');
  } else {
    rect(c, x+width-pillowW-6, y+6, pillowW, 12, '#C9CED6');
  }
}

function drawDogBed(c, x, y) {
  rect(c, x, y, 36, 8, '#4A2A1A');
  rect(c, x+3, y-10, 30, 10, '#C08958');
  rect(c, x+8, y-6, 20, 6, '#F0E3C2');
}

function drawServerRack(c, x, y) {
  rect(c, x, y, 22, 44, '#101822');
  for (let i = 0; i < 5; i++) {
    rect(c, x+3, y+6+i*8, 16, 3, i%2 === 0 ? '#00D4FF' : '#FF5F82');
  }
  rect(c, x+6, y+34, 10, 2, '#00FFB7');
}

function drawMiniFridge(c, x, y) {
  rect(c, x, y, 24, 32, '#3A4A64');
  rect(c, x+2, y+4, 20, 20, '#B0C4DA');
  rect(c, x+18, y+6, 3, 12, '#708090');
}

function drawBlueprintDesk(c, x, y) {
  rect(c, x, y, 78, 28, '#162033');
  rect(c, x+4, y+4, 70, 20, '#1B4A73');
  rect(c, x+10, y+8, 20, 10, '#6EC1FF');
  rect(c, x+38, y+6, 30, 4, '#C0D4EA');
  rect(c, x+46, y+16, 18, 3, '#5AA5FF');
}

function drawBookshelf(c, x, y, w) {
  rect(c, x, y, w, 36, '#2A1E28');
  for (let i = 0; i < 4; i++) {
    rect(c, x+4+i*12, y+6, 8, 18, ['#FF8C00','#00D4FF','#C04A7D','#8BD77A'][i%4]);
  }
}

// ===== QUARTERS ITEMS (Vera's Design - Warm Golden Glow) =====
// Item Categories:
// - Medals/Awards: Gold (#FFD700) — service decorations
// - Personal photos: Warm white (#F5F0E6) — family, companions
// - Maps/Tactical: Amber (#FFAA00) — deployment locations
// - Electronics: Cyan glow (#00D4FF) — secure phones
// - Books: Brown/Tan (#8B6914) — journals, albums

const QUARTER_ITEM_PALETTES = {
  medals: { main:'#FFD700', shine:'#FFEC8B', dark:'#B8860B', ribbon:'#8B0000' },
  tacticalMap: { main:'#FFAA00', lines:'#FFD700', dark:'#8B6914', pin:'#FF4444' },
  securePhone: { main:'#00D4FF', screen:'#003040', glow:'#00FFFF', dark:'#006080' },
  familyPhoto: { main:'#F5F0E6', frame:'#8B7355', dark:'#5C4033', photo:'#FFE4C4' },
  serverArray: { main:'#00D4FF', dark:'#003040', light:'#40E0D0', led:'#FF00FF' },
  retroConsole: { main:'#2A2A35', dark:'#1A1A25', light:'#3A3A45', led:'#00FF00' },
  coffeeMug: { main:'#8B6914', dark:'#3D2817', steam:'#AAAAAA', liquid:'#5C4A1E' },
  catPhoto: { main:'#F5F0E6', frame:'#C0A080', dark:'#8B7355' },
  worldMap: { main:'#FFAA00', ocean:'#1A3A5A', land:'#4A6A3A', lines:'#FFD700' },
  journal: { main:'#8B6914', pages:'#F5F0E6', dark:'#5C4A1E', strap:'#3D2817' },
  diploma: { main:'#F5F0E6', frame:'#FFD700', dark:'#8B7355', seal:'#CC0000' },
  fabricSwatches: { main:'#E74C3C', blue:'#3498DB', yellow:'#F1C40F', green:'#2ECC71' },
  designBooks: { main:'#8B6914', cover1:'#E74C3C', cover2:'#3498DB', cover3:'#9B59B6' },
  polaroidWall: { main:'#FFFFFF', border:'#F5F0E6', photo:'#FFE4B5' },
  incense: { main:'#8B7355', holder:'#2A2520', glow:'#FF6B35', smoke:'#AAAAAA' }
};

function drawMedals(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.medals;
  const s = 2; // Scale
  // Gold glow effect
  c.fillStyle = 'rgba(255, 215, 0, 0.2)';
  c.fillRect(x-2, y-2, 32, 20);
  // Ribbon
  rect(c, x+12, y, 8, 6, p.ribbon);
  rect(c, x+14, y+2, 4, 2, p.dark);
  // Medal circles
  rect(c, x+4, y+6, 8, 8, p.main);
  rect(c, x+6, y+8, 4, 4, p.shine);
  rect(c, x+20, y+6, 8, 8, p.main);
  rect(c, x+22, y+8, 4, 4, p.shine);
  // Bottom medals (smaller)
  rect(c, x+8, y+14, 6, 6, p.dark);
  rect(c, x+18, y+14, 6, 6, p.dark);
}

function drawTacticalMap(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.tacticalMap;
  // Amber glow
  c.fillStyle = 'rgba(255, 170, 0, 0.15)';
  c.fillRect(x-2, y-2, 52, 38);
  // Map background
  rect(c, x, y, 48, 32, p.dark);
  // Grid lines
  for (let i = 0; i < 48; i += 8) {
    rect(c, x+i, y, 1, 32, p.lines);
  }
  for (let j = 0; j < 32; j += 8) {
    rect(c, x, y+j, 48, 1, p.lines);
  }
  // Map markers
  rect(c, x+16, y+12, 4, 4, p.pin);
  rect(c, x+32, y+20, 4, 4, p.pin);
  rect(c, x+8, y+24, 3, 3, p.main);
  rect(c, x+40, y+8, 3, 3, p.main);
  // Border
  rect(c, x, y, 48, 1, p.main);
  rect(c, x, y+31, 48, 1, p.main);
  rect(c, x, y, 1, 32, p.main);
  rect(c, x+47, y, 1, 32, p.main);
}

function drawSecurePhone(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.securePhone;
  // Cyan glow effect
  c.fillStyle = 'rgba(0, 212, 255, 0.25)';
  c.fillRect(x-2, y-2, 20, 28);
  // Phone body
  rect(c, x, y, 16, 24, p.dark);
  // Screen
  rect(c, x+2, y+2, 12, 14, p.screen);
  // Screen glow lines
  rect(c, x+3, y+4, 10, 1, p.glow);
  rect(c, x+3, y+7, 8, 1, p.glow);
  rect(c, x+3, y+10, 10, 1, p.glow);
  // Keypad
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      rect(c, x+2+j*4, y+18+i*3, 3, 2, p.main);
    }
  }
  // Antenna
  rect(c, x+6, y-4, 2, 4, p.main);
  rect(c, x+5, y-5, 4, 1, p.main);
}

function drawFamilyPhoto(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.familyPhoto;
  // Warm white glow
  c.fillStyle = 'rgba(245, 240, 230, 0.15)';
  c.fillRect(x-1, y-1, 22, 26);
  // Frame
  rect(c, x, y, 20, 24, p.frame);
  // Photo background (warm)
  rect(c, x+2, y+2, 16, 16, p.photo);
  // Silhouettes
  rect(c, x+6, y+10, 4, 6, p.dark);
  rect(c, x+5, y+12, 2, 4, p.dark);
  rect(c, x+10, y+10, 4, 6, p.dark);
  rect(c, x+11, y+12, 2, 4, p.dark);
  // Child silhouette
  rect(c, x+8, y+14, 3, 4, p.dark);
}

function drawServerArray(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.serverArray;
  // Cyan glow
  c.fillStyle = 'rgba(0, 212, 255, 0.15)';
  c.fillRect(x-1, y-1, 18, 36);
  // Server rack
  rect(c, x, y, 16, 34, p.dark);
  // Server units with LEDs
  for (let i = 0; i < 5; i++) {
    rect(c, x+2, y+2+i*6, 12, 4, '#1A1A2A');
    rect(c, x+3, y+3+i*6, 3, 2, p.led);
    rect(c, x+8, y+4+i*6, 4, 1, i % 2 === 0 ? p.main : p.light);
  }
}

function drawRetroConsole(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.retroConsole;
  // Subtle glow
  c.fillStyle = 'rgba(0, 255, 0, 0.1)';
  c.fillRect(x-1, y-1, 28, 14);
  // Console body
  rect(c, x, y, 26, 12, p.dark);
  // Cartridge slot
  rect(c, x+8, y-2, 10, 3, p.light);
  // Power LED
  rect(c, x+3, y+4, 2, 2, p.led);
  // Controller ports
  rect(c, x+18, y+6, 6, 2, '#1A1A1A');
}

function drawCoffeeMug(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.coffeeMug;
  // Warm glow
  c.fillStyle = 'rgba(139, 105, 20, 0.15)';
  c.fillRect(x-1, y-1, 14, 18);
  // Mug body
  rect(c, x, y, 10, 14, p.main);
  rect(c, x+10, y+2, 3, 8, p.main);
  // Coffee inside
  rect(c, x+1, y+1, 8, 2, '#3D2817');
  // Steam
  rect(c, x+2, y-3, 1, 3, p.steam);
  rect(c, x+6, y-4, 1, 3, p.steam);
}

function drawCatPhoto(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.catPhoto;
  // Warm glow
  c.fillStyle = 'rgba(245, 240, 230, 0.15)';
  c.fillRect(x-1, y-1, 20, 24);
  // Frame
  rect(c, x, y, 18, 22, p.frame);
  // Photo
  rect(c, x+2, y+2, 14, 14, '#FFE4C4');
  // Cat silhouette (ears)
  rect(c, x+6, y+6, 2, 2, p.dark);
  rect(c, x+10, y+6, 2, 2, p.dark);
  rect(c, x+5, y+8, 8, 4, p.dark);
  // Eyes
  rect(c, x+7, y+10, 1, 1, p.main);
  rect(c, x+10, y+10, 1, 1, p.main);
}

function drawWorldMap(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.worldMap;
  // Amber glow
  c.fillStyle = 'rgba(255, 170, 0, 0.12)';
  c.fillRect(x-2, y-2, 44, 30);
  // Map background (ocean)
  rect(c, x, y, 40, 26, p.ocean);
  // Continents (simplified)
  rect(c, x+4, y+6, 10, 8, p.land);
  rect(c, x+18, y+4, 12, 10, p.land);
  rect(c, x+6, y+16, 8, 6, p.land);
  rect(c, x+28, y+8, 8, 10, p.land);
  // Grid lines
  rect(c, x+20, y+2, 1, 22, p.lines);
  rect(c, x+2, y+13, 36, 1, p.lines);
  // Border
  rect(c, x, y, 40, 1, p.main);
  rect(c, x, y+25, 40, 1, p.main);
  rect(c, x, y, 1, 26, p.main);
  rect(c, x+39, y, 1, 26, p.main);
}

function drawJournal(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.journal;
  // Warm brown glow
  c.fillStyle = 'rgba(139, 105, 20, 0.15)';
  c.fillRect(x-1, y-1, 18, 22);
  // Book cover
  rect(c, x, y, 16, 20, p.main);
  // Spine
  rect(c, x, y, 3, 20, p.dark);
  // Pages
  rect(c, x+3, y+2, 12, 16, p.pages);
  // Lines on page
  rect(c, x+5, y+5, 8, 1, '#CCCCCC');
  rect(c, x+5, y+8, 8, 1, '#CCCCCC');
  rect(c, x+5, y+11, 6, 1, '#CCCCCC');
  // Leather strap
  rect(c, x+10, y-1, 2, 3, p.strap);
}

function drawDiploma(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.diploma;
  // Warm glow
  c.fillStyle = 'rgba(245, 240, 230, 0.15)';
  c.fillRect(x-1, y-1, 30, 22);
  // Document
  rect(c, x, y, 28, 20, p.main);
  // Frame corners
  rect(c, x+2, y+2, 4, 4, p.frame);
  rect(c, x+22, y+2, 4, 4, p.frame);
  rect(c, x+2, y+14, 4, 4, p.frame);
  rect(c, x+22, y+14, 4, 4, p.frame);
  // Text lines
  rect(c, x+6, y+6, 16, 1, p.dark);
  rect(c, x+4, y+9, 20, 1, p.dark);
  rect(c, x+8, y+11, 12, 1, p.dark);
  // Seal
  rect(c, x+22, y+14, 4, 4, p.seal);
}

function drawFabricSwatches(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.fabricSwatches;
  // Subtle warm glow
  c.fillStyle = 'rgba(255, 255, 255, 0.1)';
  c.fillRect(x-1, y-1, 30, 24);
  // Swatches pinned to cork/board
  rect(c, x+2, y+4, 8, 8, p.main);
  rect(c, x+11, y+2, 8, 10, p.blue);
  rect(c, x+20, y+4, 8, 8, p.yellow);
  rect(c, x+6, y+13, 8, 8, p.green);
  rect(c, x+15, y+14, 8, 8, p.main);
  // Pins
  rect(c, x+5, y+2, 1, 2, '#666666');
  rect(c, x+14, y, 1, 2, '#666666');
  rect(c, x+23, y+2, 1, 2, '#666666');
  rect(c, x+9, y+11, 1, 2, '#666666');
}

function drawDesignBooks(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.designBooks;
  // Warm glow
  c.fillStyle = 'rgba(139, 105, 20, 0.12)';
  c.fillRect(x-1, y-1, 28, 34);
  // Stacked books
  rect(c, x, y+20, 26, 12, p.main); // Bottom
  rect(c, x+1, y+21, 24, 10, p.dark);
  rect(c, x+2, y+8, 24, 12, p.cover1); // Middle
  rect(c, x+3, y+9, 22, 10, '#C0392B');
  rect(c, x+4, y-2, 20, 10, p.cover2); // Top
  rect(c, x+5, y-1, 18, 8, '#2980B9');
  // Page edges
  rect(c, x+26, y+9, 2, 11, '#F5F0E6');
  rect(c, x+24, y+21, 2, 10, '#F5F0E6');
}

function drawPolaroidWall(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.polaroidWall;
  // Warm glow
  c.fillStyle = 'rgba(255, 255, 255, 0.12)';
  c.fillRect(x-1, y-1, 36, 28);
  // Polaroids scattered
  rect(c, x, y, 14, 16, p.border);
  rect(c, x+2, y+2, 10, 10, p.photo);
  rect(c, x+18, y+4, 12, 14, p.border);
  rect(c, x+20, y+6, 8, 8, p.photo);
  rect(c, x+4, y+14, 10, 12, p.border);
  rect(c, x+6, y+16, 6, 8, p.photo);
}

function drawIncense(c, x, y) {
  const p = QUARTER_ITEM_PALETTES.incense;
  // Warm orange glow
  c.fillStyle = 'rgba(255, 107, 53, 0.15)';
  c.fillRect(x-1, y-1, 12, 28);
  // Holder
  rect(c, x+2, y+16, 8, 10, p.holder);
  // Stick
  rect(c, x+5, y+4, 2, 14, '#D4A574');
  // Glowing tip
  rect(c, x+5, y+2, 2, 2, p.glow);
  // Smoke
  rect(c, x+4, y-4, 1, 6, p.smoke);
  rect(c, x+7, y-3, 1, 5, p.smoke);
}

// ===== QUARTER ITEM DRAWING FUNCTION =====
function drawQuarterItem(c, itemType, x, y) {
  switch(itemType) {
    case 'medals': drawMedals(c, x, y); break;
    case 'tacticalMap': drawTacticalMap(c, x, y); break;
    case 'securePhone': drawSecurePhone(c, x, y); break;
    case 'familyPhoto': drawFamilyPhoto(c, x, y); break;
    case 'serverArray': drawServerArray(c, x, y); break;
    case 'retroConsole': drawRetroConsole(c, x, y); break;
    case 'coffeeMug': drawCoffeeMug(c, x, y); break;
    case 'catPhoto': drawCatPhoto(c, x, y); break;
    case 'worldMap': drawWorldMap(c, x, y); break;
    case 'journal': drawJournal(c, x, y); break;
    case 'diploma': drawDiploma(c, x, y); break;
    case 'fabricSwatches': drawFabricSwatches(c, x, y); break;
    case 'designBooks': drawDesignBooks(c, x, y); break;
    case 'polaroidWall': drawPolaroidWall(c, x, y); break;
    case 'incense': drawIncense(c, x, y); break;
  }
}

// Track quarter item positions for hover detection
let quarterItemPositions = [];
initCollisionBoxes(); // Initialize collision after all variables defined

function getQuarterItemTooltip(itemType) {
  const tooltips = {
    medals: 'Service Medals',
    tacticalMap: 'Tactical Deployment Map',
    securePhone: 'Secure Communication Phone',
    familyPhoto: 'Family Photograph',
    serverArray: 'Server Array',
    retroConsole: 'Retro Gaming Console',
    coffeeMug: 'Coffee Mug',
    catPhoto: 'Mittens the Cat',
    worldMap: 'World Map',
    journal: 'Personal Journal',
    diploma: 'Engineering Diploma',
    fabricSwatches: 'Fabric Design Swatches',
    designBooks: 'Design Reference Books',
    polaroidWall: 'Polaroid Photo Wall',
    incense: 'Incense Holder'
  };
  return tooltips[itemType] || itemType;
}

// Get glow color based on item category (Vera's design palette)
function getItemGlowColor(itemType) {
  const glows = {
    medals: 'rgba(255, 215, 0, 0.5)',        // Gold
    tacticalMap: 'rgba(255, 170, 0, 0.4)',    // Amber
    securePhone: 'rgba(0, 212, 255, 0.5)',    // Cyan
    familyPhoto: 'rgba(245, 240, 230, 0.4)',  // Warm white
    serverArray: 'rgba(0, 212, 255, 0.4)',    // Cyan
    retroConsole: 'rgba(0, 255, 0, 0.3)',     // Green
    coffeeMug: 'rgba(139, 105, 20, 0.4)',     // Brown
    catPhoto: 'rgba(245, 240, 230, 0.4)',     // Warm white
    worldMap: 'rgba(255, 170, 0, 0.4)',       // Amber
    journal: 'rgba(139, 105, 20, 0.4)',       // Brown/Tan
    diploma: 'rgba(255, 215, 0, 0.4)',        // Gold
    fabricSwatches: 'rgba(245, 240, 230, 0.3)', // Warm white
    designBooks: 'rgba(139, 105, 20, 0.35)',  // Brown/Tan
    polaroidWall: 'rgba(245, 240, 230, 0.35)', // Warm white
    incense: 'rgba(255, 107, 53, 0.4)'       // Orange
  };
  return glows[itemType] || 'rgba(255, 215, 0, 0.3)';
}

function getItemTextColor(itemType) {
  const colors = {
    medals: '#FFD700', tacticalMap: '#FFAA00', securePhone: '#00D4FF',
    familyPhoto: '#F5F0E6', serverArray: '#00D4FF', retroConsole: '#00FF00',
    coffeeMug: '#D4A574', catPhoto: '#F5F0E6', worldMap: '#FFAA00',
    journal: '#D4A574', diploma: '#FFD700', fabricSwatches: '#F5F0E6',
    designBooks: '#D4A574', polaroidWall: '#F5F0E6', incense: '#FF6B35'
  };
  return colors[itemType] || '#FFD700';
}

function drawQuarterItemTooltip(c) {
  if (!hoveredQuarterItem) return;
  const item = hoveredQuarterItem;
  const label = getQuarterItemTooltip(item.item);
  const textColor = getItemTextColor(item.item);
  const glowColor = getItemGlowColor(item.item);
  
  c.font = 'bold 8px "JetBrains Mono"';
  const textW = c.measureText(label).width;
  const padX = 8, padY = 4;
  const tooltipW = textW + padX * 2;
  const tooltipH = 16;
  
  // Position tooltip above the item, centered
  let tx = item.x + item.width / 2 - tooltipW / 2;
  let ty = item.y - tooltipH - 6;
  
  // Clamp to canvas bounds
  if (tx < 4) tx = 4;
  if (tx + tooltipW > TARGET_WIDTH - 4) tx = TARGET_WIDTH - tooltipW - 4;
  if (ty < 4) ty = item.y + item.height + 4; // flip below if too high
  
  // Warm glow outline around hovered item
  c.save();
  c.shadowColor = glowColor;
  c.shadowBlur = 8;
  c.strokeStyle = textColor;
  c.lineWidth = 1;
  c.strokeRect(item.x - 2, item.y - 2, item.width + 4, item.height + 4);
  c.restore();
  
  // Tooltip background (dark with warm tint)
  c.fillStyle = 'rgba(20, 16, 10, 0.92)';
  c.beginPath();
  c.roundRect(tx, ty, tooltipW, tooltipH, 4);
  c.fill();
  
  // Tooltip border with item glow color
  c.strokeStyle = textColor;
  c.globalAlpha = 0.6;
  c.lineWidth = 1;
  c.beginPath();
  c.roundRect(tx, ty, tooltipW, tooltipH, 4);
  c.stroke();
  c.globalAlpha = 1;
  
  // Tooltip text
  c.fillStyle = textColor;
  c.font = 'bold 8px "JetBrains Mono"';
  c.textAlign = 'left';
  c.textBaseline = 'middle';
  c.fillText(label, tx + padX, ty + tooltipH / 2);
  c.textBaseline = 'alphabetic'; // reset
}

// Vera's quarters furniture
function drawDesignDesk(c, x, y) {
  // Design desk - larger than regular desk, with drafting surface
  rect(c, x, y, 90, 22, '#5C4A38');
  rect(c, x, y+22, 90, 3, '#4A3728');
  // Legs
  rect(c, x+4, y+25, 4, 10, '#3A2A1C');
  rect(c, x+82, y+25, 4, 10, '#3A2A1C');
  // Drafting surface (lighter wood tone)
  rect(c, x+6, y+4, 78, 14, '#C4A77D');
  // Ruler on desk
  rect(c, x+10, y+6, 40, 2, '#A08060');
  // Color swatches (small colored squares)
  rect(c, x+56, y+8, 6, 6, '#E74C3C');
  rect(c, x+64, y+8, 6, 6, '#3498DB');
  rect(c, x+72, y+8, 6, 6, '#F1C40F');
}

function drawMoodBoard(c, x, y) {
  // Cork/mood board on wall
  rect(c, x, y, 70, 50, '#8D6E63');
  rect(c, x+2, y+2, 66, 46, '#A1887F');
  // Various inspiration images/fabric swatches
  rect(c, x+6, y+6, 20, 15, '#E8DCC8'); // beige swatch
  rect(c, x+28, y+6, 18, 12, '#D4A574'); // warm tone
  rect(c, x+50, y+8, 14, 18, '#5C4A38'); // dark wood
  rect(c, x+8, y+24, 16, 14, '#4CAF50'); // green accent
  rect(c, x+26, y+22, 20, 16, '#3F51B5'); // blue accent
  // Push pins
  rect(c, x+14, y+8, 2, 2, '#CC3333');
  rect(c, x+35, y+10, 2, 2, '#CC3333');
  rect(c, x+56, y+14, 2, 2, '#CC3333');
}

function drawArtSupplies(c, x, y) {
  // Paint/pencil holder
  rect(c, x+4, y+10, 12, 14, '#8D6E63');
  // Brushes/pencils sticking out
  rect(c, x+6, y+2, 2, 10, '#D4A574');
  rect(c, x+9, y, 2, 12, '#4CAF50');
  rect(c, x+12, y+3, 2, 9, '#2196F3');
  // Palette
  rect(c, x+20, y+8, 16, 12, '#D4A574');
  rect(c, x+24, y+10, 4, 4, '#E74C3C');
  rect(c, x+30, y+11, 3, 3, '#F1C40F');
}

function drawRug(c, x, y, w, h, color) {
  rect(c, x, y, w, h, color);
  strokeRect(c, x, y, w, h, 'rgba(0,0,0,0.2)');
}

// ===== POD DRAWING =====
function drawPod(c, pod, agent) {
  const { x, y, w, h } = pod;
  const t = 4;
  // Floor
  drawFloor(c, x+t, y+t, w-t*2, h-t*2);
  // Walls
  rect(c, x, y, w, t, C.wallTop);
  rect(c, x, y, t, h, C.wall);
  rect(c, x+w-t, y, t, h, C.wall);
  // Bottom wall with door
  const doorW = 40;
  const doorX = x + (w-doorW)/2;
  rect(c, x, y+h-t, doorX-x, t, C.wallTop);
  rect(c, doorX+doorW, y+h-t, (x+w)-(doorX+doorW), t, C.wallTop);
  // Desk
  drawDesk(c, x+22, y+16, w-44, 18);
  // Monitor
  drawMonitor(c, x+(w/2)-15|0, y+8, agent && agent.status === 'working');
  // Chair (when no agent sitting)
  if (!agent || agent.state !== 'working') {
    drawChair(c, x+(w/2)-9|0, y+58);
  }
  // Name plate
  if (agent) {
    drawNamePlate(c, x+56, y+6, agent.name, agent.status);
    // Desk items
    if (agent.deskItems) {
      if (agent.deskItems.includes('radio')) drawRadio(c, x+24, y+10);
      if (agent.deskItems.includes('clipboard')) drawClipboard(c, x+w-42, y+8);
      if (agent.deskItems.includes('rubberDuck')) drawRubberDuck(c, x+28, y+8);
      if (agent.deskItems.includes('energyDrink')) drawEnergyDrink(c, x+w-38, y+6);
      if (agent.deskItems.includes('succulent')) drawSucculent(c, x+24, y+6);
      if (agent.deskItems.includes('sketchbook')) drawSketchbook(c, x+w-42, y+8);
    }
  } else {
    const vacX = x + 40;
    const vacY = y + 24;
    const vacW = w - 80;
    const vacH = 32;
    c.fillStyle = '#0F1520';
    c.beginPath();
    c.roundRect(vacX, vacY, vacW, vacH, 6);
    c.fill();
    strokeRect(c, vacX, vacY, vacW, vacH, '#1F2A38');
    c.fillStyle = '#3A9A5A';
    c.font = 'bold 10px "JetBrains Mono"';
    const vacLabel = 'VACANT';
    const vacLabelW = c.measureText(vacLabel).width;
    c.fillText(vacLabel, vacX + (vacW - vacLabelW) / 2, vacY + 18);
    c.fillStyle = '#5A6A7A';
    c.font = '7px "JetBrains Mono"';
    const vacSub = 'RECRUITING';
    const vacSubW = c.measureText(vacSub).width;
    c.fillText(vacSub, vacX + (vacW - vacSubW) / 2, vacY + 28);
  }
  // Pod number (dim)
  c.fillStyle = C.barDim;
  c.font = '7px "JetBrains Mono"';
  c.fillText('P'+(PODS.indexOf(pod)), x+8, y+h-8);
}

// ===== RENDER ROOMS =====
function renderRDLab(c) {
  const r = ROOMS[0];
  drawWalls(c, r);
  drawWorkbench(c, r.x+20, r.y+30);
  drawOscilloscope(c, r.x+140, r.y+24);
  drawShelf(c, r.x+180, r.y+12, 50);
  drawPlant(c, r.x+18, r.y+80, 1.5);
  // Parts bins
  rect(c, r.x+80, r.y+70, 40, 20, '#404050');
  rect(c, r.x+82, r.y+72, 16, 16, '#303040');
  rect(c, r.x+102, r.y+72, 16, 16, '#303040');
}

function renderCommand(c) {
  const r = ROOMS[1];
  drawWalls(c, r);
  // Big desk
  drawDesk(c, r.x+30, r.y+20, 100, 22);
  drawMonitor(c, r.x+60, r.y+10, true);
  drawChair(c, r.x+70, r.y+56);
  // Couch
  drawCouch(c, r.x+160, r.y+60, 70);
  // Shelf
  drawShelf(c, r.x+20, r.y+100, 80);
  drawPlant(c, r.x+200, r.y+100, 1.2);
}

function renderGalley(c) {
  const r = ROOMS[2];
  drawWalls(c, r);
  drawCabinet(c, r.x+15, r.y+14, 90);
  drawFridge(c, r.x+140, r.y+16);
  drawCoffeeMachine(c, r.x+180, r.y+30);
  // Counter
  rect(c, r.x+15, r.y+60, 140, 16, C.deskTop);
  rect(c, r.x+15, r.y+76, 140, 3, C.desk);
  // Stools
  for (let i = 0; i < 3; i++) {
    rect(c, r.x+30+i*40, r.y+90, 14, 4, C.chairSeat);
    rect(c, r.x+35+i*40, r.y+94, 4, 10, C.chair);
  }
  drawPlant(c, r.x+190, r.y+90, 1);
}

function renderBriefing(c) {
  const r = ROOMS[3];
  drawWalls(c, r);
  // Conference table
  drawDesk(c, r.x+60, r.y+40, 120, 22);
  // Chairs around table
  for (let i = 0; i < 4; i++) {
    drawChair(c, r.x+70+i*28, r.y+75);
  }
  // Whiteboard on wall
  drawWhiteboard(c, r.x+20, r.y+12);
  // Shelf
  drawShelf(c, r.x+220, r.y+14, 60);
  // Plants
  drawPlant(c, r.x+18, r.y+120, 1.2);
  drawPlant(c, r.x+280, r.y+120, 1);
}

function renderLounge(c) {
  const x = LOUNGE_X, y = LOUNGE_Y, w = LOUNGE_W, h = LOUNGE_H;
  // Floor
  drawFloor(c, x+5, y+5, w-10, h-10);
  // Walls
  rect(c, x, y, w, 5, C.wallTop);
  rect(c, x+w-5, y, 5, h, C.wall);
  rect(c, x, y, 5, h, C.wall);
  // Bottom wall with door
  const doorW = 46;
  const doorX = x + 20;
  rect(c, x, y+h-5, doorX-x, 5, C.wallTop);
  rect(c, doorX+doorW, y+h-5, (x+w)-(doorX+doorW), 5, C.wallTop);
  // Labels - make more visible
  c.fillStyle = '#5A7A9A';
  c.font = 'bold 10px "JetBrains Mono"';
  c.fillText('LOUNGE & REC', x+10, y+14);
  // Whiteboard
  drawWhiteboard(c, x+20, y+30);
  // Coffee table
  rect(c, x+30, y+110, 40, 24, C.desk);
  rect(c, x+32, y+112, 36, 20, C.deskTop);
  // Couch
  drawCouch(c, x+20, y+150, 80);
  // Water cooler
  drawWaterCooler(c, x+140, y+40);
  // Bean bags
  drawBeanBag(c, x+180, y+120, C.bean1);
  drawBeanBag(c, x+220, y+150, C.bean2);
  // Ping pong table (compact placement within walls)
  drawPingPong(c, x+320, y+60);
  // Plants
  drawPlant(c, x+260, y+40, 1.2);
  drawPlant(c, x+680, y+130, 1);
  drawPlant(c, x+720, y+40, 0.8);
  // Rec sign
  c.fillStyle = C.hdrDim;
  c.font = '7px "JetBrains Mono"';
  c.fillText('🎯 REC ZONE', x+320, y+50);
}

function drawQuarter(c, quarter) {
  const { x, y, w, h, label, agent } = quarter;
  const t = 4;
  drawFloor(c, x+t, y+t, w-2*t, h-2*t);
  rect(c, x, y, w, t, C.wallTop);
  rect(c, x, y, t, h, C.wall);
  rect(c, x+w-t, y, t, h, C.wall);
  const doorW = 32;
  const doorX = x + (w-doorW)/2;
  rect(c, x, y+h-t, doorX-x, t, C.wallTop);
  rect(c, doorX+doorW, y+h-t, (x+w)-(doorX+doorW), t, C.wallTop);
  c.fillStyle = C.hdrDim;
  c.font = '8px "JetBrains Mono"';
  c.fillText(label, x + 8, y + 14);

  drawRug(c, x+18, y+h-36, w-36, 20, 'rgba(90,110,130,0.2)');

  // Get agent's quarters items
  const agentData = AGENTS.find(a => a.name === agent);
  const items = agentData?.quartersItems || [];

  switch (agent) {
    case 'Flint':
      drawBed(c, x+18, y+28, 88, 'left');
      break;
    case 'Cipher':
      drawBed(c, x+w-110, y+28, 90, 'right');
      break;
    case 'Scrub':
      drawBed(c, x+26, y+32, 88, 'left');
      break;
  }
}

function drawStairs(c, x, y) {
  rect(c, x, y, 40, 50, '#2A2A35');
  for (let i = 0; i < 5; i++) {
    rect(c, x+4, y+8+i*9, 32, 3, '#4A4A5A');
  }
  c.fillStyle = '#6A6A7A';
  c.font = '7px "JetBrains Mono"';
  c.fillText('↕', x+16, y+32);
}

function renderQuarters(c) {
  // Quarters floor label
  c.fillStyle = '#5A7A9A';
  c.font = 'bold 10px "JetBrains Mono"';
  c.fillText('AGENT QUARTERS - FLOOR 2', 20, FLOOR2_Y - 12);
  
  quarterItemPositions = []; // Reset each frame
  QUARTERS.forEach(q => drawQuarter(c, q));
}
function drawQuartersOverlay(ctx) {
  QUARTERS.forEach(q => {
    const ent = entities.find(e => e.name === q.agent);
    if (ent && q.spritePos) {
      const sprites = ent.getSprites();
      drawSprite(ctx, sprites.stand, sprites.pal, q.spritePos.x, q.spritePos.y, 2);
      ctx.fillStyle = ent.status === 'working' ? C.green : C.barDim;
      ctx.font = '7px \"JetBrains Mono\"';
      ctx.fillText(ent.status.toUpperCase(), q.spritePos.x + 26, q.spritePos.y + 10);
    }
    if (q.agent === 'Flint') {
      drawSprite(ctx, LUCKY_IDLE1, LUCKY_PAL, q.spritePos.x + 32, q.spritePos.y + 22, 2);
    }
  });
}



// ===== STATIC BACKGROUND =====
function renderOpsCorridors(c) {
  // Base planks for ops-floor hallways
  drawFloor(c, 10, ROOM_Y + ROOM_H*2 + ROOM_GAP, 780, POD_Y - (ROOM_Y + ROOM_H*2 + ROOM_GAP));
  drawFloor(c, 10, POD_Y + POD_H, 780, LOUNGE_Y - POD_Y - POD_H);
  drawFloor(c, 10, LOUNGE_Y + LOUNGE_H, 780, FLOOR_SEP_Y - LOUNGE_Y - LOUNGE_H);
  // Walkway in quarters area
  drawFloor(c, 10, FLOOR2_Y - 8, 760, 12);
  drawFloor(c, 10, FLOOR2_Y + QUARTER_H, 760, BAR_Y - FLOOR2_Y - QUARTER_H);
  
  // Corridor label
  c.fillStyle = '#5A7A9A';
  c.font = 'bold 10px "JetBrains Mono"';
  c.fillText('MAIN CORRIDOR', 20, POD_Y + POD_H - 5);

  renderCorridorFlow(c);
}

function renderCorridorFlow(c) {
  drawSpinePattern(c, CORRIDOR_SEGMENTS.spine);
  drawCrossbarPattern(c, CORRIDOR_SEGMENTS.upperCross);
  drawCrossbarPattern(c, CORRIDOR_SEGMENTS.lowerCross);
  drawPodLoopPattern(c, CORRIDOR_SEGMENTS.podLoop);
  drawLoungeTurnout(c, CORRIDOR_SEGMENTS.loungeBulb);
  drawCorridorPlants(c);
}

function drawSpinePattern(c, seg) {
  rect(c, seg.x, seg.y, seg.w, seg.h, C.corridorBase);
  const chevronH = 12;
  let step = 0;
  for (let y = seg.y; y < seg.y + seg.h; y += chevronH) {
    const primary = step % 2 === 0 ? C.corridorHighlight : C.corridorAccent;
    const secondary = step % 2 === 0 ? C.corridorAccent : C.corridorHighlight;
    c.fillStyle = primary;
    c.beginPath();
    c.moveTo(seg.x, y);
    c.lineTo(seg.x + seg.w, y);
    c.lineTo(seg.x + seg.w / 2, y + chevronH);
    c.closePath();
    c.fill();
    c.fillStyle = secondary;
    c.beginPath();
    c.moveTo(seg.x, y + chevronH);
    c.lineTo(seg.x + seg.w / 2, y);
    c.lineTo(seg.x + seg.w, y + chevronH);
    c.closePath();
    c.fill();
    step++;
  }
}

function drawCrossbarPattern(c, seg) {
  rect(c, seg.x, seg.y, seg.w, seg.h, C.corridorCross);
  const centerY = seg.y + seg.h / 2 - 1;
  for (let x = seg.x + 6; x < seg.x + seg.w - 6; x += 16) {
    rect(c, x, centerY, 8, 2, C.corridorCrossLine);
  }
  rect(c, seg.x, seg.y, seg.w, 2, 'rgba(255,255,255,0.05)');
  rect(c, seg.x, seg.y + seg.h - 2, seg.w, 2, 'rgba(0,0,0,0.2)');
}

function drawPodLoopPattern(c, loop) {
  c.fillStyle = C.corridorLoop;
  c.beginPath();
  if (c.roundRect) {
    c.roundRect(loop.x, loop.y, loop.w, loop.h, loop.radius);
  } else {
    c.rect(loop.x, loop.y, loop.w, loop.h);
  }
  c.fill();
  c.strokeStyle = C.corridorLoopRail;
  c.lineWidth = 2;
  c.beginPath();
  if (c.roundRect) {
    c.roundRect(loop.x + 4, loop.y + 4, loop.w - 8, loop.h - 8, Math.max(loop.radius - 4, 4));
  } else {
    c.rect(loop.x + 4, loop.y + 4, loop.w - 8, loop.h - 8);
  }
  c.stroke();
  c.beginPath();
  if (c.roundRect) {
    c.roundRect(loop.x + 10, loop.y + 10, loop.w - 20, loop.h - 20, Math.max(loop.radius - 10, 4));
  } else {
    c.rect(loop.x + 10, loop.y + 10, loop.w - 20, loop.h - 20);
  }
  c.stroke();
  drawPodLoopChamfer(c, loop);
}

function drawPodLoopChamfer(c, loop) {
  const spine = CORRIDOR_SEGMENTS.spine;
  const chamfer = 10;
  c.fillStyle = C.corridorBase;
  c.beginPath();
  c.moveTo(spine.x + 6, loop.y - chamfer / 2);
  c.lineTo(spine.x + spine.w - 6, loop.y - chamfer / 2);
  c.lineTo(spine.x + spine.w - 10, loop.y);
  c.lineTo(spine.x + 10, loop.y);
  c.closePath();
  c.fill();
  c.beginPath();
  c.moveTo(spine.x + 10, loop.y + loop.h);
  c.lineTo(spine.x + spine.w - 10, loop.y + loop.h);
  c.lineTo(spine.x + spine.w - 6, loop.y + loop.h + chamfer / 2);
  c.lineTo(spine.x + 6, loop.y + loop.h + chamfer / 2);
  c.closePath();
  c.fill();
}

function drawLoungeTurnout(c, bulb) {
  c.fillStyle = C.corridorBase;
  c.beginPath();
  c.arc(bulb.x, bulb.y, bulb.radius, 0, Math.PI * 2);
  c.fill();
  c.strokeStyle = C.corridorAccent;
  c.lineWidth = 1.5;
  c.beginPath();
  c.arc(bulb.x, bulb.y, bulb.radius - 6, 0, Math.PI * 2);
  c.stroke();
  c.strokeStyle = 'rgba(255,255,255,0.18)';
  for (let i = 0; i < 4; i++) {
    const angle = (Math.PI / 2) * i + Math.PI / 4;
    c.beginPath();
    c.moveTo(bulb.x + Math.cos(angle) * 6, bulb.y + Math.sin(angle) * 6);
    c.lineTo(bulb.x + Math.cos(angle) * (bulb.radius - 8), bulb.y + Math.sin(angle) * (bulb.radius - 8));
    c.stroke();
  }
}

function drawCorridorPlants(c) {
  CORRIDOR_PLANTS.forEach(plant => drawCorridorPlant(c, plant));
}

function drawCorridorPlant(c, plant) {
  const size = plant.size || 1;
  const centerX = plant.cx !== undefined ? plant.cx : (plant.x + 6 * size);
  const centerY = plant.cy !== undefined ? plant.cy : (plant.y + 14 * size);
  const x = centerX - 6 * size;
  const y = centerY - 14 * size;
  const tiers = plant.tiers || 1;
  drawCorridorMedallion(c, centerX, centerY + 2 * size, plant.medallionRadius || (8 * size));
  drawPlanterBase(c, x, y, size, tiers);
  drawPlantWithRotation(c, x, y - (tiers > 1 ? 2 * size : 0), size, plant.rotation || 0);
}

function drawCorridorMedallion(c, x, y, radius) {
  const r = Math.max(radius, 4);
  c.fillStyle = C.corridorMedallion;
  c.beginPath();
  c.arc(x, y, r, 0, Math.PI * 2);
  c.fill();
  c.fillStyle = C.corridorMedallionInset;
  c.beginPath();
  c.arc(x, y, Math.max(r - 3, 2), 0, Math.PI * 2);
  c.fill();
}

function drawPlanterBase(c, x, y, size, tiers) {
  const width = 12 * size;
  const totalWidth = width + 4 * size;
  const baseX = x - 2 * size;
  const startY = y + 18 * size;
  for (let i = 0; i < tiers; i++) {
    const offset = i * (4 * size + 2);
    rect(c, baseX, startY + offset, totalWidth, 4 * size, C.potD);
    rect(c, baseX, startY - 2 * size + offset, totalWidth, 2 * size, C.pot);
  }
}

function drawPlantWithRotation(c, x, y, size, rotation) {
  if (!rotation) {
    drawPlant(c, x, y, size);
    return;
  }
  const anchorX = x + 6 * size;
  const anchorY = y + 12 * size;
  c.save();
  c.translate(anchorX, anchorY);
  c.rotate(rotation * Math.PI / 180);
  c.translate(-anchorX, -anchorY);
  drawPlant(c, x, y, size);
  c.restore();
}

function renderBackground() {
  const bg = ctx; // render directly to main canvas buffer
  // Base fill for full canvas
  rect(bg, 0, 0, TARGET_WIDTH, TARGET_HEIGHT, C.bg);

  // Header
  rect(bg, 0, 0, TARGET_WIDTH, HDR_H, C.hdrBg);
  rect(bg, 0, HDR_H-1, TARGET_WIDTH, 1, C.hdrBorder);
  bg.fillStyle = C.hdrText;
  bg.font = 'bold 11px "JetBrains Mono"';
  bg.fillText('◆ 87 HIGHLAND LANE', 16, 19);
  bg.fillStyle = C.hdrDim;
  bg.font = '10px "JetBrains Mono"';
  bg.fillText('SECURE OPS CENTER', 230, 19);

  // ── FLOOR 1: OPS ──
  renderOpsCorridors(bg);
  renderRDLab(bg);
  renderCommand(bg);
  renderGalley(bg);
  renderBriefing(bg);
  renderLounge(bg);
  PODS.forEach((pod, i) => {
    const agent = AGENTS.find(a => a.podIndex === i);
    drawPod(bg, pod, agent);
  });

  // Draw desks for agents without pods (Scout & Vera)
  AGENTS.filter(a => a.podIndex === -1 && a.deskPos).forEach(agent => {
    const dx = agent.deskPos.x;
    const dy = agent.deskPos.y;
    // Draw desk
    drawDesk(bg, dx, dy, 80, 18);
    // Draw monitor
    drawMonitor(bg, dx + 30, dy - 8, agent.status === 'working');
    // Draw chair (if not working)
    if (agent.status !== 'working') {
      drawChair(bg, dx + 32, dy + 30);
    }
    // Draw name plate
    drawNamePlate(bg, dx + 50, dy - 2, agent.name, agent.status);
    // Draw desk items
    if (agent.deskItems) {
      if (agent.deskItems.includes('notebook')) drawSketchbook(bg, dx + 4, dy - 2);
      if (agent.deskItems.includes('coffee')) drawCoffeeMachine(bg, dx + 60, dy + 2);
      if (agent.deskItems.includes('succulent')) drawSucculent(bg, dx + 4, dy - 4);
      if (agent.deskItems.includes('sketchbook')) drawSketchbook(bg, dx + 60, dy - 2);
    }
  });

  // ── FLOOR SEPARATOR ──
  rect(bg, 0, FLOOR_SEP_Y, TARGET_WIDTH, 2, '#3A5A7A');
  bg.fillStyle = '#3A5A7A';
  bg.font = 'bold 9px "JetBrains Mono"';
  bg.fillText('▼  QUARTERS LEVEL  ▼', TARGET_WIDTH/2 - 70, FLOOR_SEP_Y + 18);
  drawStairs(bg, 740, FLOOR_SEP_Y - 10);

  // ── FLOOR 2: QUARTERS ──
  renderQuarters(bg);
  drawPlant(bg, 60, FLOOR2_Y+20, 1);
  drawPlant(bg, 720, FLOOR2_Y+40, 1.2);

  // Bottom bar
  rect(bg, 0, BAR_Y, TARGET_WIDTH, BAR_H, C.barBg);
  rect(bg, 0, BAR_Y, TARGET_WIDTH, 1, C.barBorder);
  rect(bg, 0, BAR_Y+1, TARGET_WIDTH, 1, C.barBorder);
}
// ===== SPRITE SYSTEM =====
function drawSprite(ctx, data, pal, x, y, s) {
  for (let r = 0; r < data.length; r++) {
    const row = data[r];
    for (let c = 0; c < row.length; c++) {
      const ch = row[c];
      if (ch !== '.' && pal[ch]) {
        ctx.fillStyle = pal[ch];
        ctx.fillRect((x + c*s)|0, (y + r*s)|0, s, s);
      }
    }
  }
}

// ===== FLINT SPRITES =====
const FLINT_PAL = {
  H:C.fHair, S:C.fSkin, s:C.fSkinS, E:C.fEye,
  J:C.fJacket, j:C.fJacketD, O:C.fAccent,
  B:C.fBelt, P:C.fPants, b:C.fBoots,
};
const FLINT_STAND = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PPPP..',
  '..PP.PP.',
  '..bb.bb.',
];
const FLINT_WALK1 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PP.PP.',
  '.PP...PP',
  '.bb...bb',
];
const FLINT_WALK2 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '.PP..PP.',
  'PP....PP',
  'bb....bb',
];
const FLINT_SIT = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
];

// ===== CIPHER SPRITES =====
const CIPHER_PAL = {
  H: C.cHair, S: C.cSkin, s: C.cSkinS, E: C.cEye,
  J: C.cJacket, j: C.cJacketD, O: C.cAccent,
  B: C.cBelt, P: C.cPants, b: C.cBoots,
};
const CIPHER_STAND = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PPPP..',
  '..PP.PP.',
  '..bb.bb.',
];
const CIPHER_WALK1 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PP.PP.',
  '.PP...PP',
  '.bb...bb',
];
const CIPHER_WALK2 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '.PP..PP.',
  'PP....PP',
  'bb....bb',
];
const CIPHER_SIT = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
];

// ===== VERA SPRITES (Interior Designer - warm wood tones) =====
const VERA_PAL = {
  H:C.vHair, S:C.vSkin, s:C.vSkinS, E:C.vEye,
  J:C.vJacket, j:C.vJacketD, O:C.vAccent,
  B:C.vBelt, P:C.vPants, b:C.vBoots,
};
const VERA_STAND = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PPPP..',
  '..PP.PP.',
  '..bb.bb.',
];
const VERA_WALK1 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '.PP..PP.',
  'PP....PP',
  'bb....bb',
];
const VERA_WALK2 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PP.PP.',
  '.PP..PP.',
  'bb....bb',
];
const VERA_SIT = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
];

// ===== LUCKY SPRITES =====
const LUCKY_PAL = {
  W:C.lW, B:C.lB, n:C.lNose, t:C.lTongue,
};
const LUCKY_IDLE1 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWWWW.',
  '.WWWWW.',
  '.WW.WW.',
  '..W....',
];
const LUCKY_IDLE2 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWtWW.',
  '.WWWWW.',
  '.WW.WW.',
  '....W..',
];
const LUCKY_WALK1 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWWWW.',
  '.WWWWW.',
  '.W...W.',
  'W.....W',
];
const LUCKY_WALK2 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWWWW.',
  '.WWWWW.',
  'W.....W',
  '.W...W.',
];

// ===== AGENT CLASS =====
class AgentEntity {
  constructor(cfg) {
    Object.assign(this, cfg);
    // Handle custom desk positions for agents without podIndex
    if (cfg.deskPos) {
      // Use explicit desk position from config (for shared offices)
      this.deskPos = { x: cfg.deskPos.x - 12, y: cfg.deskPos.y - 20 };
    } else if (cfg.podIndex !== null && cfg.podIndex !== undefined && cfg.podIndex >= 0) {
      this.pod = PODS[cfg.podIndex];
      const dc = deskCenter(this.pod);
      this.deskPos = { x: dc.x - 12, y: dc.y - 20 };
    } else if (CUSTOM_DESK_POSITIONS[cfg.name]) {
      const customPos = CUSTOM_DESK_POSITIONS[cfg.name];
      this.deskPos = { x: customPos.x - 12, y: customPos.y - 20 };
    } else {
      // Fallback to first pod if no position defined
      this.pod = PODS[0];
      const dc = deskCenter(this.pod);
      this.deskPos = { x: dc.x - 12, y: dc.y - 20 };
    }
    this.x = this.deskPos.x;
    this.y = this.deskPos.y + 40;
    this.state = 'walking_to_desk';
    this.target = { ...this.deskPos };
    this.frame = 0;
    this.frameTimer = 0;
    this.stateTimer = 0;
    this.facing = 1; // 1=right, -1=left
    this.speed = 55;
    this.expanded = false; // Status Board card expanded?
    this.idleIndex = Math.floor(Math.random() * 4); // Random start for variety
  }
  getTargetPos() {
    // If meeting is active, use meeting location position
    if (meetingActive) {
      // First check for named position (legacy support for galley)
      if (meetingLocation === 'galley' && GALLEY_POSITIONS[this.name]) {
        const pos = GALLEY_POSITIONS[this.name];
        return { x: pos.x - 12, y: pos.y - 20 };
      }
      
      // Use location-based positions
      const locationData = MEETING_LOCATIONS[meetingLocation];
      if (locationData && locationData.positions) {
        // Get agent index for position assignment (stable order by sorting)
        const sortedAgents = [...entities].sort((a, b) => a.name.localeCompare(b.name));
        const agentIndex = sortedAgents.findIndex(a => a.name === this.name);
        
        if (agentIndex >= 0 && agentIndex < locationData.positions.length) {
          const pos = locationData.positions[agentIndex];
          return { x: pos.x - 12, y: pos.y - 20 };
        }
      }
    }
    
    // Otherwise use desk position
    return this.deskPos;
  }
  getSprites() {
    if (this.name === 'Cipher' || this.name === 'Atlas') {
      return { pal: CIPHER_PAL, stand: CIPHER_STAND, walk1: CIPHER_WALK1, walk2: CIPHER_WALK2, sit: CIPHER_SIT };
    }
    if (this.name === 'Vera') {
      return { pal: VERA_PAL, stand: VERA_STAND, walk1: VERA_WALK1, walk2: VERA_WALK2, sit: VERA_SIT };
    }
    return { pal: FLINT_PAL, stand: FLINT_STAND, walk1: FLINT_WALK1, walk2: FLINT_WALK2, sit: FLINT_SIT };
  }
  update(dt) {
    this.frameTimer += dt;
    if (this.frameTimer > 0.25) { this.frame = (this.frame+1)%2; this.frameTimer = 0; }
    this.stateTimer -= dt * 1000;

    // DEBUG: Log state changes
    if (this.state !== this._lastState || this.target.x !== this._lastTargetX || this.target.y !== this._lastTargetY) {
      console.log(`[Agent ${this.name}] State: ${this.state} -> Timer: ${this.stateTimer.toFixed(0)}ms | Pos: (${this.x.toFixed(0)}, ${this.y.toFixed(0)}) Target: (${this.target.x.toFixed(0)}, ${this.target.y.toFixed(0)})`);
      this._lastState = this.state;
      this._lastTargetX = this.target.x;
      this._lastTargetY = this.target.y;
    }

    // Update target if meeting state changed
    const targetPos = this.getTargetPos();

    // FORCE: If idle, NEVER be at desk. If working, go to desk.
    // This provides immediate visual feedback regardless of state timers
    if (this.status !== 'working' && !meetingActive) {
      // If currently at desk (walking_to_desk or working), leave immediately
      if (this.state === 'walking_to_desk' || this.state === 'working') {
        this.startWander();
      }
    }

    switch (this.state) {
      case 'walking_to_desk':
        this.target = targetPos;
        this.moveToTarget(dt);
        break;
      case 'wandering':
        // Check if wander time is up
        if (this.stateTimer <= 0) {
          // Wander time is done, go idle
          console.log(`[Agent ${this.name}] Wander timer expired, going idle`);
          this.state = 'idle';
          this.stateTimer = 2000 + Math.random() * 4000;
          break;
        }
        // Only wander if not in meeting
        if (meetingActive) {
          this.state = 'walking_to_desk';
          this.target = targetPos;
          this.moveToTarget(dt);
        } else {
          this.moveToTarget(dt);
        }
        break;
      case 'working':
        // During meeting, always "work" at galley position
        if (meetingActive) {
          this.target = targetPos;
          // Move to position if not there yet
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 3) {
            this.state = 'walking_to_desk';
          }
        } else if (this.stateTimer <= 0) {
          // Working timer expired, go do something else
          if (this.status !== 'working') {
            this.startWander(); // Idle: wander away
          } else {
            // Still working but taking a break
            if (Math.random() < 0.6) this.startWander();
            else { this.state = 'idle'; this.stateTimer = 2000 + Math.random() * 3000; }
          }
        }
        break;
      case 'idle':
        if (meetingActive) {
          this.state = 'walking_to_desk';
          this.target = targetPos;
        } else if (this.status === 'working') {
          this.state = 'walking_to_desk';
          this.target = targetPos;
        } else if (this.stateTimer <= 0) {
          if (Math.random() < 0.6) this.startWander();
          else { this.stateTimer = 2000 + Math.random() * 3000; } // Keep idling
        }
        break;
    }
  }
  moveToTarget(dt) {
    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 3) {
      this.x = this.target.x; this.y = this.target.y;
      if (this.state === 'walking_to_desk') {
        this.state = 'working';
        this.stateTimer = 8000 + Math.random() * 12000;
      } else {
        this.state = 'idle';
        this.stateTimer = 2000 + Math.random() * 4000;
      }
      return;
    }
    
    // Calculate proposed movement
    const mx = (dx/dist) * this.speed * dt;
    const my = (dy/dist) * this.speed * dt;
    const newX = this.x + mx;
    const newY = this.y + my;
    
    // Check collision - if collision, try to find alternate path
    if (checkCollision(newX, newY, 10)) {
      // First, try moving only horizontally
      if (!checkCollision(this.x + mx, this.y, 10)) {
        this.x += mx;
        console.log(`[Agent ${this.name}] Collision avoid: moved horizontal only`);
      } 
      // Then try moving only vertically
      else if (!checkCollision(this.x, this.y + my, 10)) {
        this.y += my;
        console.log(`[Agent ${this.name}] Collision avoid: moved vertical only`);
      }
      // Finally, try finding a valid position near current spot
      else {
        const valid = findValidPosition(this.x + mx*3, this.y + my*3, 10);
        if (valid.x !== this.x + mx*3 || valid.y !== this.y + my*3) {
          // Found different position, update target to it
          this.target.x = valid.x;
          this.target.y = valid.y;
          console.log(`[Agent ${this.name}] Collision: rerouting to (${valid.x.toFixed(0)}, ${valid.y.toFixed(0)})`);
        } else {
          // Can't find path, just move anyway (better than stuck)
          this.x = newX;
          this.y = newY;
          console.log(`[Agent ${this.name}] Collision: forcing through (rare fallback)`);
        }
      }
      if (Math.abs(dx) > 2) this.facing = dx > 0 ? 1 : -1;
      return;
    }
    
    // No collision, move normally
    this.x = newX;
    this.y = newY;
    if (Math.abs(dx) > 2) this.facing = dx > 0 ? 1 : -1;
  }
  startWander() {
    // Don't wander during meetings
    if (meetingActive) {
      this.state = 'walking_to_desk';
      this.target = this.getTargetPos();
      console.log(`[Agent ${this.name}] Meeting active, going to desk instead`);
      return;
    }
    
    // Get agent config
    const agentCfg = AGENTS.find(a => a.name === this.name);
    const idleLocs = agentCfg?.idleLocations || ['pod', 'quarters'];
    
    // Pick next idle location in rotation
    this.idleIndex = (this.idleIndex || 0) % idleLocs.length;
    const locType = idleLocs[this.idleIndex];
    this.idleIndex++;
    
    console.log(`[Agent ${this.name}] startWander: going to '${locType}' (idleIndex=${this.idleIndex} of ${idleLocs.length})`);
    
    this.state = 'wandering';
    
    // Define location coordinates based on agent
    const podIndex = agentCfg?.podIndex ?? -1;
    const deskPos = agentCfg?.deskPos;
    
    let targetSpot;
    switch(locType) {
      case 'pod':
        if (podIndex >= 0) {
          const pod = PODS[podIndex];
          targetSpot = { x: pod.x + pod.w/2, y: pod.y + pod.h/2 };
        } else if (deskPos) {
          targetSpot = { x: deskPos.x, y: deskPos.y };
        } else {
          targetSpot = { x: 400, y: 200 }; // fallback
        }
        break;
      case 'desk':
        if (deskPos) {
          targetSpot = { x: deskPos.x, y: deskPos.y };
        } else if (podIndex >= 0) {
          const pod = PODS[podIndex];
          targetSpot = { x: pod.x + pod.w/2, y: pod.y + pod.h/2 };
        } else {
          targetSpot = { x: 400, y: 200 };
        }
        break;
      case 'quarters':
        // Go to agent's quarters on floor 2
        const q = QUARTERS.find(q => q.agent === this.name);
        if (q) {
          targetSpot = { x: q.spritePos.x, y: q.spritePos.y };
        } else {
          targetSpot = { x: 100, y: FLOOR2_Y + 60 };
        }
        break;
      case 'briefing':
        // Briefing room center
        targetSpot = { x: ROOMS[3].x + 60, y: ROOMS[3].y + 60 };
        break;
      case 'galley':
        // Galley/kitchen area - position below the counter (avoid collision box at y=280)
        targetSpot = { x: ROOMS[2].x + 80, y: ROOMS[2].y + 100 };
        break;
      case 'rec':
        // Recreation lounge
        targetSpot = { x: LOUNGE_X + 150, y: LOUNGE_Y + 80 };
        break;
      case 'corridor':
        // Main corridor
        targetSpot = { x: 300 + Math.random() * 200, y: POD_Y + POD_H + 20 };
        break;
      default:
        // Random spot as fallback
        targetSpot = { x: 200 + Math.random() * 400, y: 150 + Math.random() * 200 };
    }
    
    this.target = targetSpot;
    this.stateTimer = 10000 + Math.random() * 15000; // Stay 10-25 seconds
  }
  draw(ctx) {
    const s = 3;
    const sprites = this.getSprites();
    if (this.state === 'working') {
      drawSprite(ctx, sprites.sit, sprites.pal, this.x|0, this.y|0, s);
    } else if (this.state === 'idle') {
      drawSprite(ctx, sprites.stand, sprites.pal, this.x|0, this.y|0, s);
    } else {
      const spr = this.frame === 0 ? sprites.walk1 : sprites.walk2;
      drawSprite(ctx, spr, sprites.pal, this.x|0, this.y|0, s);
    }
    // Name tag above head
    ctx.fillStyle = this.color;
    ctx.font = 'bold 8px "JetBrains Mono"';
    ctx.fillText(this.name, (this.x - 2)|0, (this.y - 4)|0);
  }
}

// ===== COMPANION CLASS =====
class CompanionEntity {
  constructor(cfg, owner) {
    this.name = cfg.name;
    this.owner = owner;
    this.x = owner.x + 30;
    this.y = owner.y + 20;
    this.target = { x: this.x, y: this.y };
    this.frame = 0;
    this.frameTimer = 0;
    this.state = 'following'; // following | sitting | wandering | fetching | sniffing | returning
    this.speed = 45;
    this.stateTimer = 0;
  }
  getGalleyPos() {
    if (GALLEY_POSITIONS[this.name]) {
      const pos = GALLEY_POSITIONS[this.name];
      return { x: pos.x, y: pos.y };
    }
    return null;
  }
  update(dt) {
    this.frameTimer += dt;
    if (this.frameTimer > 0.35) { this.frame = (this.frame+1)%2; this.frameTimer = 0; }
    this.stateTimer -= dt * 1000;

    // Check if meeting is active and we have a galley position
    const galleyPos = this.getGalleyPos();
    
    // Handle newspaper run states (fetching, sniffing, returning)
    if (this.state === 'fetching') {
      this.target = NEWSPAPER_SPOT;
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
      } else {
        // Reached newspaper spot, start sniffing
        this.state = 'sniffing';
        this.stateTimer = 3000; // Sniff for 3 seconds
      }
      return;
    }
    
    if (this.state === 'sniffing') {
      // Stay at newspaper spot and sniff
      if (this.stateTimer <= 0) {
        // Done sniffing, return to owner
        this.state = 'returning';
      }
      return;
    }
    
    if (this.state === 'returning') {
      // Return to owner
      const ownerPos = { x: this.owner.x + 25, y: this.owner.y + 15 };
      this.target = ownerPos;
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
      } else {
        // Back at owner, resume normal behavior
        this.state = 'sitting';
      }
      return;
    }

    // Check for heartbeat trigger (only if not already fetching, not in meeting, and cooldown expired)
    const now = Date.now();
    if (heartbeatRecent && 
        this.state !== 'fetching' && 
        this.state !== 'sniffing' && 
        this.state !== 'returning' &&
        !meetingActive &&
        now - lastHeartbeatProcessedAt > 60000) {
      lastHeartbeatProcessedAt = now;
      this.state = 'fetching';
      return;
    }

    if (meetingActive && galleyPos) {
      // Go to galley position
      this.target = galleyPos;
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
        this.state = 'following';
      } else {
        this.state = 'sitting';
      }
    } else if (this.owner.state === 'working') {
      // Sit near desk
      this.target = { x: this.owner.x + 28, y: this.owner.y + 30 };
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
        this.state = 'following';
      } else {
        this.state = 'sitting';
      }
    } else if (this.owner.state === 'idle' || this.owner.state === 'wandering' || this.owner.state === 'walking_to_desk') {
      // Follow owner with slight delay
      this.target = { x: this.owner.x + 25, y: this.owner.y + 15 };
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 20) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
        this.state = 'following';
      } else {
        this.state = 'sitting';
      }
    }
  }
  draw(ctx) {
    const s = 2;
    let spr;
    if (this.state === 'sitting' || this.state === 'sniffing') {
      // Use IDLE2 (tongue out) during sniffing for cute effect, IDLE1 for sitting
      spr = this.state === 'sniffing' ? LUCKY_IDLE2 : (this.frame === 0 ? LUCKY_IDLE1 : LUCKY_IDLE2);
    } else {
      spr = this.frame === 0 ? LUCKY_WALK1 : LUCKY_WALK2;
    }
    drawSprite(ctx, spr, LUCKY_PAL, this.x|0, this.y|0, s);
    // Name
    ctx.fillStyle = '#8090A0';
    ctx.font = '6px "JetBrains Mono"';
    ctx.fillText(this.name, (this.x-2)|0, (this.y-2)|0);
  }
}

// ===== MOBILE STATUS BAR =====
// State for mobile mode
let selectedAgent = null; // Which agent's card is expanded
let isMobile = window.innerWidth < 600;

// Track chip positions for click detection
let chipPositions = [];
let cardPositions = [];

// Handle resize to switch modes
window.addEventListener('resize', () => {
  isMobile = window.innerWidth < 600;
  if (!isMobile) selectedAgent = null; // Clear selection on desktop
});

// ===== CHUNK 1: COMPACT CHIP RENDERING =====
function drawCompactChip(ctx, ent, x, y, chipWidth = 80, chipHeight = 36) {
  // Background
  rect(ctx, x, y, chipWidth, chipHeight, '#0F1520');
  strokeRect(ctx, x, y, chipWidth, chipHeight, C.barBorder);

  // Color dot (6px)
  rect(ctx, x + 6, y + 15, 6, 6, ent.color);

  // Name (truncated if needed)
  ctx.fillStyle = '#C0C8D4';
  ctx.font = 'bold 9px "JetBrains Mono"';
  ctx.textAlign = 'left';
  
  // Truncate name to fit
  let displayName = ent.name;
  const nameMetrics = ctx.measureText(displayName);
  if (nameMetrics.width > 34) {
    displayName = ent.name.substring(0, 3) + '..';
  }
  ctx.fillText(displayName, x + 16, y + 21);

  // Level badge (small, right side)
  const levelText = `Lv.${ent.level}`;
  ctx.font = '8px "JetBrains Mono"';
  const levelWidth = ctx.measureText(levelText).width;
  const badgeX = x + chipWidth - levelWidth - 14;
  const badgeY = y + 7;
  
  // Dark background for level badge
  const darkColor = darkenColor(ent.color, 0.4);
  ctx.fillStyle = darkColor;
  ctx.beginPath();
  ctx.roundRect(badgeX - 2, badgeY, levelWidth + 4, 10, 5);
  ctx.fill();
  
  ctx.fillStyle = ent.color;
  ctx.fillText(levelText, badgeX, badgeY + 7);

  // Status dot (6px, right side) - amber for meeting, green for working, red for idle
  let statusColor;
  if (ent.status === 'meeting') {
    statusColor = C.amber;  // Orange for meeting
  } else if (ent.status === 'working') {
    statusColor = C.green;  // Green for working
  } else {
    statusColor = C.red;    // Red for idle
  }
  rect(ctx, x + chipWidth - 10, y + 15, 6, 6, statusColor);
}

// ===== CHUNK 2: EXPANDED CARD VIEW =====
function drawExpandedCard(ctx, ent, x, y, cardWidth = 160, cardHeight = 90) {
  // Ensure card stays within bounds
  if (x + cardWidth > TARGET_WIDTH) x = TARGET_WIDTH - cardWidth - 10;
  if (y + cardHeight > TARGET_HEIGHT) y = TARGET_HEIGHT - cardHeight - 10;

  // Card background with subtle shadow
  rect(ctx, x, y, cardWidth, cardHeight, '#0F1520');
  strokeRect(ctx, x, y, cardWidth, cardHeight, ent.color);
  
  // Header with color accent
  rect(ctx, x, y, cardWidth, 4, ent.color);

  // Color dot
  rect(ctx, x + 8, y + 12, 10, 10, ent.color);

  // Name
  ctx.fillStyle = ent.color;
  ctx.font = 'bold 11px "JetBrains Mono"';
  ctx.textAlign = 'left';
  ctx.fillText(ent.name, x + 24, y + 20);

  // Level badge
  drawLevelBadge(ctx, x + cardWidth - 45, y + 10, ent.level, ent.color);

  // Role
  ctx.fillStyle = C.barDim;
  ctx.font = '9px "JetBrains Mono"';
  ctx.fillText(ent.role, x + 8, y + 38);

  // Status with colored indicator - meeting shows amber/orange
  let statusText, statusColor;
  if (ent.status === 'meeting') {
    statusText = '📍 MEETING';
    statusColor = C.amber;
  } else if (ent.status === 'working') {
    statusText = '● WORKING';
    statusColor = C.green;
  } else {
    statusText = '● IDLE';
    statusColor = C.red;
  }
  ctx.fillStyle = statusColor;
  ctx.font = '9px "JetBrains Mono"';
  ctx.fillText(statusText, x + 8, y + 52);

  // Task/Model subtitle (only when working) — positioned AFTER exp bar
  if (ent.status === 'working' && ent.currentTask) {
    ctx.fillStyle = C.barDim;
    ctx.font = '7px "JetBrains Mono"';
    const taskText = ent.currentTask.length > 25 ? ent.currentTask.substring(0, 25) + '...' : ent.currentTask;
    ctx.fillText(taskText, x + 8, y + 76);
    
    if (ent.currentModel) {
      ctx.fillText(`[${ent.currentModel}]`, x + 8, y + 84);
    }
  }

  // EXP bar
  const expBarX = x + 8;
  const expBarY = y + 62;
  const expBarWidth = cardWidth - 16;
  const expBarHeight = 6;
  
  const isMaxLevel = ent.nextLevel === null || ent.nextLevel === Infinity || ent.nextLevel === undefined;
  let expProgress = ent.expProgress;
  if (expProgress === undefined || expProgress === null) {
    if (ent.exp !== undefined && ent.nextLevel && !isMaxLevel) {
      expProgress = ent.exp / ent.nextLevel;
    } else if (isMaxLevel) {
      expProgress = 1.0;
    }
  }
  
  if (expProgress !== undefined && !isNaN(expProgress)) {
    drawExpBar(ctx, expBarX, expBarY, expBarWidth, expBarHeight, expProgress, ent.color, isMaxLevel);
    
    // EXP text
    ctx.fillStyle = '#5A6A7A';
    ctx.font = '7px "JetBrains Mono"';
    let expText = isMaxLevel ? 'MAX' : `${ent.exp || 0}/${ent.nextLevel}`;
    ctx.fillText(expText, expBarX + expBarWidth + 4, expBarY + 4);
  }

  // Close hint
  ctx.fillStyle = C.barDim;
  ctx.font = '7px "JetBrains Mono"';
  ctx.fillText('(tap to close)', x + 8, y + cardHeight - 4);
  
  // Recent Comms section (if expanded card is tall enough)
  if (cardHeight >= 120 && commsData.length > 0) {
    const agentComms = commsData.filter(c => c.from === ent.name || c.to === ent.name).slice(-3);
    if (agentComms.length > 0) {
      ctx.fillStyle = '#3A4A5E';
      ctx.fillRect(x + 8, y + 95, cardWidth - 16, 1); // Separator line
      
      ctx.fillStyle = C.barDim;
      ctx.font = 'bold 7px "JetBrains Mono"';
      ctx.fillText('RECENT COMMS', x + 8, y + 104);
      
      ctx.font = '6px "JetBrains Mono"';
      agentComms.forEach((comm, idx) => {
        const commY = y + 114 + (idx * 10);
        const direction = comm.from === ent.name ? '→' : '←';
        const otherParty = comm.from === ent.name ? comm.to : comm.from;
        const shortMsg = comm.message.length > 30 ? comm.message.substring(0, 30) + '...' : comm.message;
        ctx.fillStyle = comm.from === ent.name ? '#5A7A9A' : '#7A9A5A';
        ctx.fillText(`${direction} ${otherParty}: ${shortMsg}`, x + 8, commY);
      });
    }
  }
}

// ===== CHUNK 3: MOBILE STATUS BAR =====
function drawCompactStatusBar() {
  const CHIP_WIDTH = 240;  // Wider chips for 3 agents
  const CHIP_HEIGHT = 36;
  const GAP_X = 10;
  const GAP_Y = 8;
  const COLS = 1;         // Single column, 3 rows
  const START_X = 16;
  const START_Y = BAR_Y + 24;

  // Clear chip positions for click detection
  chipPositions = [];

  // Draw agent chips in 3-column grid
  entities.forEach((ent, i) => {
    const col = i % COLS;
    const row = Math.floor(i / COLS);
    const x = START_X + col * (CHIP_WIDTH + GAP_X);
    const y = START_Y + row * (CHIP_HEIGHT + GAP_Y);

    // Store position for hit testing
    chipPositions.push({ x, y, width: CHIP_WIDTH, height: CHIP_HEIGHT, agent: ent });

    // Draw compact chip
    drawCompactChip(ctx, ent, x, y, CHIP_WIDTH, CHIP_HEIGHT);
  });

  // Calculate total grid height
  const rows = Math.ceil(entities.length / COLS);
  const gridHeight = rows * CHIP_HEIGHT + (rows - 1) * GAP_Y;

  // Draw expanded card if agent selected
  if (selectedAgent) {
    const ent = entities.find(e => e.name === selectedAgent);
    if (ent) {
      // Position expanded card below the grid
      const cardX = START_X;
      const cardY = START_Y + gridHeight + 8;
      
      drawExpandedCard(ctx, ent, cardX, cardY, 200, 150);
    } else {
      // Edge case: agent not found, clear selection
      selectedAgent = null;
    }
  }

  // System info (compact for mobile)
  ctx.fillStyle = C.barDim;
  ctx.font = '7px "JetBrains Mono"';
  const sysY = BAR_Y + BAR_H - 12;
  ctx.fillText(`AGENTS: ${entities.length} | FACILITY: ${meetingActive ? 'MEETING' : 'OPERATIONAL'}`, 16, sysY);
  
  if (meetingActive) {
    ctx.fillStyle = C.amber;
    ctx.fillText(`◆ MEETING @ ${meetingLocation.toUpperCase()} ◆`, 200, sysY);
  }
}

// ===== DESKTOP STATUS BAR (original) =====
function drawDesktopStatusBar() {
  // Clear click positions every frame
  todoPositions = [];
  statusTabPositions = [];
  
  // Header classified blink
  const blink = (Date.now() / 800 | 0) % 2;
  rect(ctx, TARGET_WIDTH - 200, 6, 190, 18, C.hdrBg);
  ctx.fillStyle = blink ? C.hdrText : C.hdrDim;
  ctx.font = '10px "JetBrains Mono"';
  ctx.fillText('◆ CLASSIFIED ◆', TARGET_WIDTH - 180, 19);

  // ── STATUS BOARD HEADER WITH TABS ──
  const TAB_W = 70;
  const TAB_H = 18;
  const TAB_Y = BAR_Y + 6;
  const TAB_GAP = 4;
  const tabs = [
    { id: 'agents', label: 'AGENTS' },
    { id: 'todos', label: 'TO-DO' },
    { id: 'activity', label: 'ACTIVITY' },
    { id: 'models', label: 'MODELS' },
    { id: 'proposals', label: 'APPROVAL' }
  ];
  
  // Draw tabs
  let tabX = 16;
  tabs.forEach(tab => {
    const isActive = statusTab === tab.id;
    const w = TAB_W;
    
    // Tab background
    ctx.fillStyle = isActive ? '#1A2535' : '#0D1520';
    ctx.beginPath();
    ctx.roundRect(tabX, TAB_Y, w, TAB_H, 3);
    ctx.fill();
    
    // Tab border
    strokeRect(ctx, tabX, TAB_Y, w, TAB_H, isActive ? '#3A5A7A' : '#1A2535');
    
    // Tab text
    ctx.fillStyle = isActive ? C.hdrText : '#4A5A6A';
    ctx.font = 'bold 8px "JetBrains Mono"';
    ctx.fillText(tab.label, tabX + 6, TAB_Y + 13);
    
    tabX += w + TAB_GAP;
  });

  // Store tab positions for click detection
  statusTabPositions = [];
  tabX = 16;
  tabs.forEach(tab => {
    statusTabPositions.push({ x: tabX, y: TAB_Y, width: TAB_W, height: TAB_H, id: tab.id });
    tabX += TAB_W + TAB_GAP;
  });

  // Modal button (expand to fullscreen) — next to tabs
  const modalBtnX = 320;
  const modalBtnW = 70;
  const modalBtnH = TAB_H;
  ctx.fillStyle = modalOpen ? '#2A4A6A' : '#0D1520';
  ctx.beginPath();
  ctx.roundRect(modalBtnX, TAB_Y, modalBtnW, modalBtnH, 3);
  ctx.fill();
  strokeRect(ctx, modalBtnX, TAB_Y, modalBtnW, modalBtnH, modalOpen ? '#4A7AAA' : '#1A2535');
  ctx.fillStyle = modalOpen ? '#8ABADF' : '#4A6A7A';
  ctx.font = 'bold 8px "JetBrains Mono"';
  ctx.fillText(modalOpen ? '▼ CLOSE' : '▲ EXPAND', modalBtnX + 8, TAB_Y + 13);
  
  // Store modal button position
  statusTabPositions.push({ x: modalBtnX, y: TAB_Y, width: modalBtnW, height: modalBtnH, id: 'modal' });

  // Time (far right, no overlap)
  const now = new Date();
  const ts = now.toLocaleTimeString('en-US', { hour12: false });
  ctx.fillStyle = C.hdrText;
  ctx.font = '9px "JetBrains Mono"';
  ctx.fillText(ts, TARGET_WIDTH - 60, BAR_Y + 14);

  // Draw content based on selected tab
  const contentY = BAR_Y + 30;
  
  if (statusTab === 'agents') {
    // Existing agent cards code starts here...

  // ── AGENT CARDS — dynamic layout based on agent count ──
  const CARD_PAD = 12;
  const COMPANION_W = 110;
  const RIGHT_MARGIN = COMPANION_W + CARD_PAD * 2;
  const AVAILABLE_W = TARGET_WIDTH - CARD_PAD * 2 - RIGHT_MARGIN;
  const CARD_GAP = 8;
  const agentCount = entities.length;
  // Dynamic card width: fit all agents in one row with companion panel
  const CARD_W = Math.min(210, Math.floor((AVAILABLE_W - (agentCount - 1) * CARD_GAP) / agentCount));
  const CARD_H = 115;
  const CARD_Y = BAR_Y + 24;

  cardPositions = [];

  entities.forEach((ent, i) => {
    const x = CARD_PAD + i * (CARD_W + CARD_GAP);
    const y = CARD_Y;

    cardPositions.push({ x, y, width: CARD_W, height: CARD_H, agent: ent });

    // Card background
    ctx.fillStyle = '#0A0F18';
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.roundRect(x, y, CARD_W, CARD_H, 4);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Subtle left accent bar in agent color
    ctx.fillStyle = ent.color;
    ctx.globalAlpha = 0.6;
    ctx.fillRect(x, y + 4, 3, CARD_H - 8);
    ctx.globalAlpha = 1;

    // Border
    strokeRect(ctx, x, y, CARD_W, CARD_H, '#1A2535');

    // ── Row 1: Name + Level badge ──
    const innerX = x + 8;
    const innerW = CARD_W - 16;

    ctx.fillStyle = ent.color;
    ctx.font = 'bold 10px "JetBrains Mono"';
    // Truncate name if card is narrow
    let displayName = ent.name;
    if (ctx.measureText(displayName).width > innerW - 40) {
      while (ctx.measureText(displayName + '…').width > innerW - 40 && displayName.length > 2) {
        displayName = displayName.slice(0, -1);
      }
      displayName += '…';
    }
    ctx.fillText(displayName, innerX, y + 16);

    // Level badge (right-aligned)
    const lvlText = `Lv${ent.level}`;
    ctx.font = 'bold 8px "JetBrains Mono"';
    const lvlW = ctx.measureText(lvlText).width + 8;
    const lvlX = x + CARD_W - lvlW - 6;
    ctx.fillStyle = '#1A2535';
    ctx.beginPath();
    ctx.roundRect(lvlX, y + 6, lvlW, 14, 3);
    ctx.fill();
    ctx.fillStyle = ent.color;
    ctx.fillText(lvlText, lvlX + 4, y + 16);

    // ── Row 2: Role ──
    ctx.fillStyle = '#4A5A6A';
    ctx.font = '8px "JetBrains Mono"';
    let displayRole = ent.role;
    if (ctx.measureText(displayRole).width > innerW) {
      while (ctx.measureText(displayRole + '…').width > innerW && displayRole.length > 2) {
        displayRole = displayRole.slice(0, -1);
      }
      displayRole += '…';
    }
    ctx.fillText(displayRole, innerX, y + 30);

    // ── Row 3: Status indicator + model badge ──
    const statusY = y + 42;
    let dotColor = ent.status === 'meeting' ? C.amber : (ent.status === 'working' ? C.green : C.red);
    let statusText = ent.status.toUpperCase();

    // Status dot (pulsing for working)
    if (ent.status === 'working') {
      const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 500);
      ctx.globalAlpha = 0.3 + 0.2 * pulse;
      ctx.beginPath();
      ctx.arc(innerX + 4, statusY - 3, 6, 0, Math.PI * 2);
      ctx.fillStyle = dotColor;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    rect(ctx, innerX, statusY - 7, 8, 8, dotColor);

    ctx.fillStyle = dotColor;
    ctx.font = 'bold 9px "JetBrains Mono"';
    ctx.fillText(statusText, innerX + 14, statusY);

    // Model badge (dynamically positioned after status text)
    if (ent.currentModel && ent.currentModel !== 'unknown') {
      const mColor = getModelColor(ent.currentModel);
      ctx.font = 'bold 9px "JetBrains Mono"';
      const statusTextW = ctx.measureText(statusText).width;
      ctx.font = '7px "JetBrains Mono"';
      const mBadgeX = innerX + 14 + statusTextW + 6;
      const maxModelW = x + CARD_W - mBadgeX - 6;
      if (maxModelW > 20) {
        let modelLabel = ent.currentModel;
        const mTextW = Math.min(ctx.measureText(modelLabel).width + 8, maxModelW);
        // Truncate model name if it doesn't fit
        while (ctx.measureText(modelLabel).width + 8 > maxModelW && modelLabel.length > 3) {
          modelLabel = modelLabel.slice(0, -1);
        }
        ctx.fillStyle = mColor + '33';
        ctx.beginPath();
        ctx.roundRect(mBadgeX, statusY - 8, mTextW, 12, 3);
        ctx.fill();
        ctx.fillStyle = mColor;
        ctx.fillText(modelLabel, mBadgeX + 4, statusY);
      }
    }

    // ── Row 4: Current task (if working) ──
    const taskY = statusY + 14;
    if (ent.status === 'working' && ent.currentTask) {
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '7px "JetBrains Mono"';
      let taskText = ent.currentTask;
      const maxTaskW = innerW - 4;
      // Truncate if too long
      while (ctx.measureText('📋 ' + taskText).width > maxTaskW && taskText.length > 10) {
        taskText = taskText.slice(0, -4) + '...';
      }
      ctx.fillText('📋 ' + taskText, innerX, taskY);
    }

    // ── Row 5: EXP bar (pushed down to avoid task overlap) ──
    const expY = y + 74;
    const expBarW = innerW;
    const expBarH = 6;
    let expProg = ent.expProgress;
    if (expProg === undefined) expProg = ent.exp / ent.nextLevel;

    // Bar background
    ctx.fillStyle = '#0D1520';
    ctx.beginPath();
    ctx.roundRect(innerX, expY, expBarW, expBarH, 2);
    ctx.fill();

    // Bar fill
    const fillW = Math.max(0, Math.min(expBarW, expBarW * expProg));
    if (fillW > 0) {
      ctx.fillStyle = ent.color;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.roundRect(innerX, expY, fillW, expBarH, 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Bar border
    ctx.strokeStyle = '#1A2535';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(innerX, expY, expBarW, expBarH, 2);
    ctx.stroke();

    // ── Row 6: EXP text + Tier label (same row, left/right aligned) ──
    const expTextY = expY + 16;
    ctx.fillStyle = '#3A4A5A';
    ctx.font = '7px "JetBrains Mono"';
    ctx.fillText(`${ent.exp}/${ent.nextLevel} XP`, innerX, expTextY);

    const tierMap = { 'Director': 'T1', 'Systems': 'T2', 'Security': 'T2', 'Tech Director': 'T3', 'Heavy Coder': 'T3', 'Coder': 'T4', 'Maintenance': 'T5', 'QA': 'T5', 'Recon': 'T5', 'Interior Designer': 'T3' };
    const tier = tierMap[ent.role] || '';
    if (tier) {
      ctx.font = '7px "JetBrains Mono"';
      const tierTextW = ctx.measureText(tier).width + 6;
      const tierX = x + CARD_W - tierTextW - 6;
      ctx.fillStyle = '#1A2535';
      ctx.beginPath();
      ctx.roundRect(tierX, expTextY - 9, tierTextW, 12, 2);
      ctx.fill();
      ctx.fillStyle = '#4A5A6A';
      ctx.fillText(tier, tierX + 3, expTextY);
    }
  });

  // ── COMPANION PANEL (right side) ──
  const compX = TARGET_WIDTH - COMPANION_W - CARD_PAD;
  const compY = CARD_Y;
  const compH = 50;

  ctx.fillStyle = '#0A0F18';
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.roundRect(compX, compY, COMPANION_W, compH, 4);
  ctx.fill();
  ctx.globalAlpha = 1;
  strokeRect(ctx, compX, compY, COMPANION_W, compH, '#1A2535');

  companions.forEach(comp => {
    // Dog emoji + name
    ctx.font = '10px "JetBrains Mono"';
    ctx.fillText('🐕', compX + 8, compY + 18);
    ctx.fillStyle = '#D4A574';
    ctx.font = 'bold 9px "JetBrains Mono"';
    ctx.fillText(comp.name, compX + 26, compY + 18);

    // State
    ctx.fillStyle = comp.state === 'sitting' ? '#8B6F4E' : C.barDim;
    ctx.font = '7px "JetBrains Mono"';
    ctx.fillText(comp.state.toUpperCase(), compX + 26, compY + 32);
  });

  // ── SYSTEM INFO (below companion) ──
  const sysX = compX;
  const sysY = compY + compH + 8;
  ctx.fillStyle = '#2A3545';
  ctx.font = '7px "JetBrains Mono"';
  const activeAgents = entities.length;
  const vacantPods = PODS.length - activeAgents;
  ctx.fillText(`AGENTS: ${activeAgents}`, sysX + 8, sysY + 10);
  ctx.fillText(`PODS: ${activeAgents}/${PODS.length} (vacant ${vacantPods})`, sysX + 8, sysY + 22);
  
  } else if (statusTab === 'todos') {
    // ── TO-DO BOARD (v2 with assignee badges) ──
    const todoListX = 16;
    const todoListY = contentY;
    const todoLineH = 28;
    const maxVisible = Math.floor((BAR_Y + BAR_H - contentY - 40) / todoLineH);
    
    // Filter buttons (mini) - ALL + agent names
    const filterX = todoListX;
    const filterY = todoListY;
    const agentNames = ['Flint', 'Cipher', 'Scout', 'Scrub', 'Vera'];
    const filterBtns = [{ id: 'all', label: 'ALL' }].concat(
      agentNames.map(name => ({ id: name.toLowerCase(), label: name.substring(0, 3).toUpperCase() }))
    );
    
    let filterOffsetX = filterX;
    filterBtns.forEach((btn, idx) => {
      const isActive = todoFilter === btn.id;
      const btnW = idx === 0 ? 40 : 36; // ALL wider, agent names compact
      const agentColor = idx > 0 ? (agentsData[agentNames[idx-1]]?.color || '#5A6A7A') : null;
      
      ctx.fillStyle = isActive ? '#1A3545' : '#0D1520';
      ctx.beginPath();
      ctx.roundRect(filterOffsetX, filterY, btnW, 18, 3);
      ctx.fill();
      strokeRect(ctx, filterOffsetX, filterY, btnW, 18, isActive ? (agentColor || '#3A6A8A') : '#1A2535');
      ctx.fillStyle = isActive ? (agentColor || '#8ABADF') : (agentColor ? agentColor + '99' : '#4A6A7A');
      ctx.font = 'bold 6px "JetBrains Mono"';
      ctx.fillText(btn.label, filterOffsetX + 4, filterY + 12);
      
      todoPositions.push({ x: filterOffsetX, y: filterY, width: btnW, height: 18, id: 'filter_' + btn.id });
      filterOffsetX += btnW + 2;
    });
    
    // Add button (right side) - positioned relative to canvas width
    const addBtnX = TARGET_WIDTH - 130;
    const addBtnY = filterY;
    ctx.fillStyle = '#1A3545';
    ctx.beginPath();
    ctx.roundRect(addBtnX, addBtnY, 100, 18, 3);
    ctx.fill();
    strokeRect(ctx, addBtnX, addBtnY, 100, 18, '#3A6A8A');
    ctx.fillStyle = '#5AAA DF';
    ctx.font = 'bold 7px "JetBrains Mono"';
    ctx.fillText('+ ADD TASK', addBtnX + 12, addBtnY + 12);
    todoPositions.push({ x: addBtnX, y: addBtnY, width: 100, height: 18, id: 'add' });
    
    // Filter todos by agent name
    const agentFilterNames = ['flint', 'cipher', 'atlas', 'vera', 'scout', 'scrub'];
    const filteredTodos = todosData.filter(todo => {
      if (todoFilter === 'all') return true;
      if (agentFilterNames.includes(todoFilter)) {
        // Filter by assignedTo matching the agent name (case-insensitive)
        return todo.assignedTo && todo.assignedTo.toLowerCase() === todoFilter;
      }
      return true;
    });
    
    // Draw todo list (compact lines)
    const listStartY = filterY + 26;
    filteredTodos.slice(0, maxVisible).forEach((todo, i) => {
      const ty = listStartY + i * todoLineH;
      
      // Checkbox
      const cbX = todoListX + 4;
      const cbY = ty + 6;
      ctx.strokeStyle = todo.done ? '#3A7A5A' : '#3A5A6A';
      ctx.lineWidth = 1;
      ctx.strokeRect(cbX, cbY, 12, 12);
      if (todo.done) {
        ctx.fillStyle = '#3A7A5A';
        ctx.font = 'bold 10px "JetBrains Mono"';
        ctx.fillText('✓', cbX + 2, cbY + 10);
      }
      
      // Task text
      ctx.fillStyle = todo.done ? '#4A6A5A' : C.hdrText;
      ctx.font = '9px "JetBrains Mono"';
      const textStartX = cbX + 20;
      const maxTextW = 500;
      // Truncate text to fit
      let displayText = todo.text;
      while (ctx.measureText(displayText).width > maxTextW && displayText.length > 10) {
        displayText = displayText.slice(0, -4) + '...';
      }
      ctx.fillText(displayText, textStartX, cbY + 9);
      
      // Assignee badge
      const badgeX = textStartX + maxTextW + 10;
      let badgeColor, badgeText;
      if (!todo.assignedTo) {
        badgeColor = '#4A5A6A';
        badgeText = 'Unassigned';
      } else if (todo.assignedTo === currentUser) {
        badgeColor = '#00D4FF';  // cyan for self
        badgeText = todo.assignedTo;
      } else {
        badgeColor = '#9966CC';  // purple for others
        badgeText = todo.assignedTo;
      }
      
      // Badge background
      const badgeW = ctx.measureText(badgeText).width + 12;
      ctx.fillStyle = badgeColor + '33'; // 20% opacity
      ctx.beginPath();
      ctx.roundRect(badgeX, cbY - 2, badgeW, 16, 4);
      ctx.fill();
      ctx.fillStyle = badgeColor;
      ctx.font = '7px "JetBrains Mono"';
      ctx.fillText(badgeText, badgeX + 6, cbY + 9);
      
      // Created by (small, right side)
      ctx.fillStyle = '#3A4A5A';
      ctx.font = '7px "JetBrains Mono"';
      const createdByText = `by ${todo.createdBy || 'Unknown'}`;
      const createdByX = 880;
      ctx.fillText(createdByText, createdByX, cbY + 9);
      
      // Delete X button (far right)
      const delX = 940;
      ctx.fillStyle = '#4A2A2A';
      ctx.beginPath();
      ctx.roundRect(delX, cbY - 2, 18, 16, 3);
      ctx.fill();
      ctx.fillStyle = '#AA5A5A';
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText('✕', delX + 5, cbY + 9);
      todoPositions.push({ x: delX, y: cbY - 2, width: 18, height: 16, id: todo.id, type: 'delete', text: todo.text });
      
      // Store checkbox position
      todoPositions.push({ x: cbX, y: cbY, width: 12, height: 12, id: todo.id, type: 'toggle' });
    });
    
  } else if (statusTab === 'activity') {
    // ── CLI-STYLE ACTIVITY LOG ──
    const cliX = 16;
    const cliY = contentY;
    const lineH = 16;
    const maxLines = Math.floor((BAR_Y + BAR_H - contentY - 10) / lineH);
    
    // Terminal header bar - full width minus padding
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(cliX, cliY, TARGET_WIDTH - 32, 20);
    ctx.fillStyle = '#3A9A5A';
    ctx.font = 'bold 9px "JetBrains Mono"';
    ctx.fillText('▶ ACTIVITY LOG — real-time feed', cliX + 8, cliY + 14);
    
    // CLI lines (newest at top)
    const startY = cliY + 26;
    activityData.slice(0, maxLines - 2).forEach((act, i) => {
      const y = startY + i * lineH;
      
      // Prompt style: $
      ctx.fillStyle = '#5A7A6A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText('$', cliX + 4, y + 12);
      
      // Timestamp [HH:MM:SS]
      ctx.fillStyle = '#4A6A5A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText(`[${act.time}]`, cliX + 16, y + 12);
      
      // Agent name (colored)
      const agentColor = agentsData[act.agent]?.color || '#AAAAAA';
      ctx.fillStyle = agentColor;
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText(act.agent + ':', cliX + 90, y + 12);
      
      // Model badge (compact pill)
      const modelName = act.model || 'unknown';
      if (modelName !== 'unknown') {
        const modelColor = getModelColor(modelName);
        ctx.font = '7px "JetBrains Mono"';
        const mw = ctx.measureText(modelName).width + 6;
        ctx.fillStyle = modelColor + '33';
        ctx.beginPath();
        ctx.roundRect(cliX + 148, y + 3, mw, 11, 3);
        ctx.fill();
        ctx.fillStyle = modelColor;
        ctx.fillText(modelName, cliX + 151, y + 11);
      }
      
      // Action + Task text (shifted right to accommodate model badge)
      ctx.fillStyle = '#8A9A9A';
      ctx.font = '9px "JetBrains Mono"';
      const taskPart = act.task ? ` ${act.task}` : '';
      let actionText = act.action + taskPart;
      const maxChars = 40;
      if (actionText.length > maxChars) {
        actionText = actionText.substring(0, maxChars - 3) + '...';
      }
      const actionStartX = modelName !== 'unknown' ? cliX + 230 : cliX + 160;
      ctx.fillText(actionText, actionStartX, y + 12);
      
      // EXP change at end - right aligned
      const expColor = act.exp > 0 ? '#3A9A5A' : (act.exp < 0 ? '#AA4A4A' : '#5A6A5A');
      ctx.fillStyle = expColor;
      ctx.font = 'bold 9px "JetBrains Mono"';
      const expX = TARGET_WIDTH - 50 - ctx.measureText(act.expChange).width;
      ctx.fillText(act.expChange, expX, y + 12);
    });
  } else if (statusTab === 'models') {
    // ── MODEL PERFORMANCE STATS ──
    const modX = 16;
    const modY = contentY;
    
    // Header
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(modX, modY, TARGET_WIDTH - 32, 20);
    ctx.fillStyle = '#D4A574';
    ctx.font = 'bold 9px "JetBrains Mono"';
    ctx.fillText('▶ MODEL PERFORMANCE — win rates & EXP by model', modX + 8, modY + 14);
    
    const modelNames = Object.keys(modelStatsData).filter(m => m !== 'unknown');
    if (modelNames.length === 0) {
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText('No model data yet. Use --model flag with grant-exp.js', modX + 8, modY + 40);
    } else {
      // Column headers
      const colY = modY + 28;
      ctx.fillStyle = '#5A7A8A';
      ctx.font = 'bold 8px "JetBrains Mono"';
      ctx.fillText('MODEL', modX + 8, colY);
      ctx.fillText('TASKS', modX + 160, colY);
      ctx.fillText('WINS', modX + 220, colY);
      ctx.fillText('LOSSES', modX + 280, colY);
      ctx.fillText('WIN %', modX + 350, colY);
      ctx.fillText('NET EXP', modX + 420, colY);
      ctx.fillText('EXP/TASK', modX + 500, colY);
      
      // Separator
      ctx.fillStyle = '#1A2535';
      ctx.fillRect(modX + 4, colY + 4, TARGET_WIDTH - 48, 1);
      
      // Sort by win rate descending
      const sorted = modelNames.sort((a, b) => {
        const aStats = modelStatsData[a];
        const bStats = modelStatsData[b];
        const aWR = aStats.tasks > 0 ? aStats.wins / aStats.tasks : 0;
        const bWR = bStats.tasks > 0 ? bStats.wins / bStats.tasks : 0;
        return bWR - aWR;
      });
      
      const rowH = 18;
      sorted.forEach((model, i) => {
        const stats = modelStatsData[model];
        const ry = colY + 12 + i * rowH;
        const winRate = stats.tasks > 0 ? Math.round((stats.wins / stats.tasks) * 100) : 0;
        const expPerTask = stats.tasks > 0 ? Math.round(stats.totalExp / stats.tasks) : 0;
        const mColor = getModelColor(model);
        
        // Model name badge
        ctx.font = '8px "JetBrains Mono"';
        const mw = ctx.measureText(model).width + 8;
        ctx.fillStyle = mColor + '33';
        ctx.beginPath();
        ctx.roundRect(modX + 4, ry - 6, mw, 14, 3);
        ctx.fill();
        ctx.fillStyle = mColor;
        ctx.fillText(model, modX + 8, ry + 4);
        
        // Stats columns
        ctx.fillStyle = '#8A9AAA';
        ctx.font = '9px "JetBrains Mono"';
        ctx.fillText(String(stats.tasks), modX + 160, ry + 4);
        ctx.fillStyle = '#3A9A5A';
        ctx.fillText(String(stats.wins), modX + 220, ry + 4);
        ctx.fillStyle = '#AA4A4A';
        ctx.fillText(String(stats.losses), modX + 280, ry + 4);
        
        // Win rate with color coding
        ctx.fillStyle = winRate >= 75 ? '#3A9A5A' : (winRate >= 50 ? '#AAAA4A' : '#AA4A4A');
        ctx.font = 'bold 9px "JetBrains Mono"';
        ctx.fillText(winRate + '%', modX + 350, ry + 4);
        
        // Net EXP
        ctx.fillStyle = stats.totalExp >= 0 ? '#3A9A5A' : '#AA4A4A';
        ctx.font = '9px "JetBrains Mono"';
        const expSign = stats.totalExp >= 0 ? '+' : '';
        ctx.fillText(expSign + stats.totalExp, modX + 420, ry + 4);
        
        // EXP per task
        ctx.fillStyle = expPerTask >= 0 ? '#5A8A6A' : '#8A5A5A';
        ctx.fillText(String(expPerTask), modX + 500, ry + 4);
      });
    }
  } else if (statusTab === 'proposals') {
    // ── STEALTH APPROVAL PANE ──
    const propX = 16;
    const propY = contentY;
    
    // Clear action positions for click detection
    proposalActionPositions = [];
    
    // Header
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(propX, propY, TARGET_WIDTH - 32, 20);
    ctx.fillStyle = '#D4A574';
    ctx.font = 'bold 9px "JetBrains Mono"';
    const pendingCount = proposalsData.filter(p => p.status === 'pending').length;
    ctx.fillText(`▶ APPROVAL QUEUE — ${pendingCount} pending proposal${pendingCount !== 1 ? 's' : ''}`, propX + 8, propY + 14);
    
    if (proposalsData.length === 0 || proposalsData.filter(p => p.status === 'pending').length === 0) {
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText('No pending proposals. All caught up.', propX + 8, propY + 45);
    } else {
      // Column headers
      const colY = propY + 28;
      ctx.fillStyle = '#5A7A8A';
      ctx.font = 'bold 8px "JetBrains Mono"';
      ctx.fillText('PROPOSAL', propX + 8, colY);
      ctx.fillText('AGENT', propX + 280, colY);
      ctx.fillText('MODEL', propX + 360, colY);
      ctx.fillText('COST', propX + 480, colY);
      ctx.fillText('ACTIONS', propX + 560, colY);
      
      // Separator
      ctx.fillStyle = '#1A2535';
      ctx.fillRect(propX + 4, colY + 4, TARGET_WIDTH - 48, 1);
      
      // Filter to pending proposals
      const pendingProposals = proposalsData.filter(p => p.status === 'pending');
      
      const rowH = 32;
      pendingProposals.forEach((prop, i) => {
        const ry = colY + 16 + i * rowH;
        const agentColor = agentsData[prop.agent]?.color || '#7A8A9A';
        
        // Row background (alternating)
        if (i % 2 === 0) {
          ctx.fillStyle = '#0A1018';
          ctx.fillRect(propX + 4, ry - 10, TARGET_WIDTH - 48, rowH - 2);
        }
        
        // Proposal title
        ctx.fillStyle = '#C0C8D4';
        ctx.font = 'bold 9px "JetBrains Mono"';
        let title = prop.title;
        if (title.length > 35) title = title.substring(0, 32) + '...';
        ctx.fillText(title, propX + 8, ry + 4);
        
        // Summary (if fits)
        if (prop.summary) {
          ctx.fillStyle = '#5A6A7A';
          ctx.font = '7px "JetBrains Mono"';
          let summary = prop.summary;
          if (summary.length > 40) summary = summary.substring(0, 37) + '...';
          ctx.fillText(summary, propX + 8, ry + 14);
        }
        
        // Agent badge
        ctx.font = '8px "JetBrains Mono"';
        const agentW = ctx.measureText(prop.agent).width + 8;
        ctx.fillStyle = agentColor + '33';
        ctx.beginPath();
        ctx.roundRect(propX + 280, ry - 6, agentW, 14, 3);
        ctx.fill();
        ctx.fillStyle = agentColor;
        ctx.fillText(prop.agent, propX + 284, ry + 4);
        
        // Model badge
        const mColor = getModelColor(prop.recommendedModel);
        ctx.fillStyle = mColor + '33';
        const modelW = ctx.measureText(prop.recommendedModel).width + 8;
        ctx.beginPath();
        ctx.roundRect(propX + 360, ry - 6, modelW, 14, 3);
        ctx.fill();
        ctx.fillStyle = mColor;
        ctx.fillText(prop.recommendedModel, propX + 364, ry + 4);
        
        // Cost estimate
        ctx.fillStyle = '#8A9AAA';
        ctx.font = '9px "JetBrains Mono"';
        ctx.fillText(prop.costEstimate || 'TBD', propX + 480, ry + 4);
        
        // Action buttons
        const btnY = ry - 8;
        const btnH = 18;
        const btnGap = 6;
        let btnX = propX + 560;
        
        // Approve button
        const approveW = 50;
        ctx.fillStyle = '#1A3A2A';
        ctx.beginPath();
        ctx.roundRect(btnX, btnY, approveW, btnH, 3);
        ctx.fill();
        strokeRect(ctx, btnX, btnY, approveW, btnH, '#3A9A5A');
        ctx.fillStyle = '#3A9A5A';
        ctx.font = 'bold 8px "JetBrains Mono"';
        ctx.fillText('✓ OK', btnX + 12, btnY + 12);
        proposalActionPositions.push({ x: btnX, y: btnY, width: approveW, height: btnH, id: prop.id, action: 'approve' });
        btnX += approveW + btnGap;
        
        // Deny button
        const denyW = 50;
        ctx.fillStyle = '#3A1A1A';
        ctx.beginPath();
        ctx.roundRect(btnX, btnY, denyW, btnH, 3);
        ctx.fill();
        strokeRect(ctx, btnX, btnY, denyW, btnH, '#AA4A4A');
        ctx.fillStyle = '#AA4A4A';
        ctx.fillText('✗ NO', btnX + 12, btnY + 12);
        proposalActionPositions.push({ x: btnX, y: btnY, width: denyW, height: btnH, id: prop.id, action: 'deny' });
        btnX += denyW + btnGap;
        
        // Info button
        const infoW = 30;
        ctx.fillStyle = '#1A2A3A';
        ctx.beginPath();
        ctx.roundRect(btnX, btnY, infoW, btnH, 3);
        ctx.fill();
        strokeRect(ctx, btnX, btnY, infoW, btnH, '#5A7AAA');
        ctx.fillStyle = '#5A7AAA';
        ctx.fillText('?', btnX + 11, btnY + 12);
        proposalActionPositions.push({ x: btnX, y: btnY, width: infoW, height: btnH, id: prop.id, action: 'requestInfo' });
      });
    }
  }
}

// ===== CHUNK 4: CLICK/TAP HANDLING =====
function handleStatusBarClick(mouseX, mouseY) {
  // Check confirmation modal first (it blocks everything else)
  if (confirmModal.active) {
    if (handleConfirmClick(mouseX, mouseY)) return;
    // Click outside modal does nothing
    return;
  }

  // Check add task modal (it blocks everything else)
  if (addTaskModal.active) {
    if (handleAddTaskModalClick(mouseX, mouseY)) return;
    // Click outside modal does nothing
    return;
  }

  // Handle modal clicks separately
  if (modalOpen) {
    // Check modal tabs
    for (const tab of modalTabPositions) {
      if (mouseX >= tab.x && mouseX <= tab.x + tab.width &&
          mouseY >= tab.y && mouseY <= tab.y + tab.height) {
        if (tab.id === 'close') {
          modalOpen = false;
        } else {
          statusTab = tab.id;
        }
        return;
      }
    }
    
    // Check modal todos
    if (statusTab === 'todos') {
      for (const pos of modalTodoPositions) {
        if (mouseX >= pos.x && mouseX <= pos.x + pos.width &&
            mouseY >= pos.y && mouseY <= pos.y + pos.height) {
          
          // Filter buttons
          if (typeof pos.id === 'string' && pos.id.startsWith('filter_')) {
            todoFilter = pos.id.replace('filter_', '');
            return;
          }
          
          // Add button
          if (pos.id === 'add') {
            showAddTaskModal((text, assignedTo) => {
              fetch('/api/todos', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                body: JSON.stringify({ action: 'add', text, assignedTo })
              }).then(() => fetchStatusBoardData());
            });
            return;
          }
          
          // Delete button
          if (pos.type === 'delete') {
            showConfirm(`Delete task "${pos.text || 'this task'}"?`, () => {
              fetch('/api/todos', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                body: JSON.stringify({ action: 'delete', id: pos.id })
              }).then(() => fetchStatusBoardData());
            });
            return;
          }
          
          // Assignment dropdown
          if (pos.type === 'assign') {
            const agents = ['Flint', 'Cipher'];
            const currentAssignee = pos.todo.assignedTo;
            // Build prompt with options
            let promptText = 'Assign to:\n';
            promptText += '0 - Unassign (clear)\n';
            agents.forEach((a, i) => {
              const marker = a === currentAssignee ? ' *' : '';
              promptText += `${i + 1} - ${a}${marker}\n`;
            });
            const choice = prompt(promptText);
            if (choice !== null) {
              const idx = parseInt(choice);
              if (idx === 0) {
                // Unassign
                fetch('/api/todos', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                  body: JSON.stringify({ action: 'unassign', id: pos.id })
                }).then(() => fetchStatusBoardData());
              } else if (idx >= 1 && idx <= agents.length) {
                const newAssignee = agents[idx - 1];
                fetch('/api/todos', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                  body: JSON.stringify({ action: 'assign', id: pos.id, assignedTo: newAssignee })
                }).then(() => fetchStatusBoardData());
              }
            }
            return;
          }
          
          // Toggle todo (click on card or checkbox)
          if (pos.type === 'todo' || pos.type === 'toggle') {
            fetch('/api/todos', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'complete', id: pos.id })
            }).then(() => fetchStatusBoardData());
            return;
          }
        }
      }
    }

    // Check modal proposals
    if (statusTab === 'proposals') {
      for (const pos of modalProposalPositions) {
        if (mouseX >= pos.x && mouseX <= pos.x + pos.width &&
            mouseY >= pos.y && mouseY <= pos.y + pos.height) {
          const proposal = proposalsData.find(p => p.id === pos.id);
          if (!proposal) return;

          if (pos.action === 'approve') {
            fetch('/api/proposals', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'approve', id: pos.id })
            }).then(() => fetchStatusBoardData());
          } else if (pos.action === 'deny') {
            fetch('/api/proposals', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'deny', id: pos.id })
            }).then(() => fetchStatusBoardData());
          } else if (pos.action === 'requestInfo') {
            fetch('/api/proposals', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'requestInfo', id: pos.id })
            }).then(() => fetchStatusBoardData());
          }
          return;
        }
      }
    }
    return;
  }

  // Check if clicking on modal button
  for (const tab of statusTabPositions) {
    if (tab.id === 'modal') {
      if (mouseX >= tab.x && mouseX <= tab.x + tab.width &&
          mouseY >= tab.y && mouseY <= tab.y + tab.height) {
        modalOpen = true;
        modalTabPositions = [];
        modalTodoPositions = [];
        return;
      }
    }
  }

  // Check if clicking on a tab
  for (const tab of statusTabPositions) {
    if (tab.id !== 'modal' && mouseX >= tab.x && mouseX <= tab.x + tab.width &&
        mouseY >= tab.y && mouseY <= tab.y + tab.height) {
      statusTab = tab.id;
      return;
    }
  }

  // Check if click is within status bar area (for non-modal)
  if (mouseY < BAR_Y || mouseY > TARGET_HEIGHT) return;

  // Check if clicking on a todo
  if (statusTab === 'todos') {
    for (const pos of todoPositions) {
      const hit = mouseX >= pos.x && mouseX <= pos.x + pos.width &&
                  mouseY >= pos.y && mouseY <= pos.y + pos.height;
      if (hit) {
        // Filter buttons
        if (typeof pos.id === 'string' && pos.id.startsWith('filter_')) {
          todoFilter = pos.id.replace('filter_', '');
          return;
        }
        
        // Add button
        if (pos.id === 'add') {
          showAddTaskModal((text, assignedTo) => {
            fetch('/api/todos', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'add', text, assignedTo })
            }).then(() => fetchStatusBoardData());
          });
          return;
        }
        
        // Delete button
        if (pos.type === 'delete') {
          showConfirm(`Delete task "${pos.text || 'this task'}"?`, () => {
            fetch('/api/todos', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'delete', id: pos.id })
            }).then(() => fetchStatusBoardData());
          });
          return;
        }
        
        // Todo item (checkbox or card click)
        if (pos.type === 'todo' || pos.type === 'toggle') {
          fetch('/api/todos', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
            body: JSON.stringify({ action: 'complete', id: pos.id })
          }).then(() => fetchStatusBoardData());
          return;
        }
      }
    }
  }

  // Check if clicking on an agent card
  for (const pos of cardPositions) {
    if (mouseX >= pos.x && mouseX <= pos.x + pos.width &&
        mouseY >= pos.y && mouseY <= pos.y + pos.height) {
      // Reserved for future interaction (agent detail panel, etc.)
      return;
    }
  }

  // Check if clicking on a proposal action
  if (statusTab === 'proposals') {
    for (const pos of proposalActionPositions) {
      if (mouseX >= pos.x && mouseX <= pos.x + pos.width &&
          mouseY >= pos.y && mouseY <= pos.y + pos.height) {
        const proposal = proposalsData.find(p => p.id === pos.id);
        if (!proposal) return;

        if (pos.action === 'approve') {
          fetch('/api/proposals', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
            body: JSON.stringify({ action: 'approve', id: pos.id })
          }).then(() => fetchStatusBoardData());
        } else if (pos.action === 'deny') {
          fetch('/api/proposals', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
            body: JSON.stringify({ action: 'deny', id: pos.id })
          }).then(() => fetchStatusBoardData());
        } else if (pos.action === 'requestInfo') {
          fetch('/api/proposals', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
            body: JSON.stringify({ action: 'requestInfo', id: pos.id })
          }).then(() => fetchStatusBoardData());
        }
        return;
      }
    }
  }
}

// ===== MODAL OVERLAY =====
function drawModalOverlay() {
  // Clear click positions every frame
  modalTabPositions = [];
  modalTodoPositions = [];
  
  const MODAL_PADDING = 40;
  const MODAL_W = canvas.width - MODAL_PADDING * 2;
  const MODAL_H = canvas.height - MODAL_PADDING * 2;
  const MODAL_X = MODAL_PADDING;
  const MODAL_Y = MODAL_PADDING;

  // Dark overlay
  ctx.fillStyle = '#000000';
  ctx.globalAlpha = 0.85;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.globalAlpha = 1;

  // Modal background
  ctx.fillStyle = '#0A0F14';
  ctx.beginPath();
  ctx.roundRect(MODAL_X, MODAL_Y, MODAL_W, MODAL_H, 12);
  ctx.fill();
  
  // Modal border
  strokeRect(ctx, MODAL_X, MODAL_Y, MODAL_W, MODAL_H, '#2A4A6A');

  // Modal header with tabs
  const modalTabs = [
    { id: 'agents', label: 'AGENTS' },
    { id: 'todos', label: 'TO-DO' },
    { id: 'activity', label: 'ACTIVITY' },
    { id: 'models', label: 'MODELS' },
    { id: 'proposals', label: 'APPROVAL' }
  ];
  
  let mTabX = MODAL_X + 20;
  const mTabW = 100;
  const mTabH = 28;
  const mTabY = MODAL_Y + 20;
  
  modalTabs.forEach(tab => {
    const isActive = statusTab === tab.id;
    ctx.fillStyle = isActive ? '#1A2A3A' : '#0D1520';
    ctx.beginPath();
    ctx.roundRect(mTabX, mTabY, mTabW, mTabH, 4);
    ctx.fill();
    strokeRect(ctx, mTabX, mTabY, mTabW, mTabH, isActive ? '#4A7AAA' : '#1A2535');
    ctx.fillStyle = isActive ? '#AADDEE' : '#5A7A8A';
    ctx.font = 'bold 11px "JetBrains Mono"';
    ctx.fillText(tab.label, mTabX + 16, mTabY + 19);
    
    // Store tab position
    modalTabPositions.push({ x: mTabX, y: mTabY, width: mTabW, height: mTabH, id: tab.id });
    mTabX += mTabW + 8;
  });

  // Close button
  const closeX = MODAL_X + MODAL_W - 100;
  ctx.fillStyle = '#2A1A1A';
  ctx.beginPath();
  ctx.roundRect(closeX, mTabY, 80, mTabH, 4);
  ctx.fill();
  strokeRect(ctx, closeX, mTabY, 80, mTabH, '#6A3A3A');
  ctx.fillStyle = '#DD6666';
  ctx.font = 'bold 11px "JetBrains Mono"';
  ctx.fillText('✕ CLOSE', closeX + 18, mTabY + 19);
  modalTabPositions.push({ x: closeX, y: mTabY, width: 80, height: mTabH, id: 'close' });

  // Content area
  const contentX = MODAL_X + 20;
  const contentY = mTabY + mTabH + 20;
  const contentW = MODAL_W - 40;
  const contentH = MODAL_Y + MODAL_H - contentY - 20;

  if (statusTab === 'agents') {
    // ── AGENTS GRID (larger, more detail) ──
    const cardW = 180;
    const cardH = 140;
    const cardGap = 12;
    const cardsPerRow = Math.floor(contentW / (cardW + cardGap));
    
    entities.forEach((ent, i) => {
      const col = i % cardsPerRow;
      const row = Math.floor(i / cardsPerRow);
      const cx = contentX + col * (cardW + cardGap);
      const cy = contentY + row * (cardH + cardGap);
      
      // Card
      ctx.fillStyle = '#0D1520';
      ctx.beginPath();
      ctx.roundRect(cx, cy, cardW, cardH, 6);
      ctx.fill();
      strokeRect(ctx, cx, cy, cardW, cardH, '#1A2535');
      
      // Accent bar
      ctx.fillStyle = ent.color;
      ctx.globalAlpha = 0.5;
      ctx.fillRect(cx + 4, cy + 8, 3, cardH - 16);
      ctx.globalAlpha = 1;
      
      // Name + Level
      ctx.fillStyle = ent.color;
      ctx.font = 'bold 14px "JetBrains Mono"';
      ctx.fillText(ent.name, cx + 14, cy + 24);
      
      ctx.fillStyle = '#3A4A5A';
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(`Lv${ent.level}`, cx + cardW - 40, cy + 24);
      
      // Role
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '10px "JetBrains Mono"';
      ctx.fillText(ent.role, cx + 14, cy + 42);
      
      // Status
      const statusDot = ent.status === 'working' ? '#3A9A5A' : (ent.status === 'meeting' ? '#AA953A' : '#6A5A4A');
      ctx.fillStyle = statusDot;
      ctx.beginPath();
      ctx.arc(cx + 14, cy + 60, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#8A9AAA';
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(ent.status.toUpperCase(), cx + 26, cy + 64);
      
      // Model badge (if available)
      if (ent.currentModel && ent.currentModel !== 'unknown') {
        const mColor = getModelColor(ent.currentModel);
        ctx.font = '7px "JetBrains Mono"';
        const mText = ent.currentModel;
        const mTextW = ctx.measureText(mText).width + 8;
        const mBadgeX = cx + cardW - mTextW - 10;
        ctx.fillStyle = mColor + '33';
        ctx.beginPath();
        ctx.roundRect(mBadgeX, cy + 54, mTextW, 14, 3);
        ctx.fill();
        ctx.fillStyle = mColor;
        ctx.fillText(mText, mBadgeX + 4, cy + 64);
      }
      
      // Current task (if working)
      if (ent.status === 'working' && ent.currentTask) {
        ctx.fillStyle = '#6A7A8A';
        ctx.font = '8px "JetBrains Mono"';
        let taskText = ent.currentTask;
        // Truncate if too long
        while (ctx.measureText(taskText).width > cardW - 30 && taskText.length > 8) {
          taskText = taskText.slice(0, -4) + '...';
        }
        ctx.fillText('📋 ' + taskText, cx + 14, cy + 78);
      }
      
      // EXP bar
      const expBarW = cardW - 28;
      ctx.fillStyle = '#0A0F14';
      ctx.beginPath();
      ctx.roundRect(cx + 14, cy + 80, expBarW, 10, 3);
      ctx.fill();
      let expProg = ent.expProgress;
      if (expProg === undefined) expProg = ent.exp / ent.nextLevel;
      ctx.fillStyle = ent.color;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.roundRect(cx + 14, cy + 80, expBarW * expProg, 10, 3);
      ctx.fill();
      ctx.globalAlpha = 1;
      strokeRect(ctx, cx + 14, cy + 80, expBarW, 10, '#1A2535');
      
      // EXP text
      ctx.fillStyle = '#4A5A6A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText(`${ent.exp} / ${ent.nextLevel} XP`, cx + 14, cy + 108);
      
      // Tier
      const tierMap = { 'Director': 'T1', 'Systems': 'T2', 'Security': 'T2', 'Tech Director': 'T3', 'Heavy Coder': 'T3', 'Coder': 'T4', 'Maintenance': 'T5', 'QA': 'T5', 'Recon': 'T5' };
      const tier = tierMap[ent.role] || '';
      if (tier) {
        ctx.fillStyle = '#1A2535';
        ctx.beginPath();
        ctx.roundRect(cx + cardW - 32, cy + 90, 24, 16, 3);
        ctx.fill();
        ctx.fillStyle = '#5A6A7A';
        ctx.font = 'bold 9px "JetBrains Mono"';
        ctx.fillText(tier, cx + cardW - 28, cy + 102);
      }
    });
    
  } else if (statusTab === 'todos') {
    // ── TO-DO LIST (full cards with filters) ──
    const todoX = contentX;
    const todoY = contentY;
    
    // Filter buttons row - ALL + agent names
    const mAgentNames = ['Flint', 'Cipher'];
    const mFilterBtns = [{ id: 'all', label: 'ALL' }].concat(
      mAgentNames.map(name => ({ id: name.toLowerCase(), label: name }))
    );
    
    let mFilterX = todoX;
    const mFilterY = todoY;
    mFilterBtns.forEach((btn, idx) => {
      const isActive = todoFilter === btn.id;
      const btnW = idx === 0 ? 50 : 70;
      const agentColor = idx > 0 ? (agentsData[mAgentNames[idx-1]]?.color || '#5A7A8A') : null;
      
      ctx.fillStyle = isActive ? '#1A3545' : '#0D1520';
      ctx.beginPath();
      ctx.roundRect(mFilterX, mFilterY, btnW, 26, 4);
      ctx.fill();
      strokeRect(ctx, mFilterX, mFilterY, btnW, 26, isActive ? (agentColor || '#4A8ABA') : '#1A2535');
      ctx.fillStyle = isActive ? (agentColor || '#AADDEE') : (agentColor ? agentColor + '99' : '#5A7A8A');
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText(btn.label, mFilterX + 8, mFilterY + 17);
      modalTodoPositions.push({ x: mFilterX, y: mFilterY, width: btnW, height: 26, id: 'filter_' + btn.id });
      mFilterX += btnW + 4;
    });
    
    // Add button
    const mAddX = contentX + contentW - 130;
    ctx.fillStyle = '#1A4A3A';
    ctx.beginPath();
    ctx.roundRect(mAddX, mFilterY, 120, 26, 4);
    ctx.fill();
    strokeRect(ctx, mAddX, mFilterY, 120, 26, '#3A8A6A');
    ctx.fillStyle = '#5AAA9A';
    ctx.font = 'bold 10px "JetBrains Mono"';
    ctx.fillText('+ ADD TASK', mAddX + 18, mFilterY + 17);
    modalTodoPositions.push({ x: mAddX, y: mFilterY, width: 120, height: 26, id: 'add' });
    
    // Filter todos by agent name
    const mAgentFilterNames = ['flint', 'cipher', 'atlas', 'vera'];
    const mFilteredTodos = todosData.filter(todo => {
      if (todoFilter === 'all') return true;
      if (mAgentFilterNames.includes(todoFilter)) {
        return todo.assignedTo && todo.assignedTo.toLowerCase() === todoFilter;
      }
      return true;
    });
    
    // Draw todo cards
    const cardW = contentW - 20;
    const cardH = 70;
    const cardGap = 10;
    const cardsPerRow = 1;
    const cardStartY = mFilterY + 40;
    
    mFilteredTodos.forEach((todo, i) => {
      const row = i;
      const cx = todoX + 10;
      const cy = cardStartY + row * (cardH + cardGap);
      
      // Card background
      ctx.fillStyle = todo.done ? '#0D1A12' : '#0D1520';
      ctx.beginPath();
      ctx.roundRect(cx, cy, cardW, cardH, 6);
      ctx.fill();
      strokeRect(ctx, cx, cy, cardW, cardH, todo.done ? '#1A3A2A' : '#1A2A3A');
      
      // Left accent bar
      const accentColor = todo.assignedTo ? 
        (todo.assignedTo === currentUser ? '#00D4FF' : '#9966CC') : 
        (todo.done ? '#3A7A5A' : '#3A5A6A');
      ctx.fillStyle = accentColor;
      ctx.fillRect(cx, cy + 4, 4, cardH - 8);
      
      // Checkbox
      const cbX = cx + 16;
      const cbY = cy + 16;
      ctx.strokeStyle = todo.done ? '#3A7A5A' : '#3A5A6A';
      ctx.lineWidth = 2;
      ctx.strokeRect(cbX, cbY, 18, 18);
      if (todo.done) {
        ctx.fillStyle = '#3A7A5A';
        ctx.font = 'bold 14px "JetBrains Mono"';
        ctx.fillText('✓', cbX + 3, cbY + 14);
      }
      
      // Task text
      ctx.fillStyle = todo.done ? '#4A6A5A' : '#C0D0E0';
      ctx.font = '12px "JetBrains Mono"';
      ctx.fillText(todo.text, cbX + 28, cbY + 14);
      
      // Meta info row
      const metaY = cy + 42;
      
      // Created by
      ctx.fillStyle = '#3A4A5A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText(`Created by ${todo.createdBy}`, cbX, metaY);
      
      // Created time (relative)
      if (todo.createdAt) {
        const created = new Date(todo.createdAt);
        const now = new Date();
        const diffMs = now - created;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        const diffDays = Math.floor(diffHours / 24);
        let timeAgo;
        if (diffDays > 0) timeAgo = `${diffDays}d ago`;
        else if (diffHours > 0) timeAgo = `${diffHours}h ago`;
        else if (diffMins > 0) timeAgo = `${diffMins}m ago`;
        else timeAgo = 'just now';
        ctx.fillText(timeAgo, cbX + ctx.measureText(`Created by ${todo.createdBy}`).width + 20, metaY);
      }
      
      // Assigned to badge (clickable dropdown)
      const badgeX = cx + cardW - 180;
      let badgeColor, badgeText;
      if (!todo.assignedTo) {
        badgeColor = '#4A5A6A';
        badgeText = 'Unassigned';
      } else if (todo.assignedTo === currentUser) {
        badgeColor = '#00D4FF';
        badgeText = todo.assignedTo + ' (You)';
      } else {
        badgeColor = '#9966CC';
        badgeText = todo.assignedTo;
      }
      
      // Badge background
      const badgeW = ctx.measureText(badgeText).width + 16;
      ctx.fillStyle = badgeColor + '33';
      ctx.beginPath();
      ctx.roundRect(badgeX, metaY - 8, badgeW, 18, 4);
      ctx.fill();
      ctx.fillStyle = badgeColor;
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText(badgeText, badgeX + 8, metaY + 4);
      modalTodoPositions.push({ x: badgeX, y: metaY - 8, width: badgeW, height: 18, id: todo.id, type: 'assign', todo: todo });
      
      // Delete button (small X)
      const delX = cx + cardW - 30;
      ctx.fillStyle = '#3A2A2A';
      ctx.beginPath();
      ctx.roundRect(delX, metaY - 8, 22, 18, 3);
      ctx.fill();
      strokeRect(ctx, delX, metaY - 8, 22, 18, '#5A3A3A');
      ctx.fillStyle = '#AA5555';
      ctx.font = 'bold 10px "JetBrains Mono"';
      ctx.fillText('✕', delX + 7, metaY + 4);
      modalTodoPositions.push({ x: delX, y: metaY - 8, width: 22, height: 18, id: todo.id, type: 'delete', todo: todo });
      
      // Store for click (whole card for toggle)
      modalTodoPositions.push({ x: cx, y: cy, width: cardW, height: cardH, id: todo.id, type: 'todo' });
    });
    
    // Show count
    ctx.fillStyle = '#3A4A5A';
    ctx.font = '9px "JetBrains Mono"';
    ctx.fillText(`${mFilteredTodos.length} task(s)`, todoX + 10, cardStartY + mFilteredTodos.length * (cardH + cardGap) + 20);
    
  } else if (statusTab === 'activity') {
    // ── CLI-STYLE ACTIVITY LOG ──
    const cliX = contentX + 10;
    let cliY = contentY + 10;
    const lineH = 22;
    const maxLines = Math.floor(contentH / lineH);
    
    // CLI-style header
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(cliX, cliY, contentW - 20, 28);
    ctx.fillStyle = '#4A9A6A';
    ctx.font = 'bold 12px "JetBrains Mono"';
    ctx.fillText('▶ ACTIVITY LOG', cliX + 10, cliY + 19);
    cliY += 36;
    
    // Each entry as CLI line
    activityData.slice(0, maxLines - 2).forEach((act, i) => {
      // Timestamp
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '11px "JetBrains Mono"';
      ctx.fillText(`[${act.time}]`, cliX, cliY + 14);
      
      // Agent name (colored)
      const agentColor = agentsData[act.agent]?.color || '#AAAAAA';
      ctx.fillStyle = agentColor;
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(act.agent + ':', cliX + 80, cliY + 14);
      
      // Model badge (in modal — slightly larger)
      const modalModelName = act.model || 'unknown';
      let actionStartOffset = 160;
      if (modalModelName !== 'unknown') {
        const mmColor = getModelColor(modalModelName);
        ctx.font = '8px "JetBrains Mono"';
        const mmw = ctx.measureText(modalModelName).width + 8;
        ctx.fillStyle = mmColor + '33';
        ctx.beginPath();
        ctx.roundRect(cliX + 158, cliY + 4, mmw, 13, 3);
        ctx.fill();
        ctx.fillStyle = mmColor;
        ctx.fillText(modalModelName, cliX + 162, cliY + 13);
        actionStartOffset = 168 + mmw;
      }
      
      // Action + Task
      ctx.fillStyle = '#8A9AAA';
      ctx.font = '11px "JetBrains Mono"';
      const actionStart = cliX + actionStartOffset;
      const taskPart = act.task ? ` ${act.task}` : '';
      let displayText = act.action + taskPart;
      const maxChars = Math.floor((contentW - actionStartOffset - 20) / 7);
      if (displayText.length > maxChars) {
        displayText = displayText.substring(0, maxChars - 3) + '...';
      }
      ctx.fillText(displayText, actionStart, cliY + 14);
      
      // EXP change
      const expColor = act.exp > 0 ? '#3A9A5A' : (act.exp < 0 ? '#AA4A4A' : '#5A6A7A');
      ctx.fillStyle = expColor;
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(act.expChange, cliX + contentW - 100, cliY + 14);
      
      cliY += lineH;
    });
  } else if (statusTab === 'models') {
    // ── MODEL PERFORMANCE STATS (Modal view — larger, more detail) ──
    const modX = contentX + 10;
    let modY = contentY + 10;
    
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(modX, modY, contentW - 20, 28);
    ctx.fillStyle = '#D4A574';
    ctx.font = 'bold 12px "JetBrains Mono"';
    ctx.fillText('▶ MODEL PERFORMANCE', modX + 10, modY + 19);
    modY += 40;
    
    const modelNames = Object.keys(modelStatsData).filter(m => m !== 'unknown');
    if (modelNames.length === 0) {
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '11px "JetBrains Mono"';
      ctx.fillText('No model data yet. Use --model flag with grant-exp.js', modX + 10, modY + 20);
    } else {
      // Sort by win rate
      const sorted = modelNames.sort((a, b) => {
        const aStats = modelStatsData[a];
        const bStats = modelStatsData[b];
        const aWR = aStats.tasks > 0 ? aStats.wins / aStats.tasks : 0;
        const bWR = bStats.tasks > 0 ? bStats.wins / bStats.tasks : 0;
        return bWR - aWR;
      });
      
      // Model cards
      const cardW = 220;
      const cardH = 120;
      const cardGap = 12;
      const cardsPerRow = Math.floor(contentW / (cardW + cardGap));
      
      sorted.forEach((model, i) => {
        const stats = modelStatsData[model];
        const col = i % cardsPerRow;
        const row = Math.floor(i / cardsPerRow);
        const cx = modX + col * (cardW + cardGap);
        const cy = modY + row * (cardH + cardGap);
        const mColor = getModelColor(model);
        const winRate = stats.tasks > 0 ? Math.round((stats.wins / stats.tasks) * 100) : 0;
        
        // Card bg
        ctx.fillStyle = '#0D1520';
        ctx.beginPath();
        ctx.roundRect(cx, cy, cardW, cardH, 6);
        ctx.fill();
        strokeRect(ctx, cx, cy, cardW, cardH, '#1A2535');
        
        // Color accent bar
        ctx.fillStyle = mColor;
        ctx.globalAlpha = 0.6;
        ctx.fillRect(cx, cy + 4, 4, cardH - 8);
        ctx.globalAlpha = 1;
        
        // Model name
        ctx.fillStyle = mColor;
        ctx.font = 'bold 13px "JetBrains Mono"';
        ctx.fillText(model, cx + 14, cy + 22);
        
        // Win rate badge
        const wrColor = winRate >= 75 ? '#3A9A5A' : (winRate >= 50 ? '#AAAA4A' : '#AA4A4A');
        ctx.fillStyle = wrColor;
        ctx.font = 'bold 14px "JetBrains Mono"';
        ctx.fillText(winRate + '%', cx + cardW - 50, cy + 22);
        
        // Stats
        ctx.fillStyle = '#5A6A7A';
        ctx.font = '10px "JetBrains Mono"';
        ctx.fillText(`Tasks: ${stats.tasks}`, cx + 14, cy + 44);
        ctx.fillStyle = '#3A9A5A';
        ctx.fillText(`Wins: ${stats.wins}`, cx + 14, cy + 60);
        ctx.fillStyle = '#AA4A4A';
        ctx.fillText(`Losses: ${stats.losses}`, cx + 110, cy + 60);
        
        // Net EXP
        const expSign = stats.totalExp >= 0 ? '+' : '';
        ctx.fillStyle = stats.totalExp >= 0 ? '#3A9A5A' : '#AA4A4A';
        ctx.font = 'bold 11px "JetBrains Mono"';
        ctx.fillText(`Net: ${expSign}${stats.totalExp} XP`, cx + 14, cy + 80);
        
        // Win rate bar
        const barX = cx + 14;
        const barY = cy + 90;
        const barW = cardW - 28;
        const barH = 8;
        ctx.fillStyle = '#0A0F14';
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW, barH, 3);
        ctx.fill();
        ctx.fillStyle = mColor;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.roundRect(barX, barY, barW * (winRate / 100), barH, 3);
        ctx.fill();
        ctx.globalAlpha = 1;
        strokeRect(ctx, barX, barY, barW, barH, '#1A2535');
        
        // Agents breakdown (small text at bottom)
        const agentNames = Object.keys(stats.agents || {});
        if (agentNames.length > 0) {
          ctx.fillStyle = '#4A5A6A';
          ctx.font = '7px "JetBrains Mono"';
          const agentText = agentNames.map(a => `${a}:${stats.agents[a].tasks}`).join(' · ');
          ctx.fillText(agentText, cx + 14, cy + 112);
        }
      });
    }
  } else if (statusTab === 'proposals') {
    // ── MODAL: STEALTH APPROVAL PANE ──
    const propX = contentX + 10;
    let propY = contentY + 10;
    
    // Clear modal proposal positions
    modalProposalPositions = [];
    
    // Header
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(propX, propY, contentW - 20, 28);
    ctx.fillStyle = '#D4A574';
    ctx.font = 'bold 12px "JetBrains Mono"';
    const pendingCount = proposalsData.filter(p => p.status === 'pending').length;
    ctx.fillText(`▶ APPROVAL QUEUE — ${pendingCount} pending`, propX + 10, propY + 19);
    propY += 40;
    
    if (proposalsData.length === 0 || proposalsData.filter(p => p.status === 'pending').length === 0) {
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '11px "JetBrains Mono"';
      ctx.fillText('No pending proposals. All caught up.', propX + 10, propY + 20);
    } else {
      // Column headers
      ctx.fillStyle = '#5A7A8A';
      ctx.font = 'bold 10px "JetBrains Mono"';
      ctx.fillText('PROPOSAL', propX + 10, propY);
      ctx.fillText('AGENT', propX + 320, propY);
      ctx.fillText('MODEL', propX + 420, propY);
      ctx.fillText('COST', propX + 560, propY);
      ctx.fillText('ACTIONS', propX + 640, propY);
      propY += 10;
      
      // Separator
      ctx.fillStyle = '#1A2535';
      ctx.fillRect(propX + 4, propY, contentW - 28, 1);
      propY += 15;
      
      // Filter to pending proposals
      const pendingProposals = proposalsData.filter(p => p.status === 'pending');
      
      const rowH = 40;
      pendingProposals.forEach((prop, i) => {
        const ry = propY + i * rowH;
        const agentColor = agentsData[prop.agent]?.color || '#7A8A9A';
        
        // Row background (alternating)
        if (i % 2 === 0) {
          ctx.fillStyle = '#0A1018';
          ctx.fillRect(propX + 4, ry - 10, contentW - 28, rowH - 4);
        }
        
        // Proposal title
        ctx.fillStyle = '#C0C8D4';
        ctx.font = 'bold 11px "JetBrains Mono"';
        let title = prop.title;
        if (title.length > 40) title = title.substring(0, 37) + '...';
        ctx.fillText(title, propX + 10, ry + 6);
        
        // Summary
        if (prop.summary) {
          ctx.fillStyle = '#5A6A7A';
          ctx.font = '9px "JetBrains Mono"';
          let summary = prop.summary;
          if (summary.length > 50) summary = summary.substring(0, 47) + '...';
          ctx.fillText(summary, propX + 10, ry + 18);
        }
        
        // Agent badge
        ctx.font = '10px "JetBrains Mono"';
        const agentW = ctx.measureText(prop.agent).width + 10;
        ctx.fillStyle = agentColor + '33';
        ctx.beginPath();
        ctx.roundRect(propX + 320, ry - 8, agentW, 18, 4);
        ctx.fill();
        ctx.fillStyle = agentColor;
        ctx.fillText(prop.agent, propX + 325, ry + 6);
        
        // Model badge
        const mColor = getModelColor(prop.recommendedModel);
        ctx.fillStyle = mColor + '33';
        const modelW = ctx.measureText(prop.recommendedModel).width + 10;
        ctx.beginPath();
        ctx.roundRect(propX + 420, ry - 8, modelW, 18, 4);
        ctx.fill();
        ctx.fillStyle = mColor;
        ctx.fillText(prop.recommendedModel, propX + 425, ry + 6);
        
        // Cost estimate
        ctx.fillStyle = '#8A9AAA';
        ctx.font = '11px "JetBrains Mono"';
        ctx.fillText(prop.costEstimate || 'TBD', propX + 560, ry + 6);
        
        // Action buttons
        const btnY = ry - 10;
        const btnH = 22;
        const btnGap = 8;
        let btnX = propX + 640;
        
        // Approve button
        const approveW = 60;
        ctx.fillStyle = '#1A3A2A';
        ctx.beginPath();
        ctx.roundRect(btnX, btnY, approveW, btnH, 4);
        ctx.fill();
        strokeRect(ctx, btnX, btnY, approveW, btnH, '#3A9A5A');
        ctx.fillStyle = '#3A9A5A';
        ctx.font = 'bold 10px "JetBrains Mono"';
        ctx.fillText('✓ APPROVE', btnX + 10, btnY + 15);
        modalProposalPositions.push({ x: btnX, y: btnY, width: approveW, height: btnH, id: prop.id, action: 'approve' });
        btnX += approveW + btnGap;
        
        // Deny button
        const denyW = 60;
        ctx.fillStyle = '#3A1A1A';
        ctx.beginPath();
        ctx.roundRect(btnX, btnY, denyW, btnH, 4);
        ctx.fill();
        strokeRect(ctx, btnX, btnY, denyW, btnH, '#AA4A4A');
        ctx.fillStyle = '#AA4A4A';
        ctx.fillText('✗ DENY', btnX + 12, btnY + 15);
        modalProposalPositions.push({ x: btnX, y: btnY, width: denyW, height: btnH, id: prop.id, action: 'deny' });
        btnX += denyW + btnGap;
        
        // Info button
        const infoW = 40;
        ctx.fillStyle = '#1A2A3A';
        ctx.beginPath();
        ctx.roundRect(btnX, btnY, infoW, btnH, 4);
        ctx.fill();
        strokeRect(ctx, btnX, btnY, infoW, btnH, '#5A7AAA');
        ctx.fillStyle = '#5A7AAA';
        ctx.fillText('INFO', btnX + 10, btnY + 15);
        modalProposalPositions.push({ x: btnX, y: btnY, width: infoW, height: btnH, id: prop.id, action: 'requestInfo' });
      });
    }
  }
}

// ===== CONFIRMATION MODAL =====
function showConfirm(text, onYes, onNo = null) {
  confirmModal.active = true;
  confirmModal.text = text;
  confirmModal.onYes = onYes;
  confirmModal.onNo = onNo;
}

function showAddTaskModal(onSubmit, onCancel = null) {
  addTaskModal.active = true;
  addTaskModal.taskText = '';
  addTaskModal.selectedAssignee = currentUser;
  addTaskModal.onSubmit = onSubmit;
  addTaskModal.onCancel = onCancel;
}

function drawConfirmModal() {
  if (!confirmModal.active) return;

  const cw = canvas.width;
  const ch = canvas.height;
  const mw = 400;
  const mh = 150;
  const mx = (cw - mw) / 2;
  const my = (ch - mh) / 2;

  // Dark overlay
  ctx.fillStyle = '#000000';
  ctx.globalAlpha = 0.7;
  ctx.fillRect(0, 0, cw, ch);
  ctx.globalAlpha = 1;

  // Modal background
  ctx.fillStyle = '#0A0F14';
  ctx.beginPath();
  ctx.roundRect(mx, my, mw, mh, 12);
  ctx.fill();
  strokeRect(ctx, mx, my, mw, mh, '#2A4A6A');

  // Title
  ctx.fillStyle = '#AADDEE';
  ctx.font = 'bold 14px "JetBrains Mono"';
  ctx.fillText('Confirm', mx + 20, my + 30);

  // Message text (wrapped)
  ctx.fillStyle = '#8A9AAA';
  ctx.font = '11px "JetBrains Mono"';
  const maxLine = 50;
  let displayText = confirmModal.text;
  if (displayText.length > maxLine) {
    displayText = displayText.substring(0, maxLine - 3) + '...';
  }
  ctx.fillText(displayText, mx + 20, my + 60);

  // Yes button
  const btnY = my + mh - 50;
  const yesX = mx + 80;
  const btnW = 80;
  const btnH = 32;

  ctx.fillStyle = '#1A4A3A';
  ctx.beginPath();
  ctx.roundRect(yesX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, yesX, btnY, btnW, btnH, '#3A8A6A');
  ctx.fillStyle = '#5AAA9A';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('YES', yesX + 25, btnY + 21);

  // No button
  const noX = mx + mw - 160;
  ctx.fillStyle = '#4A2A2A';
  ctx.beginPath();
  ctx.roundRect(noX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, noX, btnY, btnW, btnH, '#8A4A4A');
  ctx.fillStyle = '#AA6666';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('NO', noX + 28, btnY + 21);

  // Store positions for click detection
  confirmModal.yesPos = { x: yesX, y: btnY, width: btnW, height: btnH };
  confirmModal.noPos = { x: noX, y: btnY, width: btnW, height: btnH };
}

function handleConfirmClick(mouseX, mouseY) {
  if (!confirmModal.active) return false;

  // Check Yes
  if (mouseX >= confirmModal.yesPos.x && mouseX <= confirmModal.yesPos.x + confirmModal.yesPos.width &&
      mouseY >= confirmModal.yesPos.y && mouseY <= confirmModal.yesPos.y + confirmModal.yesPos.height) {
    confirmModal.active = false;
    if (confirmModal.onYes) confirmModal.onYes();
    return true;
  }

  // Check No
  if (mouseX >= confirmModal.noPos.x && mouseX <= confirmModal.noPos.x + confirmModal.noPos.width &&
      mouseY >= confirmModal.noPos.y && mouseY <= confirmModal.noPos.y + confirmModal.noPos.height) {
    confirmModal.active = false;
    if (confirmModal.onNo) confirmModal.onNo();
    return true;
  }

  return false;
}

function drawAddTaskModal() {
  if (!addTaskModal.active) return;

  const cw = canvas.width;
  const ch = canvas.height;
  const mw = 420;
  const mh = 280;
  const mx = (cw - mw) / 2;
  const my = (ch - mh) / 2;

  // Dark overlay
  ctx.fillStyle = '#000000';
  ctx.globalAlpha = 0.7;
  ctx.fillRect(0, 0, cw, ch);
  ctx.globalAlpha = 1;

  // Modal background
  ctx.fillStyle = '#0A0F14';
  ctx.beginPath();
  ctx.roundRect(mx, my, mw, mh, 12);
  ctx.fill();
  strokeRect(ctx, mx, my, mw, mh, '#2A4A6A');

  // Title
  ctx.fillStyle = '#AADDEE';
  ctx.font = 'bold 14px "JetBrains Mono"';
  ctx.fillText('Add New Task', mx + 20, my + 30);

  // Task label
  ctx.fillStyle = '#8A9AAA';
  ctx.font = '11px "JetBrains Mono"';
  ctx.fillText('Task Description:', mx + 20, my + 60);

  // Task input field (styled as text box)
  const inputX = mx + 20;
  const inputY = my + 70;
  const inputW = mw - 40;
  const inputH = 36;

  ctx.fillStyle = '#1A1F28';
  ctx.beginPath();
  ctx.roundRect(inputX, inputY, inputW, inputH, 6);
  ctx.fill();
  strokeRect(ctx, inputX, inputY, inputW, inputH, '#3A4A5A');

  // Show typed text
  ctx.fillStyle = '#CCDDEE';
  ctx.font = '12px "JetBrains Mono"';
  const displayText = addTaskModal.taskText || 'Type task here...';
  const placeholder = !addTaskModal.taskText;
  if (placeholder) {
    ctx.fillStyle = '#5A6A7A';
  }
  ctx.fillText(displayText.substring(0, 40), inputX + 10, inputY + 23);

  // Store input position
  addTaskModal.inputPos = { x: inputX, y: inputY, width: inputW, height: inputH };

  // Assignee label
  ctx.fillStyle = '#8A9AAA';
  ctx.font = '11px "JetBrains Mono"';
  ctx.fillText('Assign To:', mx + 20, my + 130);

  // Assignee dropdown (styled as button)
  const dropX = mx + 20;
  const dropY = my + 140;
  const dropW = mw - 40;
  const dropH = 36;

  ctx.fillStyle = '#1A1F28';
  ctx.beginPath();
  ctx.roundRect(dropX, dropY, dropW, dropH, 6);
  ctx.fill();
  strokeRect(ctx, dropX, dropY, dropW, dropH, '#3A4A5A');

  ctx.fillStyle = '#CCDDEE';
  ctx.font = '12px "JetBrains Mono"';
  ctx.fillText(addTaskModal.selectedAssignee || 'Select...', dropX + 10, dropY + 23);

  // Dropdown indicator
  ctx.fillStyle = '#6A7A8A';
  ctx.fillText('▼', dropX + dropW - 25, dropY + 23);

  // Store dropdown position
  addTaskModal.dropdownPos = { x: dropX, y: dropY, width: dropW, height: dropH };

  // YES button (Create Task)
  const btnY = my + mh - 50;
  const yesX = mx + 100;
  const btnW = 100;
  const btnH = 32;

  ctx.fillStyle = '#1A4A3A';
  ctx.beginPath();
  ctx.roundRect(yesX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, yesX, btnY, btnW, btnH, '#3A8A6A');
  ctx.fillStyle = '#5AAA9A';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('CREATE', yesX + 20, btnY + 21);

  // NO button (Cancel)
  const noX = mx + mw - 220;
  ctx.fillStyle = '#4A2A2A';
  ctx.beginPath();
  ctx.roundRect(noX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, noX, btnY, btnW, btnH, '#8A4A4A');
  ctx.fillStyle = '#AA6666';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('CANCEL', noX + 18, btnY + 21);

  // Store button positions
  addTaskModal.yesPos = { x: yesX, y: btnY, width: btnW, height: btnH };
  addTaskModal.noPos = { x: noX, y: btnY, width: btnW, height: btnH };
}

function handleAddTaskModalClick(mouseX, mouseY) {
  if (!addTaskModal.active) return false;

  // Check Create button
  if (mouseX >= addTaskModal.yesPos.x && mouseX <= addTaskModal.yesPos.x + addTaskModal.yesPos.width &&
      mouseY >= addTaskModal.yesPos.y && mouseY <= addTaskModal.yesPos.y + addTaskModal.yesPos.height) {
    if (addTaskModal.taskText.trim()) {
      addTaskModal.active = false;
      if (addTaskModal.onSubmit) {
        addTaskModal.onSubmit(addTaskModal.taskText.trim(), addTaskModal.selectedAssignee);
      }
    }
    return true;
  }

  // Check Cancel button
  if (mouseX >= addTaskModal.noPos.x && mouseX <= addTaskModal.noPos.x + addTaskModal.noPos.width &&
      mouseY >= addTaskModal.noPos.y && mouseY <= addTaskModal.noPos.y + addTaskModal.noPos.height) {
    addTaskModal.active = false;
    if (addTaskModal.onCancel) addTaskModal.onCancel();
    return true;
  }

  // Check assignee dropdown click - cycle through agents
  if (mouseX >= addTaskModal.dropdownPos.x && mouseX <= addTaskModal.dropdownPos.x + addTaskModal.dropdownPos.width &&
      mouseY >= addTaskModal.dropdownPos.y && mouseY <= addTaskModal.dropdownPos.y + addTaskModal.dropdownPos.height) {
    const agents = addTaskModal.agents;
    const currentIdx = agents.indexOf(addTaskModal.selectedAssignee);
    const nextIdx = (currentIdx + 1) % agents.length;
    addTaskModal.selectedAssignee = agents[nextIdx];
    return true;
  }

  return false;
}

// ===== MAIN STATUS BAR =====
function drawStatusBar() {
  // Unified layout for all devices (removed mobile/desktop split)
  drawDesktopStatusBar();
}

// ===== POLLING =====
let pollTimer = 0;
async function pollStatus() {
  try {
    // Fetch agent sessions for model info
    try {
      const sessRes = await fetch('/api/agent-sessions');
      if (sessRes.ok) {
        const sessData = await sessRes.json();
        for (const [agentName, info] of Object.entries(sessData)) {
          agentSessionModels[agentName] = info.model || 'unknown';
        }
      }
    } catch(e) { /* ignore */ }

    const res = await fetch('/api/employee-status');
    if (res.ok) {
      const data = await res.json();
      // Check for meetingActive in response
      if (data.meetingActive !== undefined) {
        meetingActive = data.meetingActive === true;
      }
      // Check for meetingLocation in response
      if (data.meetingLocation !== undefined) {
        meetingLocation = data.meetingLocation;
      }
      // Check for heartbeatRecent in response
      if (data.heartbeatRecent !== undefined) {
        heartbeatRecent = data.heartbeatRecent === true;
      }
      // Handle employee status array
      const agents = data.agents || data.employees || data;
      if (Array.isArray(agents)) {
        agents.forEach(s => {
          const ent = entities.find(e => e.name.toLowerCase() === s.name?.toLowerCase());
          if (ent) {
            ent.status = s.status || 'idle';
            // Update EXP/level data from server
            if (s.level !== undefined) ent.level = s.level;
            if (s.exp !== undefined) ent.exp = s.exp;
            if (s.nextLevel !== undefined) ent.nextLevel = s.nextLevel;
            if (s.expProgress !== undefined) ent.expProgress = s.expProgress / 100; // API sends 0-100, we use 0-1
            // Update current task and model
            if (s.currentTask !== undefined) ent.currentTask = s.currentTask;
            if (s.currentModel !== undefined) ent.currentModel = s.currentModel;
          }
        });
      }
    }
  } catch(e) {
    // API not available — that's fine, use default state
  }
}

// ===== INITIALIZATION =====
const entities = AGENTS.map(a => new AgentEntity(a));
const companions = [];
entities.forEach(ent => {
  if (ent.companion) {
    companions.push(new CompanionEntity(ent.companion, ent));
  }
});

// Model color mapping for badges
function getModelColor(model) {
  const colors = {
    'claude-opus': '#D4A574',
    'claude-sonnet': '#C09060',
    'claude-haiku': '#A07848',
    'claude': '#B08860',
    'gpt-5': '#74AA9C',
    'gpt-4': '#5A9A8A',
    'o3': '#4A8A7A',
    'o4-mini': '#3A7A6A',
    'codex': '#2A6A5A',
    'gemini-pro': '#4285F4',
    'gemini-flash': '#34A853',
    'gemini': '#4285F4',
    'kimi': '#FF6B6B',
    'grok': '#FF4500',
    'deepseek': '#6B5BFF',
    'qwen': '#FF8C42',
    'mistral': '#F7D046',
    'unknown': '#5A6A7A',
  };
  return colors[model] || '#7A8A9A';
}

// Status board data
let todosData = [];
let activityData = [];
let commsData = []; // Agent-to-agent communications
let proposalsData = [];
let modelStatsData = {}; // Model performance stats
let agentsData = {}; // Map of agent name -> agent data (for colors)
let statusTabPositions = [];
let todoPositions = [];
let proposalActionPositions = [];
let modalTabPositions = [];
let modalTodoPositions = [];
let modalProposalPositions = [];
let todoFilter = 'all'; // 'all' or agent name lowercase ('flint', 'cipher', etc.)
let currentUser = 'Flint'; // Current user (not used for filtering anymore)
let agentSessionModels = {}; // Map of agent name -> current model

// Fetch todos and activity data
async function fetchStatusBoardData() {
  try {
    const [todosRes, activityRes, statusRes, modelRes, proposalsRes, commsRes] = await Promise.all([
      fetch('/api/todos'),
      fetch('/api/todos/activity'),
      fetch('/api/employee-status'),
      fetch('/api/model-stats'),
      fetch('/api/proposals'),
      fetch('/api/agent-comms')
    ]);
    todosData = await todosRes.json();
    activityData = await activityRes.json();
    try {
      proposalsData = await proposalsRes.json();
    } catch(e) {
      proposalsData = [];
    }
    // Store comms data
    try {
      commsData = await commsRes.json();
    } catch(e) {
      commsData = [];
    }
    // Add expChange display field
    activityData.forEach(act => {
      act.expChange = act.exp > 0 ? `+${act.exp}` : (act.exp < 0 ? `${act.exp}` : '');
    });
    const statusData = await statusRes.json();
    agentsData = {};
    if (statusData.agents) {
      statusData.agents.forEach(a => { 
        agentsData[a.name] = a; 
        // Store task/model in agentSessionModels for activity log
        if (a.currentModel) {
          agentSessionModels[a.name] = a.currentModel;
        }
      });
    }
    try { modelStatsData = await modelRes.json(); } catch(e) { modelStatsData = {}; }
  } catch (err) {
    console.error('Error fetching status board data:', err);
  }
}

// Initial fetch
fetchStatusBoardData();

pollStatus(); // Fetch real status immediately on load

// ===== GAME LOOP =====
let lastTime = 0;
function gameLoop(timestamp) {
  console.log('gameLoop running'); // DEBUG
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  // Update
  entities.forEach(e => e.update(dt));
  companions.forEach(c => c.update(dt));

  // Poll timer
  pollTimer += dt * 1000;
  if (pollTimer >= POLL_INTERVAL) { pollStatus(); fetchStatusBoardData(); pollTimer = 0; }

  // Draw - sort by Y for proper depth (lower Y = behind)
  renderBackground();
  const sortedEntities = [...entities].sort((a, b) => a.y - b.y);
  sortedEntities.forEach(e => e.draw(ctx));
  companions.forEach(c => c.draw(ctx));
  // Note: drawQuartersOverlay removed - agents should only appear at their current positions, not duplicated in quarters
  
  if (modalOpen) {
    drawModalOverlay();
  } else {
    drawStatusBar();
  }
  
  // Draw quarter item hover tooltip (above modals but below confirm/add)
  drawQuarterItemTooltip(ctx);

  // Draw confirmation modal on top of everything
  drawConfirmModal();

  // Draw add task modal on top of everything
  drawAddTaskModal();

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

// Error logging for debugging
window.addEventListener('error', (e) => {
  console.error('Global error:', e.message, e.filename, e.lineno);
});
</script>
</body>
</html>
