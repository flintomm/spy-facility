<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=4.0, user-scalable=yes">
<title>87 Highland Lane â€” Secure Ops Center</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #05080D;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'JetBrains Mono', monospace;
    overflow-x: hidden;
    overflow-y: auto;
    touch-action: manipulation;
    padding: 0;
  }
  .facility-shell {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 12px;
    width: min(860px, 100%);
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.06);
    background: rgba(5, 8, 13, 0.92);
    box-shadow: 0 30px 80px rgba(0, 0, 0, 0.55);
  }
  #canvas-viewport {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    width: 100%;
    touch-action: pan-x pan-y pinch-zoom;
  }
  canvas {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    display: block;
    width: auto;
    height: auto;
    transform-origin: top left;
  }
  .mobile-toolbar {
    display: none;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 8px 12px;
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(10, 14, 20, 0.9);
    color: #C0C8D4;
  }
  .zoom-controls {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #zoom-reset {
    font-weight: 600;
  }
  .toolbar-btn {
    background: #0A0E14;
    border: 1px solid rgba(255, 255, 255, 0.18);
    color: #C0C8D4;
    font-size: 10px;
    letter-spacing: 0.08em;
    padding: 6px 10px;
    border-radius: 8px;
    text-transform: uppercase;
    cursor: pointer;
  }
  .toolbar-btn:hover,
  .toolbar-btn:focus-visible {
    border-color: #00CC66;
    color: #00CC66;
  }
  #zoom-readout {
    font-size: 11px;
    color: #5A6A7A;
    min-width: 48px;
    text-align: center;
  }
  @media (max-width: 720px) {
    body {
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 18px 12px 32px;
    }
    .facility-shell {
      width: 100%;
      max-width: 100%;
      gap: 10px;
    }
    #canvas-viewport {
      max-height: calc(100vh - 150px);
      overflow: auto;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .mobile-toolbar {
      display: flex;
      position: sticky;
      top: 0;
      z-index: 5;
      backdrop-filter: blur(10px);
    }
  }
</style>
</head>
<body>
<div class="facility-shell">
  <div class="mobile-toolbar">
    <button class="toolbar-btn" data-jump="map">MAP</button>
    <div class="zoom-controls">
      <button class="toolbar-btn" data-zoom="out" aria-label="Zoom out">âˆ’</button>
      <span id="zoom-readout">100%</span>
      <button class="toolbar-btn" data-zoom="in" aria-label="Zoom in">+</button>
      <button class="toolbar-btn" id="zoom-reset" aria-label="Reset zoom">RESET</button>
    </div>
    <button class="toolbar-btn" data-jump="status">STATUS</button>
  </div>
  <div id="canvas-viewport">
    <canvas id="game"></canvas>
  </div>
</div>
<script>
// ============================================================
//  87 HIGHLAND LANE â€” SECURE OPS CENTER
//  Retro pixel-art spy facility for AI agent visualization
// ============================================================

const canvas = document.getElementById('game');
const canvasViewport = document.getElementById('canvas-viewport');
const zoomReadout = document.getElementById('zoom-readout');
const zoomResetBtn = document.getElementById('zoom-reset');
const ctx = canvas.getContext('2d');
const TARGET_WIDTH = 800;
const TARGET_HEIGHT = 1000;
canvas.width = TARGET_WIDTH;
canvas.height = TARGET_HEIGHT;
ctx.imageSmoothingEnabled = false;

const zoomButtons = document.querySelectorAll('[data-zoom]');
const jumpButtons = document.querySelectorAll('[data-jump]');
const displayModeMedia = window.matchMedia('(display-mode: standalone)');
let baseScale = 1;
let userZoom = 1;
const MIN_ZOOM = 0.55;
const MAX_ZOOM = 1.6;
let lastTapTime = 0;
let lastTapPos = null;
let pinchActive = false;
let pinchStartDistance = 0;
let pinchStartZoom = 1;
let standaloneMode = displayModeMedia.matches || !!window.navigator.standalone || !!document.fullscreenElement;
const TAP_SLOP = 8;

let tapCandidate = false;
let tapCanvasPos = null;
let tapZone = null;
let panGestureEnabled = false;
let panActive = false;
let panStartClient = null;
let panStartScroll = null;

function updateStandaloneMode() {
  standaloneMode = displayModeMedia.matches || !!window.navigator.standalone || !!document.fullscreenElement;
  if (canvasViewport) {
    canvasViewport.style.touchAction = standaloneMode ? 'none' : 'pan-x pan-y pinch-zoom';
  }
}

function clampZoom(value) {
  return Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, value));
}

function applyZoom(options = {}) {
  const totalScale = baseScale * userZoom;
  canvas.style.width = Math.floor(TARGET_WIDTH * totalScale) + 'px';
  canvas.style.height = Math.floor(TARGET_HEIGHT * totalScale) + 'px';
  if (zoomReadout) {
    zoomReadout.textContent = Math.round(userZoom * 100) + '%';
  }
  if (canvasViewport) {
    const allowScroll = userZoom > 1.02;
    if (allowScroll) {
      canvasViewport.style.overflow = 'auto';
    } else if (window.innerWidth > 720) {
      canvasViewport.style.overflow = 'hidden';
      if (options.resetScroll !== false) {
        canvasViewport.scrollTop = 0;
        canvasViewport.scrollLeft = 0;
      }
    } else {
      canvasViewport.style.overflow = 'auto';
      if (options.resetScroll !== false) {
        canvasViewport.scrollTop = 0;
        canvasViewport.scrollLeft = 0;
      }
    }
  }
}

function updateCanvasScale() {
  const windowWidth = window.innerWidth;
  const windowHeight = window.innerHeight;
  const scaleX = windowWidth / TARGET_WIDTH;
  const scaleY = windowHeight / TARGET_HEIGHT;
  baseScale = Math.min(scaleX, scaleY, 1);
  applyZoom({ resetScroll: false });
}

updateStandaloneMode();
updateCanvasScale();
window.addEventListener('resize', () => {
  updateStandaloneMode();
  updateCanvasScale();
});
if (displayModeMedia.addEventListener) {
  displayModeMedia.addEventListener('change', updateStandaloneMode);
} else if (displayModeMedia.addListener) {
  displayModeMedia.addListener(updateStandaloneMode);
}
document.addEventListener('fullscreenchange', updateStandaloneMode);
document.addEventListener('visibilitychange', updateStandaloneMode);

zoomButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    const dir = btn.dataset.zoom;
    const delta = dir === 'in' ? 0.15 : -0.15;
    userZoom = clampZoom(userZoom + delta);
    applyZoom({ resetScroll: userZoom <= 1.01 });
  });
});

if (zoomResetBtn) {
  zoomResetBtn.addEventListener('click', () => {
    userZoom = 1;
    applyZoom({ resetScroll: true });
  });
}

function jumpToSection(section) {
  if (!canvasViewport) return;
  const behavior = 'smooth';
  if (section === 'map') {
    canvasViewport.scrollTo({ top: 0, behavior });
  } else if (section === 'status') {
    const maxScroll = canvasViewport.scrollHeight - canvasViewport.clientHeight;
    canvasViewport.scrollTo({ top: Math.max(maxScroll, 0), behavior });
  }
}

jumpButtons.forEach(btn => {
  btn.addEventListener('click', () => jumpToSection(btn.dataset.jump));
});


function detectDoubleTap(x, y) {
  if (window.innerWidth > 720) return;
  if (y >= BAR_Y - 12) {
    lastTapTime = 0;
    lastTapPos = null;
    return;
  }
  const now = Date.now();
  const isClose = lastTapPos ? Math.hypot(lastTapPos.x - x, lastTapPos.y - y) < 25 : false;
  if (now - lastTapTime < 280 && isClose) {
    userZoom = userZoom > 1.05 ? 1 : 1.35;
    applyZoom({ resetScroll: userZoom <= 1.01 });
    lastTapTime = 0;
    lastTapPos = null;
  } else {
    lastTapTime = now;
    lastTapPos = { x, y };
  }
}

function distanceBetweenTouches(touches) {
  if (touches.length < 2) return 1;
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy) || 1;
}

function clampScrollValue(value, max) {
  if (max <= 0) return 0;
  return Math.min(Math.max(value, 0), max);
}

function resetTouchInteraction() {
  tapCandidate = false;
  tapCanvasPos = null;
  tapZone = null;
  panGestureEnabled = false;
  panActive = false;
  panStartClient = null;
  panStartScroll = null;
}

// ===== CANVAS CLICK HANDLING FOR MOBILE STATUS BAR =====
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const mouseX = (e.clientX - rect.left) * scaleX;
  const mouseY = (e.clientY - rect.top) * scaleY;
  handleStatusBarClick(mouseX, mouseY);
});

// Touch support for mobile
canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length >= 2) {
    resetTouchInteraction();
    pinchActive = true;
    pinchStartDistance = distanceBetweenTouches(e.touches);
    pinchStartZoom = userZoom;
    e.preventDefault();
    return;
  }

  const touch = e.touches[0];
  if (!touch) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const canvasX = (touch.clientX - rect.left) * scaleX;
  const canvasY = (touch.clientY - rect.top) * scaleY;

  tapZone = canvasY >= BAR_Y ? 'status' : 'map';
  tapCanvasPos = { x: canvasX, y: canvasY };
  tapCandidate = true;
  panActive = false;
  panGestureEnabled = standaloneMode || userZoom > 1.02;
  panStartClient = { x: touch.clientX, y: touch.clientY };
  panStartScroll = canvasViewport ? { left: canvasViewport.scrollLeft, top: canvasViewport.scrollTop } : { left: 0, top: 0 };

  if (panGestureEnabled) {
    e.preventDefault();
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  if (pinchActive && e.touches.length === 2) {
    e.preventDefault();
    const distance = distanceBetweenTouches(e.touches);
    if (distance > 0 && pinchStartDistance > 0) {
      const scale = distance / pinchStartDistance;
      userZoom = clampZoom(pinchStartZoom * scale);
      applyZoom({ resetScroll: false });
    }
    return;
  }

  if (e.touches.length !== 1 || !panStartClient) return;
  const touch = e.touches[0];
  const dx = touch.clientX - panStartClient.x;
  const dy = touch.clientY - panStartClient.y;

  if (!panActive && Math.hypot(dx, dy) > TAP_SLOP) {
    panActive = true;
    tapCandidate = false;
  }

  if (!panGestureEnabled || !panActive || !canvasViewport) return;

  e.preventDefault();
  const maxLeft = canvasViewport.scrollWidth - canvasViewport.clientWidth;
  const maxTop = canvasViewport.scrollHeight - canvasViewport.clientHeight;
  canvasViewport.scrollLeft = clampScrollValue(panStartScroll.left - dx, maxLeft);
  canvasViewport.scrollTop = clampScrollValue(panStartScroll.top - dy, maxTop);
}, { passive: false });

function endPinchIfNeeded(e) {
  if (pinchActive && e.touches.length < 2) {
    pinchActive = false;
    pinchStartDistance = 0;
  }
}

canvas.addEventListener('touchend', (e) => {
  const wasPinch = pinchActive;
  endPinchIfNeeded(e);
  if (wasPinch) {
    resetTouchInteraction();
    return;
  }

  if (!tapCandidate || panActive || !tapCanvasPos) {
    resetTouchInteraction();
    return;
  }

  if (tapZone === 'status') {
    handleStatusBarClick(tapCanvasPos.x, tapCanvasPos.y);
  } else {
    detectDoubleTap(tapCanvasPos.x, tapCanvasPos.y);
  }
  resetTouchInteraction();
}, { passive: false });

canvas.addEventListener('touchcancel', (e) => {
  endPinchIfNeeded(e);
  resetTouchInteraction();
}, { passive: false });

// Keyboard input for add task modal
window.addEventListener('keydown', (e) => {
  if (!addTaskModal.active) return;

  // Handle Enter key to submit
  if (e.key === 'Enter') {
    if (addTaskModal.taskText.trim()) {
      addTaskModal.active = false;
      if (addTaskModal.onSubmit) {
        addTaskModal.onSubmit(addTaskModal.taskText.trim(), addTaskModal.selectedAssignee);
      }
    }
    e.preventDefault();
    return;
  }

  // Handle Escape key to cancel
  if (e.key === 'Escape') {
    addTaskModal.active = false;
    if (addTaskModal.onCancel) addTaskModal.onCancel();
    e.preventDefault();
    return;
  }

  // Handle backspace
  if (e.key === 'Backspace') {
    addTaskModal.taskText = addTaskModal.taskText.slice(0, -1);
    e.preventDefault();
    return;
  }

  // Handle regular character input (single characters only, not modifiers)
  if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
    if (addTaskModal.taskText.length < 50) {
      addTaskModal.taskText += e.key;
    }
    e.preventDefault();
    return;
  }
});

const POLL_INTERVAL = 5000; // 5 seconds

// ===== PALETTE =====
const C = {
  bg:'#0D1117',
  floor1:'#7A5C28', floor2:'#8B6914', floor3:'#6B4F1A', floorLine:'#5A4210', floorDark:'#4A3808',
  wall:'#1A2030', wallTop:'#222E3E', wallTrim:'#2E3A4E', wallInner:'#151D2A', wallAccent:'#3A4A5E',
  desk:'#4A3728', deskTop:'#5C4A38', deskLeg:'#3A2A1C',
  monitor:'#0A1020', monScreen:'#003060', monGlow:'#0055AA', monBright:'#0088DD',
  chair:'#2A2A35', chairSeat:'#35354A',
  green:'#00CC66', red:'#CC3333', amber:'#FFAA00',
  // Flint
  fHair:'#2A1808', fSkin:'#D4A574', fSkinS:'#C09060', fEye:'#1A1A2E',
  fJacket:'#2A3A5C', fJacketD:'#1E2E4A', fAccent:'#FF8C00',
  fPants:'#2A2A38', fBoots:'#1A1A20', fBelt:'#3A3A2A',
  // Cipher (cyan)
  cHair:'#1A1A2A', cSkin:'#D4A574', cSkinS:'#C09060', cEye:'#1A1A2E',
  cJacket:'#1E3A4A', cJacketD:'#152A3A', cAccent:'#00D4FF',
  cPants:'#2A2A38', cBoots:'#1A1A20', cBelt:'#2A3A4A',
  // Lucky
  lW:'#F0E8D8', lB:'#2A2018', lBr:'#8B6F4E', lNose:'#1A1410', lTongue:'#E87070',
  // Furniture
  couch:'#3A2A40', couchL:'#4A3A50', couchD:'#2A1A30',
  shelf:'#3A3040', book1:'#8B2020', book2:'#204080', book3:'#206020', book4:'#806020',
  fridge:'#B0B8C0', fridgeD:'#8090A0',
  coffee:'#2A2A2A', coffeePot:'#604020',
  cabinet:'#5C4A38', cabinetD:'#4A3828',
  wb:'#E0E0D8', wbBorder:'#707070',
  pingpong:'#206030', ppNet:'#D0D0D0', ppLeg:'#5A5A5A',
  cooler:'#8098A8', coolerJug:'#A0C8D8',
  bean1:'#7A2828', bean2:'#28487A',
  plant:'#2E7D32', plantL:'#4CAF50', plantD:'#1B5E20', pot:'#795548', potD:'#5D4037',
  radio:'#3A3A3A', radioAnt:'#808080', radioLight:'#CC3333',
  clipboard:'#C8B890', clipMetal:'#A0A0A0', clipText:'#6A6040',
  // UI
  hdrBg:'#080C12', hdrText:'#00CC66', hdrDim:'#005530', hdrBorder:'#1A2A1A',
  barBg:'#0A0E14', barBorder:'#1E2A3A', barText:'#C0C8D4', barDim:'#5A6A7A',
  namePlate:'#1A1A20', namePlateText:'#C0C8D4',
  tile:'#182028',
};

// ===== LAYOUT =====
const HDR_H = 30;
const ROOM_Y = 40;
const ROOM_H = 160;
const ROOM_GAP = 20;
const POD_Y = 380, POD_W = 172, POD_H = 142, POD_GAP = 20;
const LOUNGE_X = 10, LOUNGE_W = 780;
const LOUNGE_Y = 540, LOUNGE_H = 200;

// Floor 2 (Quarters) â€” below ops floor
const FLOOR_SEP_Y = 760;
const FLOOR2_Y = 790;
const BAR_H = 140;
const BAR_Y = TARGET_HEIGHT - BAR_H;

// Newspaper spot for Lucky's heartbeat run
const NEWSPAPER_SPOT = { x: LOUNGE_X + LOUNGE_W - 140, y: LOUNGE_Y + LOUNGE_H - 30 };

// Heartbeat detection
let heartbeatRecent = false;
let lastHeartbeatProcessedAt = 0;

// Meeting state with location
let meetingActive = false;
let meetingLocation = 'galley'; // 'galley' | 'briefing' | 'command'

// Status board tabs
let statusTab = 'agents'; // 'agents' | 'todos' | 'activity'
let modalOpen = false; // Modal overlay state

// Confirmation modal state
let confirmModal = {
  active: false,
  text: '',
  onYes: null,
  onNo: null
};

// Add Task modal state
let addTaskModal = {
  active: false,
  taskText: '',
  selectedAssignee: '',
  agents: ['Flint', 'Cipher', 'Atlas'],
  onSubmit: null,
  onCancel: null,
  inputPos: { x: 0, y: 0, width: 0, height: 0 },
  dropdownPos: { x: 0, y: 0, width: 0, height: 0 },
  yesPos: { x: 0, y: 0, width: 0, height: 0 },
  noPos: { x: 0, y: 0, width: 0, height: 0 }
};

const ROOM_LAYOUT = [
  { name:'R&D LAB', x:40, y:ROOM_Y, w:360, h:ROOM_H },
  { name:'COMMAND', x:420, y:ROOM_Y, w:340, h:ROOM_H },
  { name:'GALLEY',  x:40, y:ROOM_Y + ROOM_H + ROOM_GAP, w:360, h:ROOM_H },
  { name:'BRIEFING', x:420, y:ROOM_Y + ROOM_H + ROOM_GAP, w:340, h:ROOM_H }
];

const ROOMS = ROOM_LAYOUT.map(room => ({
  ...room,
  doorW: 46,
  doorX: room.x + (room.w - 46) / 2
}));

function podPos(col) {
  return {
    x: 40 + col * (POD_W + POD_GAP),
    y: POD_Y,
    w: POD_W, h: POD_H
  };
}

const PODS = [];
for (let c = 0; c < 4; c++) PODS.push(podPos(c));

const QUARTER_Y = FLOOR2_Y;
const QUARTER_H = 150;
const QUARTER_W = 230;
const QUARTER_GAP = 18;
const QUARTERS = [
  { agent: 'Flint', label: "FLINT'S QUARTERS", x: 20, y: QUARTER_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 72, y: QUARTER_Y + 60 } },
  { agent: 'Cipher', label: "CIPHER'S QUARTERS", x: 20 + (QUARTER_W + QUARTER_GAP), y: QUARTER_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 20 + (QUARTER_W + QUARTER_GAP) + 140, y: QUARTER_Y + 58 } },
  { agent: 'Atlas', label: "ATLAS' QUARTERS", x: 20 + 2 * (QUARTER_W + QUARTER_GAP), y: QUARTER_Y, w: QUARTER_W, h: QUARTER_H, spritePos: { x: 20 + 2 * (QUARTER_W + QUARTER_GAP) + 60, y: QUARTER_Y + 62 } }
];

// ===== SCALABLE MEETING LOCATIONS =====
const MEETING_LOCATIONS = {
  galley: {
    positions: [
      { x: 120, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 160, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 200, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 240, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 140, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
      { x: 280, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
    ]
  },
  briefing: {
    positions: [
      { x: 500, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 540, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
      { x: 580, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 620, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 },
      { x: 520, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
      { x: 660, y: ROOM_Y + ROOM_H + ROOM_GAP + 120 },
    ]
  },
  command: {
    positions: [
      { x: ROOMS[1].x + 60, y: ROOMS[1].y + 40 },
      { x: ROOMS[1].x + 100, y: ROOMS[1].y + 50 },
      { x: ROOMS[1].x + 80, y: ROOMS[1].y + 80 },
      { x: ROOMS[1].x + 140, y: ROOMS[1].y + 70 },
      { x: ROOMS[1].x + 40, y: ROOMS[1].y + 100 },
      { x: ROOMS[1].x + 180, y: ROOMS[1].y + 60 },
    ]
  },
  lounge: {
    positions: [
      { x: LOUNGE_X + 60, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 150, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 240, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 330, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 420, y: LOUNGE_Y + 80 },
      { x: LOUNGE_X + 510, y: LOUNGE_Y + 80 },
    ]
  }
};

// Legacy support - individual named positions for galley
const GALLEY_POSITIONS = {
  'Flint': { x: 120, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
  'Cipher': { x: 160, y: ROOM_Y + ROOM_H + ROOM_GAP + 80 },
  'Lucky': { x: 200, y: ROOM_Y + ROOM_H + ROOM_GAP + 100 }
};

// Desk center positions (where agents sit)
function deskCenter(pod) { return { x: pod.x + pod.w/2, y: pod.y + 52 }; }

// ===== AGENTS CONFIG =====
const AGENTS = [
  {
    name:'Flint', role:'Lead', color:'#FF8C00', podIndex:0,
    deskItems:['radio','clipboard'],
    companion:{ name:'Lucky', type:'boston_terrier' },
    status:'idle',
    level:5, exp:1125, nextLevel:1500, expProgress:0.75
  },
  {
    name:'Cipher', role:'Coder', color:'#00D4FF', podIndex:1,
    deskItems:['rubberDuck','energyDrink'],
    companion:null,
    status:'idle',
    level:2, exp:500, nextLevel:750, expProgress:0.66
  },
  {
    name:'Atlas', role:'Tech Director', color:'#3366CC', podIndex:3,
    deskItems:[],
    companion:null,
    status:'idle',
    level:1, exp:25, nextLevel:500, expProgress:0.05
  }
];

// ===== OFFSCREEN BG =====

// ===== DRAWING HELPERS =====
function rect(c, x, y, w, h, col) { c.fillStyle = col; c.fillRect(x|0, y|0, w|0, h|0); }
function strokeRect(c, x, y, w, h, col, lw) {
  c.strokeStyle = col; c.lineWidth = lw||1;
  c.strokeRect((x|0)+0.5, (y|0)+0.5, w|0, h|0);
}

function drawExpBar(ctx, x, y, width, height, progress, color, isMaxLevel) {
  // Clamp progress to 0-1 range
  progress = Math.max(0, Math.min(1, progress));

  // Background
  rect(ctx, x, y, width, height, '#1A1A20');

  // Border
  strokeRect(ctx, x, y, width, height, '#2A2A2A', 1);

  // Fill based on progress
  const fillWidth = (width - 2) * progress; // -2 for border padding
  if (fillWidth > 0) {
    // Use gold color for max level, otherwise use agent color
    const fillColor = isMaxLevel ? '#FFAA00' : color;
    rect(ctx, x + 1, y + 1, fillWidth, height - 2, fillColor);
  }
}

function drawLevelBadge(ctx, x, y, level, color) {
  // Format: "Lv.{level}"
  const text = `Lv.${level}`;

  // Font setup
  ctx.font = '9px "JetBrains Mono"';
  const textMetrics = ctx.measureText(text);
  const textWidth = textMetrics.width;
  const paddingX = 6;
  const paddingY = 2;
  const badgeWidth = textWidth + paddingX * 2;
  const badgeHeight = 12;

  // Create dark tint of agent color for background
  // Parse hex color and darken it
  const darkColor = darkenColor(color, 0.4);

  // Draw pill background
  ctx.fillStyle = darkColor;
  ctx.beginPath();
  const radius = badgeHeight / 2;
  ctx.roundRect(x, y, badgeWidth, badgeHeight, radius);
  ctx.fill();

  // Draw text centered
  ctx.fillStyle = color;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, x + paddingX, y + badgeHeight / 2 + 0.5);

  // Return badge width for positioning
  return badgeWidth;
}

// Helper to darken a hex color
function darkenColor(color, factor) {
  // Handle hex colors
  if (color.startsWith('#')) {
    let hex = color.slice(1);
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);

    const newR = Math.floor(r * factor);
    const newG = Math.floor(g * factor);
    const newB = Math.floor(b * factor);

    return `rgb(${newR}, ${newG}, ${newB})`;
  }
  return color;
}

// ===== DRAW WOOD FLOOR =====
function drawFloor(c, x, y, w, h) {
  const colors = [C.floor1, C.floor2, C.floor3, C.floor2, C.floor1, C.floor3];
  const plankH = 10;
  for (let py = y; py < y + h; py += plankH) {
    const ci = ((py / plankH) | 0) % colors.length;
    rect(c, x, py, w, Math.min(plankH, y+h-py), colors[ci]);
    rect(c, x, py, w, 1, C.floorLine);
    // Plank joints
    const offset = ((py / plankH) | 0) % 2 === 0 ? 0 : 60;
    for (let px = x + offset; px < x + w; px += 120) {
      rect(c, px, py, 1, Math.min(plankH, y+h-py), C.floorLine);
    }
  }
}

// ===== DRAW WALLS =====
function drawWalls(c, room) {
  const { x, y, w, h, doorX, doorW } = room;
  const t = 5; // wall thickness
  // Floor first
  drawFloor(c, x+t, y+t, w-t*2, h-t*2);
  // Walls
  rect(c, x, y, w, t, C.wallTop);       // top
  rect(c, x, y, t, h, C.wall);          // left
  rect(c, x+w-t, y, t, h, C.wall);      // right
  // Bottom wall with door
  rect(c, x, y+h-t, doorX - x, t, C.wallTop);
  rect(c, doorX + doorW, y+h-t, (x+w) - (doorX+doorW), t, C.wallTop);
  // Trim line
  rect(c, x, y+t, w, 1, C.wallTrim);
  // Room label
  c.fillStyle = C.wallAccent;
  c.font = '8px "JetBrains Mono"';
  c.fillText(room.name, x + 10, y + 14);
}

// ===== FURNITURE DRAWING =====
function drawDesk(c, x, y, w, h) {
  rect(c, x, y, w, h, C.deskTop);
  rect(c, x, y+h, w, 2, C.desk);
  // Legs
  rect(c, x+2, y+h, 3, 8, C.deskLeg);
  rect(c, x+w-5, y+h, 3, 8, C.deskLeg);
}

function drawMonitor(c, x, y, on) {
  rect(c, x, y, 30, 24, C.monitor);
  rect(c, x+2, y+2, 26, 18, on ? C.monScreen : '#0A0A15');
  if (on) {
    // Scan lines
    for (let i = 0; i < 18; i += 3) {
      rect(c, x+2, y+2+i, 26, 1, C.monGlow);
    }
    // Text cursor blink
    rect(c, x+6, y+12, 8, 2, C.monBright);
  }
  // Stand
  rect(c, x+12, y+24, 6, 4, C.monitor);
  rect(c, x+8, y+27, 14, 2, C.monitor);
}

function drawChair(c, x, y) {
  rect(c, x, y, 18, 4, C.chairSeat);
  rect(c, x+2, y-10, 14, 10, C.chair);
  rect(c, x+1, y+4, 3, 6, C.chair);
  rect(c, x+14, y+4, 3, 6, C.chair);
}

function drawNamePlate(c, x, y, name, status) {
  rect(c, x, y, 60, 12, C.namePlate);
  rect(c, x+2, y+2, 6, 8, status === 'working' ? C.green : C.red);
  c.fillStyle = C.namePlateText;
  c.font = '7px "JetBrains Mono"';
  c.fillText(name, x + 12, y + 9);
}

function drawRadio(c, x, y) {
  rect(c, x, y, 14, 10, C.radio);
  rect(c, x+2, y+2, 10, 5, '#2A2A2A');
  rect(c, x+5, y+1, 1, -8, C.radioAnt);
  rect(c, x+5, y-8, 3, 2, C.radioAnt);
  rect(c, x+10, y+3, 2, 2, C.radioLight);
}

function drawClipboard(c, x, y) {
  rect(c, x, y, 12, 16, C.clipboard);
  rect(c, x+3, y-2, 6, 3, C.clipMetal);
  // Text lines
  for (let i = 0; i < 4; i++) {
    rect(c, x+2, y+4+i*3, 8, 1, C.clipText);
  }
}

function drawRubberDuck(c, x, y) {
  // Duck body (yellow)
  rect(c, x+2, y+6, 10, 6, '#FFD700');
  rect(c, x+4, y+4, 6, 2, '#FFD700');
  // Head
  rect(c, x+8, y+2, 6, 5, '#FFD700');
  // Beak (orange)
  rect(c, x+13, y+3, 3, 2, '#FF8C00');
  // Eye
  rect(c, x+10, y+3, 1, 1, '#1A1A2E');
  // Wing
  rect(c, x+4, y+8, 4, 3, '#FFC800');
}

function drawEnergyDrink(c, x, y) {
  // Can body (silver with cyan accent)
  rect(c, x+2, y+2, 8, 14, '#C0C0C0');
  rect(c, x+2, y+4, 8, 10, '#00D4FF');
  // Rim
  rect(c, x+2, y, 8, 2, '#A0A0A0');
  // Lightning bolt
  rect(c, x+4, y+6, 2, 4, '#FFFFFF');
  rect(c, x+5, y+7, 2, 3, '#FFFFFF');
}

function drawWorkbench(c, x, y) {
  drawDesk(c, x, y, 100, 20);
  // Tools
  rect(c, x+10, y+2, 16, 3, '#808080'); // wrench
  rect(c, x+30, y+3, 12, 2, '#A0A0A0'); // screwdriver
  rect(c, x+50, y+1, 8, 8, '#505060');  // multimeter
  rect(c, x+52, y+3, 4, 4, '#003030');
  rect(c, x+70, y+2, 6, 6, '#404050');  // component
  rect(c, x+80, y+4, 14, 3, '#606070'); // pliers
}

function drawOscilloscope(c, x, y) {
  rect(c, x, y, 30, 24, '#303040');
  rect(c, x+3, y+3, 24, 14, '#001810');
  // Wave
  for (let i = 0; i < 20; i += 2) {
    const wy = y + 10 + Math.sin(i * 0.8) * 4;
    rect(c, x+5+i, wy|0, 2, 1, '#00FF80');
  }
  // Knobs
  rect(c, x+6, y+19, 4, 4, '#505060');
  rect(c, x+14, y+19, 4, 4, '#505060');
  rect(c, x+22, y+19, 4, 4, '#505060');
}

function drawShelf(c, x, y, w) {
  rect(c, x, y, w, 50, C.shelf);
  // Books
  const books = [C.book1,C.book2,C.book3,C.book4,C.book1,C.book2,C.book3];
  let bx = x + 3;
  for (const bc of books) {
    const bw = 4 + Math.random()*4|0;
    if (bx + bw > x + w - 3) break;
    rect(c, bx, y+3, bw, 20, bc);
    bx += bw + 2;
  }
  rect(c, x, y+25, w, 2, C.wallTrim);
  // Lower shelf books
  bx = x + 3;
  for (let i = 0; i < 5; i++) {
    const bw = 5 + Math.random()*3|0;
    rect(c, bx, y+28, bw, 18, [C.book3,C.book4,C.book1,C.book2,C.book3][i]);
    bx += bw + 2;
  }
}

function drawCouch(c, x, y, w) {
  rect(c, x, y+6, w, 18, C.couch);
  rect(c, x+2, y+8, w-4, 12, C.couchL);
  rect(c, x, y, 6, 24, C.couchD); // arm
  rect(c, x+w-6, y, 6, 24, C.couchD); // arm
  rect(c, x, y-4, w, 6, C.couch); // back
  // Cushion lines
  rect(c, x+w/3|0, y+8, 1, 12, C.couchD);
  rect(c, x+(w*2/3)|0, y+8, 1, 12, C.couchD);
}

function drawFridge(c, x, y) {
  rect(c, x, y, 24, 50, C.fridge);
  rect(c, x, y, 24, 2, C.fridgeD);
  rect(c, x, y+28, 24, 2, C.fridgeD);
  rect(c, x+20, y+8, 2, 16, C.fridgeD);
  rect(c, x+20, y+34, 2, 12, C.fridgeD);
}

function drawCoffeeMachine(c, x, y) {
  rect(c, x, y, 16, 20, C.coffee);
  rect(c, x+2, y+2, 12, 8, '#1A1A1A');
  rect(c, x+4, y+12, 8, 6, C.coffeePot);
  rect(c, x+12, y+4, 3, 3, C.red); // light
}

function drawCabinet(c, x, y, w) {
  rect(c, x, y, w, 30, C.cabinet);
  rect(c, x, y, w, 2, C.cabinetD);
  // Doors
  const dw = (w-6)/3;
  for (let i = 0; i < 3; i++) {
    const dx = x+3+i*(dw+1);
    rect(c, dx, y+4, dw-1, 22, C.cabinetD);
    rect(c, dx+dw/2-1|0, y+14, 2, 4, '#808080');
  }
}

function drawWhiteboard(c, x, y) {
  rect(c, x, y, 80, 50, C.wbBorder);
  rect(c, x+3, y+3, 74, 44, C.wb);
  // Scribbles
  for (let i = 0; i < 5; i++) {
    rect(c, x+8+i*12, y+10+i*6, 20, 1, '#4040A0');
  }
  rect(c, x+10, y+20, 30, 15, 'rgba(200,60,60,0.3)');
  // Marker tray
  rect(c, x+10, y+50, 60, 4, C.wbBorder);
  rect(c, x+15, y+49, 6, 3, '#CC3333');
  rect(c, x+24, y+49, 6, 3, '#3333CC');
  rect(c, x+33, y+49, 6, 3, '#33CC33');
}

function drawPingPong(c, x, y) {
  // Table
  rect(c, x, y, 70, 36, C.pingpong);
  rect(c, x, y, 70, 2, '#184828');
  rect(c, x, y+34, 70, 2, '#184828');
  rect(c, x, y, 2, 36, '#184828');
  rect(c, x+68, y, 2, 36, '#184828');
  // Center line
  rect(c, x+34, y, 2, 36, C.ppNet);
  // Legs
  rect(c, x+5, y+36, 4, 10, C.ppLeg);
  rect(c, x+61, y+36, 4, 10, C.ppLeg);
}

function drawWaterCooler(c, x, y) {
  rect(c, x, y+14, 14, 26, C.cooler);
  rect(c, x+1, y, 12, 16, C.coolerJug);
  rect(c, x+4, y+2, 6, 10, '#C0E0F0');
  rect(c, x+6, y+30, 2, 4, '#606060');
  // Cup
  rect(c, x+16, y+34, 5, 5, '#E0E0E0');
}

function drawBeanBag(c, x, y, col) {
  // Oval-ish shape
  rect(c, x+2, y, 16, 4, col);
  rect(c, x, y+4, 20, 10, col);
  rect(c, x+2, y+14, 16, 4, col);
}

function drawPlant(c, x, y, size) {
  const s = size || 1;
  // Pot
  rect(c, x+2*s, y+10*s, 8*s, 8*s, C.pot);
  rect(c, x+1*s, y+10*s, 10*s, 2*s, C.potD);
  rect(c, x+3*s, y+18*s, 6*s, 2*s, C.potD);
  // Leaves
  rect(c, x+4*s, y+4*s, 4*s, 6*s, C.plant);
  rect(c, x+1*s, y+2*s, 3*s, 5*s, C.plantL);
  rect(c, x+8*s, y+3*s, 3*s, 4*s, C.plantL);
  rect(c, x+5*s, y, 2*s, 4*s, C.plantD);
}

function drawBed(c, x, y, width = 90, orientation = 'left') {
  const height = 36;
  rect(c, x, y, width, height, '#1A1F2A');
  rect(c, x+4, y+4, width-8, height-12, '#2A3140');
  rect(c, x+6, y+height-14, width-12, 10, '#0F141E');
  const pillowW = 26;
  if (orientation === 'left') {
    rect(c, x+6, y+6, pillowW, 12, '#C9CED6');
  } else {
    rect(c, x+width-pillowW-6, y+6, pillowW, 12, '#C9CED6');
  }
}

function drawDogBed(c, x, y) {
  rect(c, x, y, 36, 8, '#4A2A1A');
  rect(c, x+3, y-10, 30, 10, '#C08958');
  rect(c, x+8, y-6, 20, 6, '#F0E3C2');
}

function drawServerRack(c, x, y) {
  rect(c, x, y, 22, 44, '#101822');
  for (let i = 0; i < 5; i++) {
    rect(c, x+3, y+6+i*8, 16, 3, i%2 === 0 ? '#00D4FF' : '#FF5F82');
  }
  rect(c, x+6, y+34, 10, 2, '#00FFB7');
}

function drawMiniFridge(c, x, y) {
  rect(c, x, y, 24, 32, '#3A4A64');
  rect(c, x+2, y+4, 20, 20, '#B0C4DA');
  rect(c, x+18, y+6, 3, 12, '#708090');
}

function drawBlueprintDesk(c, x, y) {
  rect(c, x, y, 78, 28, '#162033');
  rect(c, x+4, y+4, 70, 20, '#1B4A73');
  rect(c, x+10, y+8, 20, 10, '#6EC1FF');
  rect(c, x+38, y+6, 30, 4, '#C0D4EA');
  rect(c, x+46, y+16, 18, 3, '#5AA5FF');
}

function drawBookshelf(c, x, y, w) {
  rect(c, x, y, w, 36, '#2A1E28');
  for (let i = 0; i < 4; i++) {
    rect(c, x+4+i*12, y+6, 8, 18, ['#FF8C00','#00D4FF','#C04A7D','#8BD77A'][i%4]);
  }
}

function drawRug(c, x, y, w, h, color) {
  rect(c, x, y, w, h, color);
  strokeRect(c, x, y, w, h, 'rgba(0,0,0,0.2)');
}

// ===== POD DRAWING =====
function drawPod(c, pod, agent) {
  const { x, y, w, h } = pod;
  const t = 4;
  // Floor
  drawFloor(c, x+t, y+t, w-t*2, h-t*2);
  // Walls
  rect(c, x, y, w, t, C.wallTop);
  rect(c, x, y, t, h, C.wall);
  rect(c, x+w-t, y, t, h, C.wall);
  // Bottom wall with door
  const doorW = 40;
  const doorX = x + (w-doorW)/2;
  rect(c, x, y+h-t, doorX-x, t, C.wallTop);
  rect(c, doorX+doorW, y+h-t, (x+w)-(doorX+doorW), t, C.wallTop);
  // Desk
  drawDesk(c, x+22, y+16, w-44, 18);
  // Monitor
  drawMonitor(c, x+(w/2)-15|0, y+8, agent && agent.status === 'working');
  // Chair (when no agent sitting)
  if (!agent || agent.state !== 'working') {
    drawChair(c, x+(w/2)-9|0, y+58);
  }
  // Name plate
  if (agent) {
    drawNamePlate(c, x+56, y+6, agent.name, agent.status);
    // Desk items
    if (agent.deskItems) {
      if (agent.deskItems.includes('radio')) drawRadio(c, x+24, y+10);
      if (agent.deskItems.includes('clipboard')) drawClipboard(c, x+w-42, y+8);
      if (agent.deskItems.includes('rubberDuck')) drawRubberDuck(c, x+28, y+8);
      if (agent.deskItems.includes('energyDrink')) drawEnergyDrink(c, x+w-38, y+6);
    }
  } else {
    const vacX = x + 40;
    const vacY = y + 24;
    const vacW = w - 80;
    const vacH = 32;
    c.fillStyle = '#0F1520';
    c.beginPath();
    c.roundRect(vacX, vacY, vacW, vacH, 6);
    c.fill();
    strokeRect(c, vacX, vacY, vacW, vacH, '#1F2A38');
    c.fillStyle = '#3A9A5A';
    c.font = 'bold 10px "JetBrains Mono"';
    const vacLabel = 'VACANT';
    const vacLabelW = c.measureText(vacLabel).width;
    c.fillText(vacLabel, vacX + (vacW - vacLabelW) / 2, vacY + 18);
    c.fillStyle = '#5A6A7A';
    c.font = '7px "JetBrains Mono"';
    const vacSub = 'RECRUITING';
    const vacSubW = c.measureText(vacSub).width;
    c.fillText(vacSub, vacX + (vacW - vacSubW) / 2, vacY + 28);
  }
  // Pod number (dim)
  c.fillStyle = C.barDim;
  c.font = '7px "JetBrains Mono"';
  c.fillText('P'+(PODS.indexOf(pod)), x+8, y+h-8);
}

// ===== RENDER ROOMS =====
function renderRDLab(c) {
  const r = ROOMS[0];
  drawWalls(c, r);
  drawWorkbench(c, r.x+20, r.y+30);
  drawOscilloscope(c, r.x+140, r.y+24);
  drawShelf(c, r.x+180, r.y+12, 50);
  drawPlant(c, r.x+18, r.y+80, 1.5);
  // Parts bins
  rect(c, r.x+80, r.y+70, 40, 20, '#404050');
  rect(c, r.x+82, r.y+72, 16, 16, '#303040');
  rect(c, r.x+102, r.y+72, 16, 16, '#303040');
}

function renderCommand(c) {
  const r = ROOMS[1];
  drawWalls(c, r);
  // Big desk
  drawDesk(c, r.x+30, r.y+20, 100, 22);
  drawMonitor(c, r.x+60, r.y+10, true);
  drawChair(c, r.x+70, r.y+56);
  // Couch
  drawCouch(c, r.x+160, r.y+60, 70);
  // Shelf
  drawShelf(c, r.x+20, r.y+100, 80);
  drawPlant(c, r.x+200, r.y+100, 1.2);
}

function renderGalley(c) {
  const r = ROOMS[2];
  drawWalls(c, r);
  drawCabinet(c, r.x+15, r.y+14, 90);
  drawFridge(c, r.x+140, r.y+16);
  drawCoffeeMachine(c, r.x+180, r.y+30);
  // Counter
  rect(c, r.x+15, r.y+60, 140, 16, C.deskTop);
  rect(c, r.x+15, r.y+76, 140, 3, C.desk);
  // Stools
  for (let i = 0; i < 3; i++) {
    rect(c, r.x+30+i*40, r.y+90, 14, 4, C.chairSeat);
    rect(c, r.x+35+i*40, r.y+94, 4, 10, C.chair);
  }
  drawPlant(c, r.x+190, r.y+90, 1);
}

function renderBriefing(c) {
  const r = ROOMS[3];
  drawWalls(c, r);
  // Conference table
  drawDesk(c, r.x+60, r.y+40, 120, 22);
  // Chairs around table
  for (let i = 0; i < 4; i++) {
    drawChair(c, r.x+70+i*28, r.y+75);
  }
  // Whiteboard on wall
  drawWhiteboard(c, r.x+20, r.y+12);
  // Shelf
  drawShelf(c, r.x+220, r.y+14, 60);
  // Plants
  drawPlant(c, r.x+18, r.y+120, 1.2);
  drawPlant(c, r.x+280, r.y+120, 1);
}

function renderLounge(c) {
  const x = LOUNGE_X, y = LOUNGE_Y, w = LOUNGE_W, h = LOUNGE_H;
  // Floor
  drawFloor(c, x+5, y+5, w-10, h-10);
  // Walls
  rect(c, x, y, w, 5, C.wallTop);
  rect(c, x+w-5, y, 5, h, C.wall);
  rect(c, x, y, 5, h, C.wall);
  // Bottom wall with door
  const doorW = 46;
  const doorX = x + 20;
  rect(c, x, y+h-5, doorX-x, 5, C.wallTop);
  rect(c, doorX+doorW, y+h-5, (x+w)-(doorX+doorW), 5, C.wallTop);
  // Labels
  c.fillStyle = C.wallAccent;
  c.font = '8px "JetBrains Mono"';
  c.fillText('BRIEFING & REC', x+10, y+14);
  // Whiteboard
  drawWhiteboard(c, x+20, y+30);
  // Coffee table
  rect(c, x+30, y+110, 40, 24, C.desk);
  rect(c, x+32, y+112, 36, 20, C.deskTop);
  // Couch
  drawCouch(c, x+20, y+150, 80);
  // Water cooler
  drawWaterCooler(c, x+140, y+40);
  // Bean bags
  drawBeanBag(c, x+180, y+120, C.bean1);
  drawBeanBag(c, x+220, y+150, C.bean2);
  // Ping pong table
  drawPingPong(c, x+120, y+220);
  // Plants
  drawPlant(c, x+260, y+40, 1.5);
  drawPlant(c, x+280, y+280, 1.2);
  drawPlant(c, x+20, y+300, 1);
  // Rec sign
  c.fillStyle = C.hdrDim;
  c.font = '7px "JetBrains Mono"';
  c.fillText('ðŸŽ¯ REC ZONE', x+120, y+210);
}

function drawQuarter(c, quarter) {
  const { x, y, w, h, label, agent } = quarter;
  const t = 4;
  drawFloor(c, x+t, y+t, w-2*t, h-2*t);
  rect(c, x, y, w, t, C.wallTop);
  rect(c, x, y, t, h, C.wall);
  rect(c, x+w-t, y, t, h, C.wall);
  const doorW = 32;
  const doorX = x + (w-doorW)/2;
  rect(c, x, y+h-t, doorX-x, t, C.wallTop);
  rect(c, doorX+doorW, y+h-t, (x+w)-(doorX+doorW), t, C.wallTop);
  c.fillStyle = C.hdrDim;
  c.font = '8px "JetBrains Mono"';
  c.fillText(label, x + 8, y + 14);

  drawRug(c, x+18, y+h-36, w-36, 20, 'rgba(90,110,130,0.2)');

  switch (agent) {
    case 'Flint':
      drawBed(c, x+18, y+28, 88, 'left');
      drawDogBed(c, x+w-60, y+70);
      drawWhiteboard(c, x+w-96, y+24);
      drawPlant(c, x+30, y+h-60, 0.8);
      break;
    case 'Cipher':
      drawBed(c, x+w-110, y+28, 90, 'right');
      drawServerRack(c, x+24, y+32);
      drawMiniFridge(c, x+22, y+78);
      drawEnergyDrink(c, x+60, y+78);
      break;
    case 'Atlas':
      drawBed(c, x+26, y+32, 88, 'left');
      drawBlueprintDesk(c, x+110, y+80);
      drawBookshelf(c, x+w-70, y+22, 56);
      drawPlant(c, x+90, y+28, 0.7);
      break;
  }
}

function drawStairs(c, x, y) {
  rect(c, x, y, 40, 50, '#2A2A35');
  for (let i = 0; i < 5; i++) {
    rect(c, x+4, y+8+i*9, 32, 3, '#4A4A5A');
  }
  c.fillStyle = '#6A6A7A';
  c.font = '7px "JetBrains Mono"';
  c.fillText('â†•', x+16, y+32);
}

function renderQuarters(c) {
  QUARTERS.forEach(q => drawQuarter(c, q));
}
function drawQuartersOverlay(ctx) {
  QUARTERS.forEach(q => {
    const ent = entities.find(e => e.name === q.agent);
    if (ent && q.spritePos) {
      const sprites = ent.getSprites();
      drawSprite(ctx, sprites.stand, sprites.pal, q.spritePos.x, q.spritePos.y, 2);
      ctx.fillStyle = ent.status === 'working' ? C.green : C.barDim;
      ctx.font = '7px \"JetBrains Mono\"';
      ctx.fillText(ent.status.toUpperCase(), q.spritePos.x + 26, q.spritePos.y + 10);
    }
    if (q.agent === 'Flint') {
      drawSprite(ctx, LUCKY_IDLE1, LUCKY_PAL, q.spritePos.x + 32, q.spritePos.y + 22, 2);
    }
  });
}



// ===== STATIC BACKGROUND =====
function paintBase(ctx, floorLabel) {
  rect(ctx, 0, 0, TARGET_WIDTH, TARGET_HEIGHT, C.bg);
  rect(ctx, 0, 0, TARGET_WIDTH, HDR_H, C.hdrBg);
  rect(ctx, 0, HDR_H-1, TARGET_WIDTH, 1, C.hdrBorder);
  ctx.fillStyle = C.hdrText;
  ctx.font = 'bold 11px "JetBrains Mono"';
  ctx.fillText('â—† 87 HIGHLAND LANE', 16, 19);
  ctx.fillStyle = C.hdrDim;
  ctx.font = '10px "JetBrains Mono"';
  ctx.fillText('SECURE OPS CENTER', 230, 19);
  ctx.textAlign = 'right';
  ctx.fillText(floorLabel, TARGET_WIDTH - 16, 19);
  ctx.textAlign = 'left';
  rect(ctx, 0, BAR_Y, TARGET_WIDTH, BAR_H, C.barBg);
  rect(ctx, 0, BAR_Y, TARGET_WIDTH, 1, C.barBorder);
  rect(ctx, 0, BAR_Y+1, TARGET_WIDTH, 1, C.barBorder);
}

function renderOpsCorridors(c) {
  // Horizontal corridor between rooms and pods
  drawFloor(c, 10, ROOM_Y + ROOM_H*2 + ROOM_GAP, 780, 20);
  // Vertical corridor on right side
  drawFloor(c, 742, ROOM_Y, 28, POD_Y + POD_H - ROOM_Y);
  // Walkway from stairs down to quarters
  drawFloor(c, 10, FLOOR2_Y - 8, 750, 12);
  drawFloor(c, 742, FLOOR2_Y - 8, 28, QUARTER_H + 24);
}

function renderBackground() {
  const bg = ctx; // render directly to main canvas buffer
  // Base fill for full canvas
  rect(bg, 0, 0, TARGET_WIDTH, TARGET_HEIGHT, C.bg);

  // Header
  rect(bg, 0, 0, TARGET_WIDTH, HDR_H, C.hdrBg);
  rect(bg, 0, HDR_H-1, TARGET_WIDTH, 1, C.hdrBorder);
  bg.fillStyle = C.hdrText;
  bg.font = 'bold 11px "JetBrains Mono"';
  bg.fillText('â—† 87 HIGHLAND LANE', 16, 19);
  bg.fillStyle = C.hdrDim;
  bg.font = '10px "JetBrains Mono"';
  bg.fillText('SECURE OPS CENTER', 230, 19);

  // â”€â”€ FLOOR 1: OPS â”€â”€
  renderOpsCorridors(bg);
  renderRDLab(bg);
  renderCommand(bg);
  renderGalley(bg);
  renderBriefing(bg);
  renderLounge(bg);
  PODS.forEach((pod, i) => {
    const agent = AGENTS.find(a => a.podIndex === i);
    drawPod(bg, pod, agent);
  });
  drawPlant(bg, 30, POD_Y+POD_H+1, 0.8);
  drawPlant(bg, 400, ROOM_Y+ROOM_H+2, 1);
  drawPlant(bg, 700, POD_Y+POD_H+10, 1.2);

  // â”€â”€ FLOOR SEPARATOR â”€â”€
  rect(bg, 0, FLOOR_SEP_Y, TARGET_WIDTH, 2, '#3A5A7A');
  bg.fillStyle = '#3A5A7A';
  bg.font = 'bold 9px "JetBrains Mono"';
  bg.fillText('â–¼  QUARTERS LEVEL  â–¼', TARGET_WIDTH/2 - 70, FLOOR_SEP_Y + 18);
  drawStairs(bg, 740, FLOOR_SEP_Y - 10);

  // â”€â”€ FLOOR 2: QUARTERS â”€â”€
  renderQuarters(bg);
  drawPlant(bg, 60, QUARTER_Y+20, 1);
  drawPlant(bg, 720, QUARTER_Y+40, 1.2);

  // Bottom bar
  rect(bg, 0, BAR_Y, TARGET_WIDTH, BAR_H, C.barBg);
  rect(bg, 0, BAR_Y, TARGET_WIDTH, 1, C.barBorder);
  rect(bg, 0, BAR_Y+1, TARGET_WIDTH, 1, C.barBorder);
}
// ===== SPRITE SYSTEM =====
function drawSprite(ctx, data, pal, x, y, s) {
  for (let r = 0; r < data.length; r++) {
    const row = data[r];
    for (let c = 0; c < row.length; c++) {
      const ch = row[c];
      if (ch !== '.' && pal[ch]) {
        ctx.fillStyle = pal[ch];
        ctx.fillRect((x + c*s)|0, (y + r*s)|0, s, s);
      }
    }
  }
}

// ===== FLINT SPRITES =====
const FLINT_PAL = {
  H:C.fHair, S:C.fSkin, s:C.fSkinS, E:C.fEye,
  J:C.fJacket, j:C.fJacketD, O:C.fAccent,
  B:C.fBelt, P:C.fPants, b:C.fBoots,
};
const FLINT_STAND = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PPPP..',
  '..PP.PP.',
  '..bb.bb.',
];
const FLINT_WALK1 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PP.PP.',
  '.PP...PP',
  '.bb...bb',
];
const FLINT_WALK2 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '.PP..PP.',
  'PP....PP',
  'bb....bb',
];
const FLINT_SIT = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
];

// ===== CIPHER SPRITES =====
const CIPHER_PAL = {
  H: C.cHair, S: C.cSkin, s: C.cSkinS, E: C.cEye,
  J: C.cJacket, j: C.cJacketD, O: C.cAccent,
  B: C.cBelt, P: C.cPants, b: C.cBoots,
};
const CIPHER_STAND = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PPPP..',
  '..PP.PP.',
  '..bb.bb.',
];
const CIPHER_WALK1 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '..PP.PP.',
  '.PP...PP',
  '.bb...bb',
];
const CIPHER_WALK2 = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
  '..PPPP..',
  '.PP..PP.',
  'PP....PP',
  'bb....bb',
];
const CIPHER_SIT = [
  '..HHHH..',
  '.HHHHHH.',
  '.HSSSSH.',
  '.SEESSE.',
  '.SSssSS.',
  '..SssS..',
  '..SSSS..',
  '.jJJJJj.',
  '.JJJJJJ.',
  '.JOOJOJ.',
  '.JJJJJJ.',
  '.jJBBJj.',
];

// ===== LUCKY SPRITES =====
const LUCKY_PAL = {
  W:C.lW, B:C.lB, n:C.lNose, t:C.lTongue,
};
const LUCKY_IDLE1 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWWWW.',
  '.WWWWW.',
  '.WW.WW.',
  '..W....',
];
const LUCKY_IDLE2 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWtWW.',
  '.WWWWW.',
  '.WW.WW.',
  '....W..',
];
const LUCKY_WALK1 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWWWW.',
  '.WWWWW.',
  '.W...W.',
  'W.....W',
];
const LUCKY_WALK2 = [
  '.WW.WW.',
  'WWWWWWW',
  'WBWnWBW',
  '.WWWWW.',
  '.WWWWW.',
  'W.....W',
  '.W...W.',
];

// ===== AGENT CLASS =====
class AgentEntity {
  constructor(cfg) {
    Object.assign(this, cfg);
    this.pod = PODS[cfg.podIndex];
    const dc = deskCenter(this.pod);
    this.deskPos = { x: dc.x - 12, y: dc.y - 20 };
    this.x = dc.x - 12;
    this.y = dc.y + 20;
    this.state = 'walking_to_desk';
    this.target = { ...this.deskPos };
    this.frame = 0;
    this.frameTimer = 0;
    this.stateTimer = 0;
    this.facing = 1; // 1=right, -1=left
    this.speed = 55;
    this.expanded = false; // Status Board card expanded?
  }
  getTargetPos() {
    // If meeting is active, use meeting location position
    if (meetingActive) {
      // First check for named position (legacy support for galley)
      if (meetingLocation === 'galley' && GALLEY_POSITIONS[this.name]) {
        const pos = GALLEY_POSITIONS[this.name];
        return { x: pos.x - 12, y: pos.y - 20 };
      }
      
      // Use location-based positions
      const locationData = MEETING_LOCATIONS[meetingLocation];
      if (locationData && locationData.positions) {
        // Get agent index for position assignment (stable order by sorting)
        const sortedAgents = [...entities].sort((a, b) => a.name.localeCompare(b.name));
        const agentIndex = sortedAgents.findIndex(a => a.name === this.name);
        
        if (agentIndex >= 0 && agentIndex < locationData.positions.length) {
          const pos = locationData.positions[agentIndex];
          return { x: pos.x - 12, y: pos.y - 20 };
        }
      }
    }
    
    // Otherwise use desk position
    return this.deskPos;
  }
  getSprites() {
    if (this.name === 'Cipher' || this.name === 'Atlas') {
      return { pal: CIPHER_PAL, stand: CIPHER_STAND, walk1: CIPHER_WALK1, walk2: CIPHER_WALK2, sit: CIPHER_SIT };
    }
    return { pal: FLINT_PAL, stand: FLINT_STAND, walk1: FLINT_WALK1, walk2: FLINT_WALK2, sit: FLINT_SIT };
  }
  update(dt) {
    this.frameTimer += dt;
    if (this.frameTimer > 0.25) { this.frame = (this.frame+1)%2; this.frameTimer = 0; }
    this.stateTimer -= dt * 1000;

    // Update target if meeting state changed
    const targetPos = this.getTargetPos();

    // FORCE: If idle, NEVER be at desk. If working, go to desk.
    // This provides immediate visual feedback regardless of state timers
    if (this.status !== 'working' && !meetingActive) {
      // If currently at desk (walking_to_desk or working), leave immediately
      if (this.state === 'walking_to_desk' || this.state === 'working') {
        this.startWander();
      }
    }

    switch (this.state) {
      case 'walking_to_desk':
        this.target = targetPos;
        this.moveToTarget(dt);
        break;
      case 'wandering':
        // Only wander if not in meeting
        if (meetingActive) {
          this.state = 'walking_to_desk';
          this.target = targetPos;
          this.moveToTarget(dt);
        } else {
          this.moveToTarget(dt);
        }
        break;
      case 'working':
        // During meeting, always "work" at galley position
        if (meetingActive) {
          this.target = targetPos;
          // Move to position if not there yet
          const dx = this.target.x - this.x;
          const dy = this.target.y - this.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > 3) {
            this.state = 'walking_to_desk';
          }
        } else if (this.stateTimer <= 0) {
          // Working timer expired, go do something else
          if (this.status !== 'working') {
            this.startWander(); // Idle: wander away
          } else {
            // Still working but taking a break
            if (Math.random() < 0.6) this.startWander();
            else { this.state = 'idle'; this.stateTimer = 2000 + Math.random() * 3000; }
          }
        }
        break;
      case 'idle':
        if (meetingActive) {
          this.state = 'walking_to_desk';
          this.target = targetPos;
        } else if (this.status === 'working') {
          this.state = 'walking_to_desk';
          this.target = targetPos;
        } else if (this.stateTimer <= 0) {
          if (Math.random() < 0.6) this.startWander();
          else { this.stateTimer = 2000 + Math.random() * 3000; } // Keep idling
        }
        break;
    }
  }
  moveToTarget(dt) {
    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < 3) {
      this.x = this.target.x; this.y = this.target.y;
      if (this.state === 'walking_to_desk') {
        this.state = 'working';
        this.stateTimer = 8000 + Math.random() * 12000;
      } else {
        this.state = 'idle';
        this.stateTimer = 2000 + Math.random() * 4000;
      }
      return;
    }
    const mx = (dx/dist) * this.speed * dt;
    const my = (dy/dist) * this.speed * dt;
    this.x += mx; this.y += my;
    if (Math.abs(dx) > 2) this.facing = dx > 0 ? 1 : -1;
  }
  startWander() {
    // Don't wander during meetings
    if (meetingActive) {
      this.state = 'walking_to_desk';
      this.target = this.getTargetPos();
      return;
    }
    this.state = 'wandering';
    const spots = [
      // Rooms (2x2 grid)
      { x: ROOMS[0].x+80, y: ROOMS[0].y+80 },
      { x: ROOMS[1].x+120, y: ROOMS[1].y+80 },
      { x: ROOMS[2].x+100, y: ROOMS[2].y+80 },
      { x: ROOMS[3].x+100, y: ROOMS[3].y+80 },
      // Lounge (below pods)
      { x: LOUNGE_X+100, y: LOUNGE_Y+60 },
      { x: LOUNGE_X+300, y: LOUNGE_Y+100 },
      { x: LOUNGE_X+500, y: LOUNGE_Y+80 },
      // Corridors
      { x: 200, y: ROOM_Y+ROOM_H*2+ROOM_GAP+6 },
      { x: 500, y: ROOM_Y+ROOM_H*2+ROOM_GAP+6 },
      { x: 400, y: POD_Y+POD_H+10 },
    ];
    this.target = spots[Math.random()*spots.length|0];
  }
  draw(ctx) {
    const s = 3;
    const sprites = this.getSprites();
    if (this.state === 'working') {
      drawSprite(ctx, sprites.sit, sprites.pal, this.x|0, this.y|0, s);
    } else if (this.state === 'idle') {
      drawSprite(ctx, sprites.stand, sprites.pal, this.x|0, this.y|0, s);
    } else {
      const spr = this.frame === 0 ? sprites.walk1 : sprites.walk2;
      drawSprite(ctx, spr, sprites.pal, this.x|0, this.y|0, s);
    }
    // Name tag above head
    ctx.fillStyle = this.color;
    ctx.font = 'bold 8px "JetBrains Mono"';
    ctx.fillText(this.name, (this.x - 2)|0, (this.y - 4)|0);
  }
}

// ===== COMPANION CLASS =====
class CompanionEntity {
  constructor(cfg, owner) {
    this.name = cfg.name;
    this.owner = owner;
    this.x = owner.x + 30;
    this.y = owner.y + 20;
    this.target = { x: this.x, y: this.y };
    this.frame = 0;
    this.frameTimer = 0;
    this.state = 'following'; // following | sitting | wandering | fetching | sniffing | returning
    this.speed = 45;
    this.stateTimer = 0;
  }
  getGalleyPos() {
    if (GALLEY_POSITIONS[this.name]) {
      const pos = GALLEY_POSITIONS[this.name];
      return { x: pos.x, y: pos.y };
    }
    return null;
  }
  update(dt) {
    this.frameTimer += dt;
    if (this.frameTimer > 0.35) { this.frame = (this.frame+1)%2; this.frameTimer = 0; }
    this.stateTimer -= dt * 1000;

    // Check if meeting is active and we have a galley position
    const galleyPos = this.getGalleyPos();
    
    // Handle newspaper run states (fetching, sniffing, returning)
    if (this.state === 'fetching') {
      this.target = NEWSPAPER_SPOT;
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
      } else {
        // Reached newspaper spot, start sniffing
        this.state = 'sniffing';
        this.stateTimer = 3000; // Sniff for 3 seconds
      }
      return;
    }
    
    if (this.state === 'sniffing') {
      // Stay at newspaper spot and sniff
      if (this.stateTimer <= 0) {
        // Done sniffing, return to owner
        this.state = 'returning';
      }
      return;
    }
    
    if (this.state === 'returning') {
      // Return to owner
      const ownerPos = { x: this.owner.x + 25, y: this.owner.y + 15 };
      this.target = ownerPos;
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
      } else {
        // Back at owner, resume normal behavior
        this.state = 'sitting';
      }
      return;
    }

    // Check for heartbeat trigger (only if not already fetching, not in meeting, and cooldown expired)
    const now = Date.now();
    if (heartbeatRecent && 
        this.state !== 'fetching' && 
        this.state !== 'sniffing' && 
        this.state !== 'returning' &&
        !meetingActive &&
        now - lastHeartbeatProcessedAt > 60000) {
      lastHeartbeatProcessedAt = now;
      this.state = 'fetching';
      return;
    }

    if (meetingActive && galleyPos) {
      // Go to galley position
      this.target = galleyPos;
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
        this.state = 'following';
      } else {
        this.state = 'sitting';
      }
    } else if (this.owner.state === 'working') {
      // Sit near desk
      this.target = { x: this.owner.x + 28, y: this.owner.y + 30 };
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 4) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
        this.state = 'following';
      } else {
        this.state = 'sitting';
      }
    } else if (this.owner.state === 'idle' || this.owner.state === 'wandering' || this.owner.state === 'walking_to_desk') {
      // Follow owner with slight delay
      this.target = { x: this.owner.x + 25, y: this.owner.y + 15 };
      const dx = this.target.x - this.x, dy = this.target.y - this.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 20) {
        this.x += (dx/dist)*this.speed*dt;
        this.y += (dy/dist)*this.speed*dt;
        this.state = 'following';
      } else {
        this.state = 'sitting';
      }
    }
  }
  draw(ctx) {
    const s = 2;
    let spr;
    if (this.state === 'sitting' || this.state === 'sniffing') {
      // Use IDLE2 (tongue out) during sniffing for cute effect, IDLE1 for sitting
      spr = this.state === 'sniffing' ? LUCKY_IDLE2 : (this.frame === 0 ? LUCKY_IDLE1 : LUCKY_IDLE2);
    } else {
      spr = this.frame === 0 ? LUCKY_WALK1 : LUCKY_WALK2;
    }
    drawSprite(ctx, spr, LUCKY_PAL, this.x|0, this.y|0, s);
    // Name
    ctx.fillStyle = '#8090A0';
    ctx.font = '6px "JetBrains Mono"';
    ctx.fillText(this.name, (this.x-2)|0, (this.y-2)|0);
  }
}

// ===== MOBILE STATUS BAR =====
// State for mobile mode
let selectedAgent = null; // Which agent's card is expanded
let isMobile = window.innerWidth < 600;

// Track chip positions for click detection
let chipPositions = [];
let cardPositions = [];

// Handle resize to switch modes
window.addEventListener('resize', () => {
  isMobile = window.innerWidth < 600;
  if (!isMobile) selectedAgent = null; // Clear selection on desktop
});

// ===== CHUNK 1: COMPACT CHIP RENDERING =====
function drawCompactChip(ctx, ent, x, y, chipWidth = 80, chipHeight = 36) {
  // Background
  rect(ctx, x, y, chipWidth, chipHeight, '#0F1520');
  strokeRect(ctx, x, y, chipWidth, chipHeight, C.barBorder);

  // Color dot (6px)
  rect(ctx, x + 6, y + 15, 6, 6, ent.color);

  // Name (truncated if needed)
  ctx.fillStyle = '#C0C8D4';
  ctx.font = 'bold 9px "JetBrains Mono"';
  ctx.textAlign = 'left';
  
  // Truncate name to fit
  let displayName = ent.name;
  const nameMetrics = ctx.measureText(displayName);
  if (nameMetrics.width > 34) {
    displayName = ent.name.substring(0, 3) + '..';
  }
  ctx.fillText(displayName, x + 16, y + 21);

  // Level badge (small, right side)
  const levelText = `Lv.${ent.level}`;
  ctx.font = '8px "JetBrains Mono"';
  const levelWidth = ctx.measureText(levelText).width;
  const badgeX = x + chipWidth - levelWidth - 14;
  const badgeY = y + 7;
  
  // Dark background for level badge
  const darkColor = darkenColor(ent.color, 0.4);
  ctx.fillStyle = darkColor;
  ctx.beginPath();
  ctx.roundRect(badgeX - 2, badgeY, levelWidth + 4, 10, 5);
  ctx.fill();
  
  ctx.fillStyle = ent.color;
  ctx.fillText(levelText, badgeX, badgeY + 7);

  // Status dot (6px, right side) - amber for meeting, green for working, red for idle
  let statusColor;
  if (ent.status === 'meeting') {
    statusColor = C.amber;  // Orange for meeting
  } else if (ent.status === 'working') {
    statusColor = C.green;  // Green for working
  } else {
    statusColor = C.red;    // Red for idle
  }
  rect(ctx, x + chipWidth - 10, y + 15, 6, 6, statusColor);
}

// ===== CHUNK 2: EXPANDED CARD VIEW =====
function drawExpandedCard(ctx, ent, x, y, cardWidth = 160, cardHeight = 90) {
  // Ensure card stays within bounds
  if (x + cardWidth > TARGET_WIDTH) x = TARGET_WIDTH - cardWidth - 10;
  if (y + cardHeight > TARGET_HEIGHT) y = TARGET_HEIGHT - cardHeight - 10;

  // Card background with subtle shadow
  rect(ctx, x, y, cardWidth, cardHeight, '#0F1520');
  strokeRect(ctx, x, y, cardWidth, cardHeight, ent.color);
  
  // Header with color accent
  rect(ctx, x, y, cardWidth, 4, ent.color);

  // Color dot
  rect(ctx, x + 8, y + 12, 10, 10, ent.color);

  // Name
  ctx.fillStyle = ent.color;
  ctx.font = 'bold 11px "JetBrains Mono"';
  ctx.textAlign = 'left';
  ctx.fillText(ent.name, x + 24, y + 20);

  // Level badge
  drawLevelBadge(ctx, x + cardWidth - 45, y + 10, ent.level, ent.color);

  // Role
  ctx.fillStyle = C.barDim;
  ctx.font = '9px "JetBrains Mono"';
  ctx.fillText(ent.role, x + 8, y + 38);

  // Status with colored indicator - meeting shows amber/orange
  let statusText, statusColor;
  if (ent.status === 'meeting') {
    statusText = 'ðŸ“ MEETING';
    statusColor = C.amber;
  } else if (ent.status === 'working') {
    statusText = 'â— WORKING';
    statusColor = C.green;
  } else {
    statusText = 'â— IDLE';
    statusColor = C.red;
  }
  ctx.fillStyle = statusColor;
  ctx.font = '9px "JetBrains Mono"';
  ctx.fillText(statusText, x + 8, y + 52);

  // EXP bar
  const expBarX = x + 8;
  const expBarY = y + 62;
  const expBarWidth = cardWidth - 16;
  const expBarHeight = 6;
  
  const isMaxLevel = ent.nextLevel === null || ent.nextLevel === Infinity || ent.nextLevel === undefined;
  let expProgress = ent.expProgress;
  if (expProgress === undefined || expProgress === null) {
    if (ent.exp !== undefined && ent.nextLevel && !isMaxLevel) {
      expProgress = ent.exp / ent.nextLevel;
    } else if (isMaxLevel) {
      expProgress = 1.0;
    }
  }
  
  if (expProgress !== undefined && !isNaN(expProgress)) {
    drawExpBar(ctx, expBarX, expBarY, expBarWidth, expBarHeight, expProgress, ent.color, isMaxLevel);
    
    // EXP text
    ctx.fillStyle = '#5A6A7A';
    ctx.font = '7px "JetBrains Mono"';
    let expText = isMaxLevel ? 'MAX' : `${ent.exp || 0}/${ent.nextLevel}`;
    ctx.fillText(expText, expBarX + expBarWidth + 4, expBarY + 4);
  }

  // Close hint
  ctx.fillStyle = C.barDim;
  ctx.font = '7px "JetBrains Mono"';
  ctx.fillText('(tap to close)', x + 8, y + cardHeight - 4);
}

// ===== CHUNK 3: MOBILE STATUS BAR =====
function drawCompactStatusBar() {
  const CHIP_WIDTH = 240;  // Wider chips for 3 agents
  const CHIP_HEIGHT = 36;
  const GAP_X = 10;
  const GAP_Y = 8;
  const COLS = 1;         // Single column, 3 rows
  const START_X = 16;
  const START_Y = BAR_Y + 24;

  // Clear chip positions for click detection
  chipPositions = [];

  // Draw agent chips in 3-column grid
  entities.forEach((ent, i) => {
    const col = i % COLS;
    const row = Math.floor(i / COLS);
    const x = START_X + col * (CHIP_WIDTH + GAP_X);
    const y = START_Y + row * (CHIP_HEIGHT + GAP_Y);

    // Store position for hit testing
    chipPositions.push({ x, y, width: CHIP_WIDTH, height: CHIP_HEIGHT, agent: ent });

    // Draw compact chip
    drawCompactChip(ctx, ent, x, y, CHIP_WIDTH, CHIP_HEIGHT);
  });

  // Calculate total grid height
  const rows = Math.ceil(entities.length / COLS);
  const gridHeight = rows * CHIP_HEIGHT + (rows - 1) * GAP_Y;

  // Draw expanded card if agent selected
  if (selectedAgent) {
    const ent = entities.find(e => e.name === selectedAgent);
    if (ent) {
      // Position expanded card below the grid
      const cardX = START_X;
      const cardY = START_Y + gridHeight + 8;
      
      drawExpandedCard(ctx, ent, cardX, cardY, 160, 85);
    } else {
      // Edge case: agent not found, clear selection
      selectedAgent = null;
    }
  }

  // System info (compact for mobile)
  ctx.fillStyle = C.barDim;
  ctx.font = '7px "JetBrains Mono"';
  const sysY = BAR_Y + BAR_H - 12;
  ctx.fillText(`AGENTS: ${entities.length} | FACILITY: ${meetingActive ? 'MEETING' : 'OPERATIONAL'}`, 16, sysY);
  
  if (meetingActive) {
    ctx.fillStyle = C.amber;
    ctx.fillText(`â—† MEETING @ ${meetingLocation.toUpperCase()} â—†`, 200, sysY);
  }
}

// ===== DESKTOP STATUS BAR (original) =====
function drawDesktopStatusBar() {
  // Clear click positions every frame
  todoPositions = [];
  statusTabPositions = [];
  
  // Header classified blink
  const blink = (Date.now() / 800 | 0) % 2;
  rect(ctx, TARGET_WIDTH - 200, 6, 190, 18, C.hdrBg);
  ctx.fillStyle = blink ? C.hdrText : C.hdrDim;
  ctx.font = '10px "JetBrains Mono"';
  ctx.fillText('â—† CLASSIFIED â—†', TARGET_WIDTH - 180, 19);

  // â”€â”€ STATUS BOARD HEADER WITH TABS â”€â”€
  const TAB_W = 70;
  const TAB_H = 18;
  const TAB_Y = BAR_Y + 6;
  const TAB_GAP = 4;
  const tabs = [
    { id: 'agents', label: 'AGENTS' },
    { id: 'todos', label: 'TO-DO' },
    { id: 'activity', label: 'ACTIVITY' }
  ];
  
  // Draw tabs
  let tabX = 16;
  tabs.forEach(tab => {
    const isActive = statusTab === tab.id;
    const w = TAB_W;
    
    // Tab background
    ctx.fillStyle = isActive ? '#1A2535' : '#0D1520';
    ctx.beginPath();
    ctx.roundRect(tabX, TAB_Y, w, TAB_H, 3);
    ctx.fill();
    
    // Tab border
    strokeRect(ctx, tabX, TAB_Y, w, TAB_H, isActive ? '#3A5A7A' : '#1A2535');
    
    // Tab text
    ctx.fillStyle = isActive ? C.hdrText : '#4A5A6A';
    ctx.font = 'bold 8px "JetBrains Mono"';
    ctx.fillText(tab.label, tabX + 6, TAB_Y + 13);
    
    tabX += w + TAB_GAP;
  });

  // Store tab positions for click detection
  statusTabPositions = [];
  tabX = 16;
  tabs.forEach(tab => {
    statusTabPositions.push({ x: tabX, y: TAB_Y, width: TAB_W, height: TAB_H, id: tab.id });
    tabX += TAB_W + TAB_GAP;
  });

  // Modal button (expand to fullscreen) â€” next to tabs
  const modalBtnX = 250;
  const modalBtnW = 70;
  const modalBtnH = TAB_H;
  ctx.fillStyle = modalOpen ? '#2A4A6A' : '#0D1520';
  ctx.beginPath();
  ctx.roundRect(modalBtnX, TAB_Y, modalBtnW, modalBtnH, 3);
  ctx.fill();
  strokeRect(ctx, modalBtnX, TAB_Y, modalBtnW, modalBtnH, modalOpen ? '#4A7AAA' : '#1A2535');
  ctx.fillStyle = modalOpen ? '#8ABADF' : '#4A6A7A';
  ctx.font = 'bold 8px "JetBrains Mono"';
  ctx.fillText(modalOpen ? 'â–¼ CLOSE' : 'â–² EXPAND', modalBtnX + 8, TAB_Y + 13);
  
  // Store modal button position
  statusTabPositions.push({ x: modalBtnX, y: TAB_Y, width: modalBtnW, height: modalBtnH, id: 'modal' });

  // Time (far right, no overlap)
  const now = new Date();
  const ts = now.toLocaleTimeString('en-US', { hour12: false });
  ctx.fillStyle = C.hdrText;
  ctx.font = '9px "JetBrains Mono"';
  ctx.fillText(ts, TARGET_WIDTH - 60, BAR_Y + 14);

  // Draw content based on selected tab
  const contentY = BAR_Y + 30;
  
  if (statusTab === 'agents') {
    // Existing agent cards code starts here...

  // â”€â”€ AGENT CARDS â€” single row, 3 cards side by side â”€â”€
  const CARD_PAD = 12;
  const AGENT_COUNT = 3; // Fixed for 3 agents
  const COMPANION_W = 110;
  const RIGHT_MARGIN = COMPANION_W + CARD_PAD * 2;
  const AVAILABLE_W = TARGET_WIDTH - CARD_PAD * 2 - RIGHT_MARGIN;
  const CARD_GAP = 10;
  const CARD_W = 210; // Fixed: narrower to fit 3 agents + companion panel
  const CARD_H = 115;
  const CARD_Y = BAR_Y + 24;

  cardPositions = [];

  entities.forEach((ent, i) => {
    const x = CARD_PAD + i * (CARD_W + CARD_GAP);
    const y = CARD_Y;

    cardPositions.push({ x, y, width: CARD_W, height: CARD_H, agent: ent });

    // Card background
    ctx.fillStyle = '#0A0F18';
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.roundRect(x, y, CARD_W, CARD_H, 4);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Subtle left accent bar in agent color
    ctx.fillStyle = ent.color;
    ctx.globalAlpha = 0.6;
    ctx.fillRect(x, y + 4, 3, CARD_H - 8);
    ctx.globalAlpha = 1;

    // Border
    strokeRect(ctx, x, y, CARD_W, CARD_H, '#1A2535');

    // â”€â”€ Row 1: Name + Level badge â”€â”€
    const innerX = x + 10;
    const innerW = CARD_W - 20;

    ctx.fillStyle = ent.color;
    ctx.font = 'bold 10px "JetBrains Mono"';
    ctx.fillText(ent.name, innerX, y + 16);

    // Level badge (right-aligned)
    const lvlText = `Lv${ent.level}`;
    ctx.font = 'bold 8px "JetBrains Mono"';
    const lvlW = ctx.measureText(lvlText).width + 8;
    const lvlX = x + CARD_W - lvlW - 8;
    ctx.fillStyle = '#1A2535';
    ctx.beginPath();
    ctx.roundRect(lvlX, y + 6, lvlW, 14, 3);
    ctx.fill();
    ctx.fillStyle = ent.color;
    ctx.fillText(lvlText, lvlX + 4, y + 16);

    // â”€â”€ Row 2: Role â”€â”€
    ctx.fillStyle = '#4A5A6A';
    ctx.font = '8px "JetBrains Mono"';
    ctx.fillText(ent.role, innerX, y + 30);

    // â”€â”€ Row 3: Status indicator â”€â”€
    const statusY = y + 46;
    let dotColor = ent.status === 'meeting' ? C.amber : (ent.status === 'working' ? C.green : C.red);
    let statusText = ent.status.toUpperCase();

    // Status dot (pulsing for working)
    if (ent.status === 'working') {
      const pulse = 0.5 + 0.5 * Math.sin(Date.now() / 500);
      ctx.globalAlpha = 0.3 + 0.2 * pulse;
      ctx.beginPath();
      ctx.arc(innerX + 4, statusY - 3, 6, 0, Math.PI * 2);
      ctx.fillStyle = dotColor;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    rect(ctx, innerX, statusY - 7, 8, 8, dotColor);

    ctx.fillStyle = dotColor;
    ctx.font = 'bold 9px "JetBrains Mono"';
    ctx.fillText(statusText, innerX + 14, statusY);

    // â”€â”€ Row 4: EXP bar â”€â”€
    const expY = y + 60;
    const expBarW = innerW;
    const expBarH = 6;
    let expProg = ent.expProgress;
    if (expProg === undefined) expProg = ent.exp / ent.nextLevel;

    // Bar background
    ctx.fillStyle = '#0D1520';
    ctx.beginPath();
    ctx.roundRect(innerX, expY, expBarW, expBarH, 2);
    ctx.fill();

    // Bar fill
    const fillW = Math.max(0, Math.min(expBarW, expBarW * expProg));
    if (fillW > 0) {
      ctx.fillStyle = ent.color;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.roundRect(innerX, expY, fillW, expBarH, 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Bar border
    ctx.strokeStyle = '#1A2535';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(innerX, expY, expBarW, expBarH, 2);
    ctx.stroke();

    // â”€â”€ Row 5: EXP text â”€â”€
    ctx.fillStyle = '#3A4A5A';
    ctx.font = '7px "JetBrains Mono"';
    ctx.fillText(`${ent.exp} / ${ent.nextLevel} XP`, innerX, expY + 16);

    // â”€â”€ Row 6: Tier label â”€â”€
    const tierMap = { 'Lead': 'T1', 'Tech Director': 'T2', 'Heavy Coder': 'T3', 'Coder': 'T4', 'Maintenance': 'T5', 'QA': 'T5', 'Recon': 'T5' };
    const tier = tierMap[ent.role] || '';
    if (tier) {
      ctx.fillStyle = '#2A3545';
      ctx.font = '7px "JetBrains Mono"';
      const tierTextW = ctx.measureText(tier).width + 6;
      const tierX = x + CARD_W - tierTextW - 8;
      ctx.fillStyle = '#1A2535';
      ctx.beginPath();
      ctx.roundRect(tierX, expY + 8, tierTextW, 12, 2);
      ctx.fill();
      ctx.fillStyle = '#4A5A6A';
      ctx.fillText(tier, tierX + 3, expY + 17);
    }
  });

  // â”€â”€ COMPANION PANEL (right side) â”€â”€
  const compX = TARGET_WIDTH - COMPANION_W - CARD_PAD;
  const compY = CARD_Y;
  const compH = 50;

  ctx.fillStyle = '#0A0F18';
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.roundRect(compX, compY, COMPANION_W, compH, 4);
  ctx.fill();
  ctx.globalAlpha = 1;
  strokeRect(ctx, compX, compY, COMPANION_W, compH, '#1A2535');

  companions.forEach(comp => {
    // Dog emoji + name
    ctx.font = '10px "JetBrains Mono"';
    ctx.fillText('ðŸ•', compX + 8, compY + 18);
    ctx.fillStyle = '#D4A574';
    ctx.font = 'bold 9px "JetBrains Mono"';
    ctx.fillText(comp.name, compX + 26, compY + 18);

    // State
    ctx.fillStyle = comp.state === 'sitting' ? '#8B6F4E' : C.barDim;
    ctx.font = '7px "JetBrains Mono"';
    ctx.fillText(comp.state.toUpperCase(), compX + 26, compY + 32);
  });

  // â”€â”€ SYSTEM INFO (below companion) â”€â”€
  const sysX = compX;
  const sysY = compY + compH + 8;
  ctx.fillStyle = '#2A3545';
  ctx.font = '7px "JetBrains Mono"';
  const activeAgents = entities.length;
  const vacantPods = PODS.length - activeAgents;
  ctx.fillText(`AGENTS: ${activeAgents}`, sysX + 8, sysY + 10);
  ctx.fillText(`PODS: ${activeAgents}/${PODS.length} (vacant ${vacantPods})`, sysX + 8, sysY + 22);
  
  } else if (statusTab === 'todos') {
    // â”€â”€ TO-DO BOARD (v2 with assignee badges) â”€â”€
    const todoListX = 16;
    const todoListY = contentY;
    const todoLineH = 28;
    const maxVisible = Math.floor((BAR_Y + BAR_H - contentY - 40) / todoLineH);
    
    // Filter buttons (mini) - ALL + agent names
    const filterX = todoListX;
    const filterY = todoListY;
    const agentNames = ['Flint', 'Cipher', 'Atlas'];
    const filterBtns = [{ id: 'all', label: 'ALL' }].concat(
      agentNames.map(name => ({ id: name.toLowerCase(), label: name.substring(0, 3).toUpperCase() }))
    );
    
    let filterOffsetX = filterX;
    filterBtns.forEach((btn, idx) => {
      const isActive = todoFilter === btn.id;
      const btnW = idx === 0 ? 40 : 36; // ALL wider, agent names compact
      const agentColor = idx > 0 ? (agentsData[agentNames[idx-1]]?.color || '#5A6A7A') : null;
      
      ctx.fillStyle = isActive ? '#1A3545' : '#0D1520';
      ctx.beginPath();
      ctx.roundRect(filterOffsetX, filterY, btnW, 18, 3);
      ctx.fill();
      strokeRect(ctx, filterOffsetX, filterY, btnW, 18, isActive ? (agentColor || '#3A6A8A') : '#1A2535');
      ctx.fillStyle = isActive ? (agentColor || '#8ABADF') : (agentColor ? agentColor + '99' : '#4A6A7A');
      ctx.font = 'bold 6px "JetBrains Mono"';
      ctx.fillText(btn.label, filterOffsetX + 4, filterY + 12);
      
      todoPositions.push({ x: filterOffsetX, y: filterY, width: btnW, height: 18, id: 'filter_' + btn.id });
      filterOffsetX += btnW + 2;
    });
    
    // Add button (right side) - positioned relative to canvas width
    const addBtnX = TARGET_WIDTH - 130;
    const addBtnY = filterY;
    ctx.fillStyle = '#1A3545';
    ctx.beginPath();
    ctx.roundRect(addBtnX, addBtnY, 100, 18, 3);
    ctx.fill();
    strokeRect(ctx, addBtnX, addBtnY, 100, 18, '#3A6A8A');
    ctx.fillStyle = '#5AAA DF';
    ctx.font = 'bold 7px "JetBrains Mono"';
    ctx.fillText('+ ADD TASK', addBtnX + 12, addBtnY + 12);
    todoPositions.push({ x: addBtnX, y: addBtnY, width: 100, height: 18, id: 'add' });
    
    // Filter todos by agent name
    const agentFilterNames = ['flint', 'cipher', 'atlas'];
    const filteredTodos = todosData.filter(todo => {
      if (todoFilter === 'all') return true;
      if (agentFilterNames.includes(todoFilter)) {
        // Filter by assignedTo matching the agent name (case-insensitive)
        return todo.assignedTo && todo.assignedTo.toLowerCase() === todoFilter;
      }
      return true;
    });
    
    // Draw todo list (compact lines)
    const listStartY = filterY + 26;
    filteredTodos.slice(0, maxVisible).forEach((todo, i) => {
      const ty = listStartY + i * todoLineH;
      
      // Checkbox
      const cbX = todoListX + 4;
      const cbY = ty + 6;
      ctx.strokeStyle = todo.done ? '#3A7A5A' : '#3A5A6A';
      ctx.lineWidth = 1;
      ctx.strokeRect(cbX, cbY, 12, 12);
      if (todo.done) {
        ctx.fillStyle = '#3A7A5A';
        ctx.font = 'bold 10px "JetBrains Mono"';
        ctx.fillText('âœ“', cbX + 2, cbY + 10);
      }
      
      // Task text
      ctx.fillStyle = todo.done ? '#4A6A5A' : C.hdrText;
      ctx.font = '9px "JetBrains Mono"';
      const textStartX = cbX + 20;
      const maxTextW = 500;
      // Truncate text to fit
      let displayText = todo.text;
      while (ctx.measureText(displayText).width > maxTextW && displayText.length > 10) {
        displayText = displayText.slice(0, -4) + '...';
      }
      ctx.fillText(displayText, textStartX, cbY + 9);
      
      // Assignee badge
      const badgeX = textStartX + maxTextW + 10;
      let badgeColor, badgeText;
      if (!todo.assignedTo) {
        badgeColor = '#4A5A6A';
        badgeText = 'Unassigned';
      } else if (todo.assignedTo === currentUser) {
        badgeColor = '#00D4FF';  // cyan for self
        badgeText = todo.assignedTo;
      } else {
        badgeColor = '#9966CC';  // purple for others
        badgeText = todo.assignedTo;
      }
      
      // Badge background
      const badgeW = ctx.measureText(badgeText).width + 12;
      ctx.fillStyle = badgeColor + '33'; // 20% opacity
      ctx.beginPath();
      ctx.roundRect(badgeX, cbY - 2, badgeW, 16, 4);
      ctx.fill();
      ctx.fillStyle = badgeColor;
      ctx.font = '7px "JetBrains Mono"';
      ctx.fillText(badgeText, badgeX + 6, cbY + 9);
      
      // Created by (small, right side)
      ctx.fillStyle = '#3A4A5A';
      ctx.font = '7px "JetBrains Mono"';
      const createdByText = `by ${todo.createdBy || 'Unknown'}`;
      const createdByX = 880;
      ctx.fillText(createdByText, createdByX, cbY + 9);
      
      // Delete X button (far right)
      const delX = 940;
      ctx.fillStyle = '#4A2A2A';
      ctx.beginPath();
      ctx.roundRect(delX, cbY - 2, 18, 16, 3);
      ctx.fill();
      ctx.fillStyle = '#AA5A5A';
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText('âœ•', delX + 5, cbY + 9);
      todoPositions.push({ x: delX, y: cbY - 2, width: 18, height: 16, id: todo.id, type: 'delete', text: todo.text });
      
      // Store checkbox position
      todoPositions.push({ x: cbX, y: cbY, width: 12, height: 12, id: todo.id, type: 'toggle' });
    });
    
  } else if (statusTab === 'activity') {
    // â”€â”€ CLI-STYLE ACTIVITY LOG â”€â”€
    const cliX = 16;
    const cliY = contentY;
    const lineH = 16;
    const maxLines = Math.floor((BAR_Y + BAR_H - contentY - 10) / lineH);
    
    // Terminal header bar - full width minus padding
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(cliX, cliY, TARGET_WIDTH - 32, 20);
    ctx.fillStyle = '#3A9A5A';
    ctx.font = 'bold 9px "JetBrains Mono"';
    ctx.fillText('â–¶ ACTIVITY LOG â€” real-time feed', cliX + 8, cliY + 14);
    
    // CLI lines (newest at top)
    const startY = cliY + 26;
    activityData.slice(0, maxLines - 2).forEach((act, i) => {
      const y = startY + i * lineH;
      
      // Prompt style: $
      ctx.fillStyle = '#5A7A6A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText('$', cliX + 4, y + 12);
      
      // Timestamp [HH:MM:SS]
      ctx.fillStyle = '#4A6A5A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText(`[${act.time}]`, cliX + 16, y + 12);
      
      // Agent name (colored)
      const agentColor = agentsData[act.agent]?.color || '#AAAAAA';
      ctx.fillStyle = agentColor;
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText(act.agent + ':', cliX + 90, y + 12);
      
      // Action + Task text
      ctx.fillStyle = '#8A9A9A';
      ctx.font = '9px "JetBrains Mono"';
      const taskPart = act.task ? ` ${act.task}` : '';
      let actionText = act.action + taskPart;
      const maxChars = 50;
      if (actionText.length > maxChars) {
        actionText = actionText.substring(0, maxChars - 3) + '...';
      }
      ctx.fillText(actionText, cliX + 160, y + 12);
      
      // EXP change at end - right aligned
      const expColor = act.exp > 0 ? '#3A9A5A' : (act.exp < 0 ? '#AA4A4A' : '#5A6A5A');
      ctx.fillStyle = expColor;
      ctx.font = 'bold 9px "JetBrains Mono"';
      const expX = TARGET_WIDTH - 50 - ctx.measureText(act.expChange).width;
      ctx.fillText(act.expChange, expX, y + 12);
    });
  }
}

// ===== CHUNK 4: CLICK/TAP HANDLING =====
function handleStatusBarClick(mouseX, mouseY) {
  // Check confirmation modal first (it blocks everything else)
  if (confirmModal.active) {
    if (handleConfirmClick(mouseX, mouseY)) return;
    // Click outside modal does nothing
    return;
  }

  // Check add task modal (it blocks everything else)
  if (addTaskModal.active) {
    if (handleAddTaskModalClick(mouseX, mouseY)) return;
    // Click outside modal does nothing
    return;
  }

  // Handle modal clicks separately
  if (modalOpen) {
    // Check modal tabs
    for (const tab of modalTabPositions) {
      if (mouseX >= tab.x && mouseX <= tab.x + tab.width &&
          mouseY >= tab.y && mouseY <= tab.y + tab.height) {
        if (tab.id === 'close') {
          modalOpen = false;
        } else {
          statusTab = tab.id;
        }
        return;
      }
    }
    
    // Check modal todos
    if (statusTab === 'todos') {
      for (const pos of modalTodoPositions) {
        if (mouseX >= pos.x && mouseX <= pos.x + pos.width &&
            mouseY >= pos.y && mouseY <= pos.y + pos.height) {
          
          // Filter buttons
          if (typeof pos.id === 'string' && pos.id.startsWith('filter_')) {
            todoFilter = pos.id.replace('filter_', '');
            return;
          }
          
          // Add button
          if (pos.id === 'add') {
            showAddTaskModal((text, assignedTo) => {
              fetch('/api/todos', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                body: JSON.stringify({ action: 'add', text, assignedTo })
              }).then(() => fetchStatusBoardData());
            });
            return;
          }
          
          // Delete button
          if (pos.type === 'delete') {
            showConfirm(`Delete task "${pos.todo?.text || 'this task'}"?`, () => {
              fetch('/api/todos', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                body: JSON.stringify({ action: 'delete', id: pos.id })
              }).then(() => fetchStatusBoardData());
            });
            return;
          }
          
          // Assignment dropdown
          if (pos.type === 'assign') {
            const agents = ['Flint', 'Cipher', 'Atlas'];
            const currentAssignee = pos.todo.assignedTo;
            // Build prompt with options
            let promptText = 'Assign to:\n';
            promptText += '0 - Unassign (clear)\n';
            agents.forEach((a, i) => {
              const marker = a === currentAssignee ? ' *' : '';
              promptText += `${i + 1} - ${a}${marker}\n`;
            });
            const choice = prompt(promptText);
            if (choice !== null) {
              const idx = parseInt(choice);
              if (idx === 0) {
                // Unassign
                fetch('/api/todos', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                  body: JSON.stringify({ action: 'unassign', id: pos.id })
                }).then(() => fetchStatusBoardData());
              } else if (idx >= 1 && idx <= agents.length) {
                const newAssignee = agents[idx - 1];
                fetch('/api/todos', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
                  body: JSON.stringify({ action: 'assign', id: pos.id, assignedTo: newAssignee })
                }).then(() => fetchStatusBoardData());
              }
            }
            return;
          }
          
          // Toggle todo (click on card or checkbox)
          if (pos.type === 'todo' || pos.type === 'toggle') {
            fetch('/api/todos', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'complete', id: pos.id })
            }).then(() => fetchStatusBoardData());
            return;
          }
        }
      }
    }
    return;
  }

  // Check if clicking on modal button
  for (const tab of statusTabPositions) {
    if (tab.id === 'modal') {
      if (mouseX >= tab.x && mouseX <= tab.x + tab.width &&
          mouseY >= tab.y && mouseY <= tab.y + tab.height) {
        modalOpen = true;
        modalTabPositions = [];
        modalTodoPositions = [];
        return;
      }
    }
  }

  // Check if clicking on a tab
  for (const tab of statusTabPositions) {
    if (tab.id !== 'modal' && mouseX >= tab.x && mouseX <= tab.x + tab.width &&
        mouseY >= tab.y && mouseY <= tab.y + tab.height) {
      statusTab = tab.id;
      return;
    }
  }

  // Check if click is within status bar area (for non-modal)
  if (mouseY < BAR_Y || mouseY > TARGET_HEIGHT) return;

  // Check if clicking on a todo
  if (statusTab === 'todos') {
    for (const pos of todoPositions) {
      const hit = mouseX >= pos.x && mouseX <= pos.x + pos.width &&
                  mouseY >= pos.y && mouseY <= pos.y + pos.height;
      if (hit) {
        // Filter buttons
        if (typeof pos.id === 'string' && pos.id.startsWith('filter_')) {
          todoFilter = pos.id.replace('filter_', '');
          return;
        }
        
        // Add button
        if (pos.id === 'add') {
          showAddTaskModal((text, assignedTo) => {
            fetch('/api/todos', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'add', text, assignedTo })
            }).then(() => fetchStatusBoardData());
          });
          return;
        }
        
        // Delete button
        if (pos.type === 'delete') {
          showConfirm(`Delete task "${pos.text || 'this task'}"?`, () => {
            fetch('/api/todos', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
              body: JSON.stringify({ action: 'delete', id: pos.id })
            }).then(() => fetchStatusBoardData());
          });
          return;
        }
        
        // Todo item (checkbox or card click)
        if (pos.type === 'todo' || pos.type === 'toggle') {
          fetch('/api/todos', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Requester': currentUser },
            body: JSON.stringify({ action: 'complete', id: pos.id })
          }).then(() => fetchStatusBoardData());
          return;
        }
      }
    }
  }

  // Check if clicking on an agent card
  for (const pos of cardPositions) {
    if (mouseX >= pos.x && mouseX <= pos.x + pos.width &&
        mouseY >= pos.y && mouseY <= pos.y + pos.height) {
      // Reserved for future interaction (agent detail panel, etc.)
      return;
    }
  }
}

// ===== MODAL OVERLAY =====
function drawModalOverlay() {
  // Clear click positions every frame
  modalTabPositions = [];
  modalTodoPositions = [];
  
  const MODAL_PADDING = 40;
  const MODAL_W = canvas.width - MODAL_PADDING * 2;
  const MODAL_H = canvas.height - MODAL_PADDING * 2;
  const MODAL_X = MODAL_PADDING;
  const MODAL_Y = MODAL_PADDING;

  // Dark overlay
  ctx.fillStyle = '#000000';
  ctx.globalAlpha = 0.85;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.globalAlpha = 1;

  // Modal background
  ctx.fillStyle = '#0A0F14';
  ctx.beginPath();
  ctx.roundRect(MODAL_X, MODAL_Y, MODAL_W, MODAL_H, 12);
  ctx.fill();
  
  // Modal border
  strokeRect(ctx, MODAL_X, MODAL_Y, MODAL_W, MODAL_H, '#2A4A6A');

  // Modal header with tabs
  const modalTabs = [
    { id: 'agents', label: 'AGENTS' },
    { id: 'todos', label: 'TO-DO' },
    { id: 'activity', label: 'ACTIVITY' }
  ];
  
  let mTabX = MODAL_X + 20;
  const mTabW = 100;
  const mTabH = 28;
  const mTabY = MODAL_Y + 20;
  
  modalTabs.forEach(tab => {
    const isActive = statusTab === tab.id;
    ctx.fillStyle = isActive ? '#1A2A3A' : '#0D1520';
    ctx.beginPath();
    ctx.roundRect(mTabX, mTabY, mTabW, mTabH, 4);
    ctx.fill();
    strokeRect(ctx, mTabX, mTabY, mTabW, mTabH, isActive ? '#4A7AAA' : '#1A2535');
    ctx.fillStyle = isActive ? '#AADDEE' : '#5A7A8A';
    ctx.font = 'bold 11px "JetBrains Mono"';
    ctx.fillText(tab.label, mTabX + 16, mTabY + 19);
    
    // Store tab position
    modalTabPositions.push({ x: mTabX, y: mTabY, width: mTabW, height: mTabH, id: tab.id });
    mTabX += mTabW + 8;
  });

  // Close button
  const closeX = MODAL_X + MODAL_W - 100;
  ctx.fillStyle = '#2A1A1A';
  ctx.beginPath();
  ctx.roundRect(closeX, mTabY, 80, mTabH, 4);
  ctx.fill();
  strokeRect(ctx, closeX, mTabY, 80, mTabH, '#6A3A3A');
  ctx.fillStyle = '#DD6666';
  ctx.font = 'bold 11px "JetBrains Mono"';
  ctx.fillText('âœ• CLOSE', closeX + 18, mTabY + 19);
  modalTabPositions.push({ x: closeX, y: mTabY, width: 80, height: mTabH, id: 'close' });

  // Content area
  const contentX = MODAL_X + 20;
  const contentY = mTabY + mTabH + 20;
  const contentW = MODAL_W - 40;
  const contentH = MODAL_Y + MODAL_H - contentY - 20;

  if (statusTab === 'agents') {
    // â”€â”€ AGENTS GRID (larger, more detail) â”€â”€
    const cardW = 180;
    const cardH = 140;
    const cardGap = 12;
    const cardsPerRow = Math.floor(contentW / (cardW + cardGap));
    
    entities.forEach((ent, i) => {
      const col = i % cardsPerRow;
      const row = Math.floor(i / cardsPerRow);
      const cx = contentX + col * (cardW + cardGap);
      const cy = contentY + row * (cardH + cardGap);
      
      // Card
      ctx.fillStyle = '#0D1520';
      ctx.beginPath();
      ctx.roundRect(cx, cy, cardW, cardH, 6);
      ctx.fill();
      strokeRect(ctx, cx, cy, cardW, cardH, '#1A2535');
      
      // Accent bar
      ctx.fillStyle = ent.color;
      ctx.globalAlpha = 0.5;
      ctx.fillRect(cx + 4, cy + 8, 3, cardH - 16);
      ctx.globalAlpha = 1;
      
      // Name + Level
      ctx.fillStyle = ent.color;
      ctx.font = 'bold 14px "JetBrains Mono"';
      ctx.fillText(ent.name, cx + 14, cy + 24);
      
      ctx.fillStyle = '#3A4A5A';
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(`Lv${ent.level}`, cx + cardW - 40, cy + 24);
      
      // Role
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '10px "JetBrains Mono"';
      ctx.fillText(ent.role, cx + 14, cy + 42);
      
      // Status
      const statusDot = ent.status === 'working' ? '#3A9A5A' : (ent.status === 'meeting' ? '#AA953A' : '#6A5A4A');
      ctx.fillStyle = statusDot;
      ctx.beginPath();
      ctx.arc(cx + 14, cy + 60, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#8A9AAA';
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(ent.status.toUpperCase(), cx + 26, cy + 64);
      
      // EXP bar
      const expBarW = cardW - 28;
      ctx.fillStyle = '#0A0F14';
      ctx.beginPath();
      ctx.roundRect(cx + 14, cy + 80, expBarW, 10, 3);
      ctx.fill();
      let expProg = ent.expProgress;
      if (expProg === undefined) expProg = ent.exp / ent.nextLevel;
      ctx.fillStyle = ent.color;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.roundRect(cx + 14, cy + 80, expBarW * expProg, 10, 3);
      ctx.fill();
      ctx.globalAlpha = 1;
      strokeRect(ctx, cx + 14, cy + 80, expBarW, 10, '#1A2535');
      
      // EXP text
      ctx.fillStyle = '#4A5A6A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText(`${ent.exp} / ${ent.nextLevel} XP`, cx + 14, cy + 108);
      
      // Tier
      const tierMap = { 'Lead': 'T1', 'Tech Director': 'T2', 'Heavy Coder': 'T3', 'Coder': 'T4', 'Maintenance': 'T5', 'QA': 'T5', 'Recon': 'T5' };
      const tier = tierMap[ent.role] || '';
      if (tier) {
        ctx.fillStyle = '#1A2535';
        ctx.beginPath();
        ctx.roundRect(cx + cardW - 32, cy + 90, 24, 16, 3);
        ctx.fill();
        ctx.fillStyle = '#5A6A7A';
        ctx.font = 'bold 9px "JetBrains Mono"';
        ctx.fillText(tier, cx + cardW - 28, cy + 102);
      }
    });
    
  } else if (statusTab === 'todos') {
    // â”€â”€ TO-DO LIST (full cards with filters) â”€â”€
    const todoX = contentX;
    const todoY = contentY;
    
    // Filter buttons row - ALL + agent names
    const mAgentNames = ['Flint', 'Cipher', 'Atlas'];
    const mFilterBtns = [{ id: 'all', label: 'ALL' }].concat(
      mAgentNames.map(name => ({ id: name.toLowerCase(), label: name }))
    );
    
    let mFilterX = todoX;
    const mFilterY = todoY;
    mFilterBtns.forEach((btn, idx) => {
      const isActive = todoFilter === btn.id;
      const btnW = idx === 0 ? 50 : 70;
      const agentColor = idx > 0 ? (agentsData[mAgentNames[idx-1]]?.color || '#5A7A8A') : null;
      
      ctx.fillStyle = isActive ? '#1A3545' : '#0D1520';
      ctx.beginPath();
      ctx.roundRect(mFilterX, mFilterY, btnW, 26, 4);
      ctx.fill();
      strokeRect(ctx, mFilterX, mFilterY, btnW, 26, isActive ? (agentColor || '#4A8ABA') : '#1A2535');
      ctx.fillStyle = isActive ? (agentColor || '#AADDEE') : (agentColor ? agentColor + '99' : '#5A7A8A');
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText(btn.label, mFilterX + 8, mFilterY + 17);
      modalTodoPositions.push({ x: mFilterX, y: mFilterY, width: btnW, height: 26, id: 'filter_' + btn.id });
      mFilterX += btnW + 4;
    });
    
    // Add button
    const mAddX = contentX + contentW - 130;
    ctx.fillStyle = '#1A4A3A';
    ctx.beginPath();
    ctx.roundRect(mAddX, mFilterY, 120, 26, 4);
    ctx.fill();
    strokeRect(ctx, mAddX, mFilterY, 120, 26, '#3A8A6A');
    ctx.fillStyle = '#5AAA9A';
    ctx.font = 'bold 10px "JetBrains Mono"';
    ctx.fillText('+ ADD TASK', mAddX + 18, mFilterY + 17);
    modalTodoPositions.push({ x: mAddX, y: mFilterY, width: 120, height: 26, id: 'add' });
    
    // Filter todos by agent name
    const mAgentFilterNames = ['flint', 'cipher', 'scout', 'atlas', 'forge', 'patch', 'sentry'];
    const mFilteredTodos = todosData.filter(todo => {
      if (todoFilter === 'all') return true;
      if (mAgentFilterNames.includes(todoFilter)) {
        return todo.assignedTo && todo.assignedTo.toLowerCase() === todoFilter;
      }
      return true;
    });
    
    // Draw todo cards
    const cardW = contentW - 20;
    const cardH = 70;
    const cardGap = 10;
    const cardsPerRow = 1;
    const cardStartY = mFilterY + 40;
    
    mFilteredTodos.forEach((todo, i) => {
      const row = i;
      const cx = todoX + 10;
      const cy = cardStartY + row * (cardH + cardGap);
      
      // Card background
      ctx.fillStyle = todo.done ? '#0D1A12' : '#0D1520';
      ctx.beginPath();
      ctx.roundRect(cx, cy, cardW, cardH, 6);
      ctx.fill();
      strokeRect(ctx, cx, cy, cardW, cardH, todo.done ? '#1A3A2A' : '#1A2A3A');
      
      // Left accent bar
      const accentColor = todo.assignedTo ? 
        (todo.assignedTo === currentUser ? '#00D4FF' : '#9966CC') : 
        (todo.done ? '#3A7A5A' : '#3A5A6A');
      ctx.fillStyle = accentColor;
      ctx.fillRect(cx, cy + 4, 4, cardH - 8);
      
      // Checkbox
      const cbX = cx + 16;
      const cbY = cy + 16;
      ctx.strokeStyle = todo.done ? '#3A7A5A' : '#3A5A6A';
      ctx.lineWidth = 2;
      ctx.strokeRect(cbX, cbY, 18, 18);
      if (todo.done) {
        ctx.fillStyle = '#3A7A5A';
        ctx.font = 'bold 14px "JetBrains Mono"';
        ctx.fillText('âœ“', cbX + 3, cbY + 14);
      }
      
      // Task text
      ctx.fillStyle = todo.done ? '#4A6A5A' : '#C0D0E0';
      ctx.font = '12px "JetBrains Mono"';
      ctx.fillText(todo.text, cbX + 28, cbY + 14);
      
      // Meta info row
      const metaY = cy + 42;
      
      // Created by
      ctx.fillStyle = '#3A4A5A';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText(`Created by ${todo.createdBy}`, cbX, metaY);
      
      // Created time (relative)
      if (todo.createdAt) {
        const created = new Date(todo.createdAt);
        const now = new Date();
        const diffMs = now - created;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMins / 60);
        const diffDays = Math.floor(diffHours / 24);
        let timeAgo;
        if (diffDays > 0) timeAgo = `${diffDays}d ago`;
        else if (diffHours > 0) timeAgo = `${diffHours}h ago`;
        else if (diffMins > 0) timeAgo = `${diffMins}m ago`;
        else timeAgo = 'just now';
        ctx.fillText(timeAgo, cbX + ctx.measureText(`Created by ${todo.createdBy}`).width + 20, metaY);
      }
      
      // Assigned to badge (clickable dropdown)
      const badgeX = cx + cardW - 180;
      let badgeColor, badgeText;
      if (!todo.assignedTo) {
        badgeColor = '#4A5A6A';
        badgeText = 'Unassigned';
      } else if (todo.assignedTo === currentUser) {
        badgeColor = '#00D4FF';
        badgeText = todo.assignedTo + ' (You)';
      } else {
        badgeColor = '#9966CC';
        badgeText = todo.assignedTo;
      }
      
      // Badge background
      const badgeW = ctx.measureText(badgeText).width + 16;
      ctx.fillStyle = badgeColor + '33';
      ctx.beginPath();
      ctx.roundRect(badgeX, metaY - 8, badgeW, 18, 4);
      ctx.fill();
      ctx.fillStyle = badgeColor;
      ctx.font = 'bold 9px "JetBrains Mono"';
      ctx.fillText(badgeText, badgeX + 8, metaY + 4);
      modalTodoPositions.push({ x: badgeX, y: metaY - 8, width: badgeW, height: 18, id: todo.id, type: 'assign', todo: todo });
      
      // Delete button (small X)
      const delX = cx + cardW - 30;
      ctx.fillStyle = '#3A2A2A';
      ctx.beginPath();
      ctx.roundRect(delX, metaY - 8, 22, 18, 3);
      ctx.fill();
      strokeRect(ctx, delX, metaY - 8, 22, 18, '#5A3A3A');
      ctx.fillStyle = '#AA5555';
      ctx.font = 'bold 10px "JetBrains Mono"';
      ctx.fillText('âœ•', delX + 7, metaY + 4);
      modalTodoPositions.push({ x: delX, y: metaY - 8, width: 22, height: 18, id: todo.id, type: 'delete', todo: todo });
      
      // Store for click (whole card for toggle)
      modalTodoPositions.push({ x: cx, y: cy, width: cardW, height: cardH, id: todo.id, type: 'todo' });
    });
    
    // Show count
    ctx.fillStyle = '#3A4A5A';
    ctx.font = '9px "JetBrains Mono"';
    ctx.fillText(`${mFilteredTodos.length} task(s)`, todoX + 10, cardStartY + mFilteredTodos.length * (cardH + cardGap) + 20);
    
  } else if (statusTab === 'activity') {
    // â”€â”€ CLI-STYLE ACTIVITY LOG â”€â”€
    const cliX = contentX + 10;
    let cliY = contentY + 10;
    const lineH = 22;
    const maxLines = Math.floor(contentH / lineH);
    
    // CLI-style header
    ctx.fillStyle = '#1A2535';
    ctx.fillRect(cliX, cliY, contentW - 20, 28);
    ctx.fillStyle = '#4A9A6A';
    ctx.font = 'bold 12px "JetBrains Mono"';
    ctx.fillText('â–¶ ACTIVITY LOG', cliX + 10, cliY + 19);
    cliY += 36;
    
    // Each entry as CLI line
    activityData.slice(0, maxLines - 2).forEach((act, i) => {
      // Timestamp
      ctx.fillStyle = '#5A6A7A';
      ctx.font = '11px "JetBrains Mono"';
      ctx.fillText(`[${act.time}]`, cliX, cliY + 14);
      
      // Agent name (colored)
      const agentColor = agentsData[act.agent]?.color || '#AAAAAA';
      ctx.fillStyle = agentColor;
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(act.agent + ':', cliX + 80, cliY + 14);
      
      // Action + Task
      ctx.fillStyle = '#8A9AAA';
      ctx.font = '11px "JetBrains Mono"';
      const actionStart = cliX + 160;
      const taskPart = act.task ? ` ${act.task}` : '';
      let displayText = act.action + taskPart;
      const maxChars = Math.floor((contentW - 180) / 7);
      if (displayText.length > maxChars) {
        displayText = displayText.substring(0, maxChars - 3) + '...';
      }
      ctx.fillText(displayText, actionStart, cliY + 14);
      
      // EXP change
      const expColor = act.exp > 0 ? '#3A9A5A' : (act.exp < 0 ? '#AA4A4A' : '#5A6A7A');
      ctx.fillStyle = expColor;
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.fillText(act.expChange, cliX + contentW - 100, cliY + 14);
      
      cliY += lineH;
    });
  }
}

// ===== CONFIRMATION MODAL =====
function showConfirm(text, onYes, onNo = null) {
  confirmModal.active = true;
  confirmModal.text = text;
  confirmModal.onYes = onYes;
  confirmModal.onNo = onNo;
}

function showAddTaskModal(onSubmit, onCancel = null) {
  addTaskModal.active = true;
  addTaskModal.taskText = '';
  addTaskModal.selectedAssignee = currentUser;
  addTaskModal.onSubmit = onSubmit;
  addTaskModal.onCancel = onCancel;
}

function drawConfirmModal() {
  if (!confirmModal.active) return;

  const cw = canvas.width;
  const ch = canvas.height;
  const mw = 400;
  const mh = 150;
  const mx = (cw - mw) / 2;
  const my = (ch - mh) / 2;

  // Dark overlay
  ctx.fillStyle = '#000000';
  ctx.globalAlpha = 0.7;
  ctx.fillRect(0, 0, cw, ch);
  ctx.globalAlpha = 1;

  // Modal background
  ctx.fillStyle = '#0A0F14';
  ctx.beginPath();
  ctx.roundRect(mx, my, mw, mh, 12);
  ctx.fill();
  strokeRect(ctx, mx, my, mw, mh, '#2A4A6A');

  // Title
  ctx.fillStyle = '#AADDEE';
  ctx.font = 'bold 14px "JetBrains Mono"';
  ctx.fillText('Confirm', mx + 20, my + 30);

  // Message text (wrapped)
  ctx.fillStyle = '#8A9AAA';
  ctx.font = '11px "JetBrains Mono"';
  const maxLine = 50;
  let displayText = confirmModal.text;
  if (displayText.length > maxLine) {
    displayText = displayText.substring(0, maxLine - 3) + '...';
  }
  ctx.fillText(displayText, mx + 20, my + 60);

  // Yes button
  const btnY = my + mh - 50;
  const yesX = mx + 80;
  const btnW = 80;
  const btnH = 32;

  ctx.fillStyle = '#1A4A3A';
  ctx.beginPath();
  ctx.roundRect(yesX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, yesX, btnY, btnW, btnH, '#3A8A6A');
  ctx.fillStyle = '#5AAA9A';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('YES', yesX + 25, btnY + 21);

  // No button
  const noX = mx + mw - 160;
  ctx.fillStyle = '#4A2A2A';
  ctx.beginPath();
  ctx.roundRect(noX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, noX, btnY, btnW, btnH, '#8A4A4A');
  ctx.fillStyle = '#AA6666';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('NO', noX + 28, btnY + 21);

  // Store positions for click detection
  confirmModal.yesPos = { x: yesX, y: btnY, width: btnW, height: btnH };
  confirmModal.noPos = { x: noX, y: btnY, width: btnW, height: btnH };
}

function handleConfirmClick(mouseX, mouseY) {
  if (!confirmModal.active) return false;

  // Check Yes
  if (mouseX >= confirmModal.yesPos.x && mouseX <= confirmModal.yesPos.x + confirmModal.yesPos.width &&
      mouseY >= confirmModal.yesPos.y && mouseY <= confirmModal.yesPos.y + confirmModal.yesPos.height) {
    confirmModal.active = false;
    if (confirmModal.onYes) confirmModal.onYes();
    return true;
  }

  // Check No
  if (mouseX >= confirmModal.noPos.x && mouseX <= confirmModal.noPos.x + confirmModal.noPos.width &&
      mouseY >= confirmModal.noPos.y && mouseY <= confirmModal.noPos.y + confirmModal.noPos.height) {
    confirmModal.active = false;
    if (confirmModal.onNo) confirmModal.onNo();
    return true;
  }

  return false;
}

function drawAddTaskModal() {
  if (!addTaskModal.active) return;

  const cw = canvas.width;
  const ch = canvas.height;
  const mw = 420;
  const mh = 280;
  const mx = (cw - mw) / 2;
  const my = (ch - mh) / 2;

  // Dark overlay
  ctx.fillStyle = '#000000';
  ctx.globalAlpha = 0.7;
  ctx.fillRect(0, 0, cw, ch);
  ctx.globalAlpha = 1;

  // Modal background
  ctx.fillStyle = '#0A0F14';
  ctx.beginPath();
  ctx.roundRect(mx, my, mw, mh, 12);
  ctx.fill();
  strokeRect(ctx, mx, my, mw, mh, '#2A4A6A');

  // Title
  ctx.fillStyle = '#AADDEE';
  ctx.font = 'bold 14px "JetBrains Mono"';
  ctx.fillText('Add New Task', mx + 20, my + 30);

  // Task label
  ctx.fillStyle = '#8A9AAA';
  ctx.font = '11px "JetBrains Mono"';
  ctx.fillText('Task Description:', mx + 20, my + 60);

  // Task input field (styled as text box)
  const inputX = mx + 20;
  const inputY = my + 70;
  const inputW = mw - 40;
  const inputH = 36;

  ctx.fillStyle = '#1A1F28';
  ctx.beginPath();
  ctx.roundRect(inputX, inputY, inputW, inputH, 6);
  ctx.fill();
  strokeRect(ctx, inputX, inputY, inputW, inputH, '#3A4A5A');

  // Show typed text
  ctx.fillStyle = '#CCDDEE';
  ctx.font = '12px "JetBrains Mono"';
  const displayText = addTaskModal.taskText || 'Type task here...';
  const placeholder = !addTaskModal.taskText;
  if (placeholder) {
    ctx.fillStyle = '#5A6A7A';
  }
  ctx.fillText(displayText.substring(0, 40), inputX + 10, inputY + 23);

  // Store input position
  addTaskModal.inputPos = { x: inputX, y: inputY, width: inputW, height: inputH };

  // Assignee label
  ctx.fillStyle = '#8A9AAA';
  ctx.font = '11px "JetBrains Mono"';
  ctx.fillText('Assign To:', mx + 20, my + 130);

  // Assignee dropdown (styled as button)
  const dropX = mx + 20;
  const dropY = my + 140;
  const dropW = mw - 40;
  const dropH = 36;

  ctx.fillStyle = '#1A1F28';
  ctx.beginPath();
  ctx.roundRect(dropX, dropY, dropW, dropH, 6);
  ctx.fill();
  strokeRect(ctx, dropX, dropY, dropW, dropH, '#3A4A5A');

  ctx.fillStyle = '#CCDDEE';
  ctx.font = '12px "JetBrains Mono"';
  ctx.fillText(addTaskModal.selectedAssignee || 'Select...', dropX + 10, dropY + 23);

  // Dropdown indicator
  ctx.fillStyle = '#6A7A8A';
  ctx.fillText('â–¼', dropX + dropW - 25, dropY + 23);

  // Store dropdown position
  addTaskModal.dropdownPos = { x: dropX, y: dropY, width: dropW, height: dropH };

  // YES button (Create Task)
  const btnY = my + mh - 50;
  const yesX = mx + 100;
  const btnW = 100;
  const btnH = 32;

  ctx.fillStyle = '#1A4A3A';
  ctx.beginPath();
  ctx.roundRect(yesX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, yesX, btnY, btnW, btnH, '#3A8A6A');
  ctx.fillStyle = '#5AAA9A';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('CREATE', yesX + 20, btnY + 21);

  // NO button (Cancel)
  const noX = mx + mw - 220;
  ctx.fillStyle = '#4A2A2A';
  ctx.beginPath();
  ctx.roundRect(noX, btnY, btnW, btnH, 6);
  ctx.fill();
  strokeRect(ctx, noX, btnY, btnW, btnH, '#8A4A4A');
  ctx.fillStyle = '#AA6666';
  ctx.font = 'bold 12px "JetBrains Mono"';
  ctx.fillText('CANCEL', noX + 18, btnY + 21);

  // Store button positions
  addTaskModal.yesPos = { x: yesX, y: btnY, width: btnW, height: btnH };
  addTaskModal.noPos = { x: noX, y: btnY, width: btnW, height: btnH };
}

function handleAddTaskModalClick(mouseX, mouseY) {
  if (!addTaskModal.active) return false;

  // Check Create button
  if (mouseX >= addTaskModal.yesPos.x && mouseX <= addTaskModal.yesPos.x + addTaskModal.yesPos.width &&
      mouseY >= addTaskModal.yesPos.y && mouseY <= addTaskModal.yesPos.y + addTaskModal.yesPos.height) {
    if (addTaskModal.taskText.trim()) {
      addTaskModal.active = false;
      if (addTaskModal.onSubmit) {
        addTaskModal.onSubmit(addTaskModal.taskText.trim(), addTaskModal.selectedAssignee);
      }
    }
    return true;
  }

  // Check Cancel button
  if (mouseX >= addTaskModal.noPos.x && mouseX <= addTaskModal.noPos.x + addTaskModal.noPos.width &&
      mouseY >= addTaskModal.noPos.y && mouseY <= addTaskModal.noPos.y + addTaskModal.noPos.height) {
    addTaskModal.active = false;
    if (addTaskModal.onCancel) addTaskModal.onCancel();
    return true;
  }

  // Check assignee dropdown click - cycle through agents
  if (mouseX >= addTaskModal.dropdownPos.x && mouseX <= addTaskModal.dropdownPos.x + addTaskModal.dropdownPos.width &&
      mouseY >= addTaskModal.dropdownPos.y && mouseY <= addTaskModal.dropdownPos.y + addTaskModal.dropdownPos.height) {
    const agents = addTaskModal.agents;
    const currentIdx = agents.indexOf(addTaskModal.selectedAssignee);
    const nextIdx = (currentIdx + 1) % agents.length;
    addTaskModal.selectedAssignee = agents[nextIdx];
    return true;
  }

  return false;
}

// ===== MAIN STATUS BAR =====
function drawStatusBar() {
  if (isMobile) {
    drawCompactStatusBar();
  } else {
    drawDesktopStatusBar();
  }
}

// ===== POLLING =====
let pollTimer = 0;
async function pollStatus() {
  try {
    const res = await fetch('/api/employee-status');
    if (res.ok) {
      const data = await res.json();
      // Check for meetingActive in response
      if (data.meetingActive !== undefined) {
        meetingActive = data.meetingActive === true;
      }
      // Check for meetingLocation in response
      if (data.meetingLocation !== undefined) {
        meetingLocation = data.meetingLocation;
      }
      // Check for heartbeatRecent in response
      if (data.heartbeatRecent !== undefined) {
        heartbeatRecent = data.heartbeatRecent === true;
      }
      // Handle employee status array
      const agents = data.agents || data.employees || data;
      if (Array.isArray(agents)) {
        agents.forEach(s => {
          const ent = entities.find(e => e.name.toLowerCase() === s.name?.toLowerCase());
          if (ent) {
            ent.status = s.status || 'idle';
            // Update EXP/level data from server
            if (s.level !== undefined) ent.level = s.level;
            if (s.exp !== undefined) ent.exp = s.exp;
            if (s.nextLevel !== undefined) ent.nextLevel = s.nextLevel;
            if (s.expProgress !== undefined) ent.expProgress = s.expProgress / 100; // API sends 0-100, we use 0-1
          }
        });
      }
    }
  } catch(e) {
    // API not available â€” that's fine, use default state
  }
}

// ===== INITIALIZATION =====
const entities = AGENTS.map(a => new AgentEntity(a));
const companions = [];
entities.forEach(ent => {
  if (ent.companion) {
    companions.push(new CompanionEntity(ent.companion, ent));
  }
});

// Status board data
let todosData = [];
let activityData = [];
let agentsData = {}; // Map of agent name -> agent data (for colors)
let statusTabPositions = [];
let todoPositions = [];
let modalTabPositions = [];
let modalTodoPositions = [];
let todoFilter = 'all'; // 'all' or agent name lowercase ('flint', 'cipher', etc.)
let currentUser = 'Flint'; // Current user (not used for filtering anymore)

// Fetch todos and activity data
async function fetchStatusBoardData() {
  try {
    const [todosRes, activityRes, statusRes] = await Promise.all([
      fetch('/api/todos'),
      fetch('/api/todos/activity'),
      fetch('/api/employee-status')
    ]);
    todosData = await todosRes.json();
    activityData = await activityRes.json();
    // Add expChange display field
    activityData.forEach(act => {
      act.expChange = act.exp > 0 ? `+${act.exp}` : (act.exp < 0 ? `${act.exp}` : '');
    });
    const statusData = await statusRes.json();
    agentsData = {};
    if (statusData.agents) {
      statusData.agents.forEach(a => { agentsData[a.name] = a; });
    }
  } catch (err) {
    console.error('Error fetching status board data:', err);
  }
}

// Initial fetch
fetchStatusBoardData();

pollStatus(); // Fetch real status immediately on load

// ===== GAME LOOP =====
let lastTime = 0;
function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  // Update
  entities.forEach(e => e.update(dt));
  companions.forEach(c => c.update(dt));

  // Poll timer
  pollTimer += dt * 1000;
  if (pollTimer >= POLL_INTERVAL) { pollStatus(); fetchStatusBoardData(); pollTimer = 0; }

  // Draw
  renderBackground();
  entities.forEach(e => e.draw(ctx));
  companions.forEach(c => c.draw(ctx));
  // Note: drawQuartersOverlay removed - agents should only appear at their current positions, not duplicated in quarters
  
  if (modalOpen) {
    drawModalOverlay();
  } else {
    drawStatusBar();
  }
  
  // Draw confirmation modal on top of everything
  drawConfirmModal();

  // Draw add task modal on top of everything
  drawAddTaskModal();

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
