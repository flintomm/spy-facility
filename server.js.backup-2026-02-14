const http = require('http');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const chokidar = require('chokidar');

const MESHNET_IP = process.env.MESHNET_IP || '0.0.0.0';
const PORT = process.env.PORT || 8080;

const SERVER_START_TIME = Date.now();

const mimeTypes = {
  '.html': 'text/html',
  '.js': 'application/javascript',
  '.css': 'text/css',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.gif': 'image/gif',
  '.ico': 'image/x-icon'
};

let cachedStatus = null;
let cacheTimestamp = 0;
const CACHE_TTL_MS = 2000;

const SESSIONS_DIR = path.join(
  process.env.HOME || '/Users/flint',
  '.openclaw/agents/main/sessions'
);

const AGENTS_JSON_PATH = path.join(__dirname, 'data', 'agents.json');

function loadAgentsData() {
  try {
    const data = fs.readFileSync(AGENTS_JSON_PATH, 'utf8');
    return JSON.parse(data);
  } catch (err) {
    console.error('Error reading agents.json:', err.message);
    return null;
  }
}

function saveAgentsData(agentsData) {
  try {
    fs.writeFileSync(AGENTS_JSON_PATH, JSON.stringify(agentsData, null, 2));
  } catch (err) {
    console.error('Error saving agents.json:', err.message);
  }
}

function updateAgentExp(agentName, expChange) {
  const agentsData = loadAgentsData();
  if (!agentsData || !agentsData.agents || !agentsData.agents[agentName]) {
    return null;
  }
  
  const agent = agentsData.agents[agentName];
  agent.exp = (agent.exp || 0) + expChange;
  
  while (agent.exp >= agent.nextLevel) {
    agent.level += 1;
    agent.nextLevel = Math.floor(agent.nextLevel * 1.5);
  }
  
  if (agent.exp < 0) agent.exp = 0;
  
  saveAgentsData(agentsData);
  console.log(`[EXP] ${agentName}: ${expChange > 0 ? '+' : ''}${expChange} EXP (total: ${agent.exp}, Lv${agent.level})`);
  return agent;
}

const activityFile = path.join(__dirname, 'data', 'todo-activity.json');

function loadActivity() {
  try {
    if (fs.existsSync(activityFile)) {
      return JSON.parse(fs.readFileSync(activityFile, 'utf8'));
    }
  } catch (err) {
    console.error('Error loading activity:', err);
  }
  return [];
}

function saveActivity(activity) {
  try {
    fs.writeFileSync(activityFile, JSON.stringify(activity, null, 2));
  } catch (err) {
    console.error('Error saving activity:', err);
  }
}

function logActivity(agent, action, taskText, extra = {}) {
  const exp = extra.exp || 0;
  const activity = loadActivity();
  const entry = {
    time: new Date().toISOString(),
    agent,
    action,
    task: taskText,
    exp: exp,
    ...extra
  };
  activity.push(entry);
  if (activity.length > 100) {
    activity.shift();
  }
  saveActivity(activity);
  const expStr = exp > 0 ? `+${exp}` : (exp < 0 ? `${exp}` : '');
  console.log(`[TODO] ${agent}: ${expStr ? expStr + ' ' : ''}${action} "${taskText}"${extra.target ? ` to ${extra.target}` : ''}`);
}

// Todos
const todosFile = path.join(__dirname, 'data', 'todos.json');

function loadTodos() {
  try {
    if (fs.existsSync(todosFile)) {
      return JSON.parse(fs.readFileSync(todosFile, 'utf8'));
    }
  } catch (err) {
    console.error('Error loading todos:', err);
  }
  return [];
}

function saveTodos(todos) {
  try {
    fs.writeFileSync(todosFile, JSON.stringify(todos, null, 2));
  } catch (err) {
    console.error('Error saving todos:', err);
  }
}

let todos = loadTodos();

const sessionActivity = new Map();
const recentlyActive = new Map(); // Track when agent was last active

function getLastJsonlEntry(filePath) {
  try {
    const stats = fs.statSync(filePath);
    const readSize = Math.min(8192, stats.size);
    const buffer = Buffer.alloc(readSize);
    const fd = fs.openSync(filePath, 'r');
    fs.readSync(fd, buffer, 0, readSize, stats.size - readSize);
    fs.closeSync(fd);
    const chunk = buffer.toString('utf8');
    const lines = chunk.split('\n');
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      if (line.startsWith('{')) {
        try {
          return JSON.parse(line);
        } catch (e) {
          // Skip invalid JSON
        }
      }
    }
  } catch (err) {
    // Ignore errors
  }
  return null;
}

const AGENT_SESSIONS_PATH = path.join(__dirname, 'data', 'agent-sessions.json');

function loadAgentSessionMap() {
  try {
    if (fs.existsSync(AGENT_SESSIONS_PATH)) {
      return JSON.parse(fs.readFileSync(AGENT_SESSIONS_PATH, 'utf8'));
    }
  } catch (err) {
    console.error('[STATUS] Error reading agent-sessions.json:', err.message);
  }
  return {};
}

function saveAgentSessionMap(map) {
  try {
    fs.writeFileSync(AGENT_SESSIONS_PATH, JSON.stringify(map, null, 2));
  } catch (err) {
    console.error('[STATUS] Error saving agent-sessions.json:', err.message);
  }
}

// File watcher
const watcher = chokidar.watch(SESSIONS_DIR, {
  persistent: true,
  usePolling: true,
  interval: 500,
  ignoreInitial: true,
  depth: 0
});

function handleFileActivity(filePath, eventType) {
  if (!filePath.endsWith('.jsonl')) return;
  const sessionId = path.basename(filePath, '.jsonl');
  const entry = getLastJsonlEntry(filePath);
  if (!entry || !entry.timestamp) return;
  const activityTime = new Date(entry.timestamp).getTime();
  sessionActivity.set(sessionId, {
    lastActivity: activityTime,
    model: entry.modelId || entry.model || null
  });
  cachedStatus = null;
}

watcher.on('change', (filePath) => handleFileActivity(filePath, 'change'));
watcher.on('add', (filePath) => handleFileActivity(filePath, 'add'));
watcher.on('unlink', (filePath) => {
  const sessionId = path.basename(filePath, '.jsonl');
  sessionActivity.delete(sessionId);
  cachedStatus = null;
});

watcher.on('error', (error) => {
  console.error('[WATCHER] Error:', error.message);
});

try {
  const existingFiles = fs.readdirSync(SESSIONS_DIR).filter(f => f.endsWith('.jsonl'));
  for (const file of existingFiles) {
    const filePath = path.join(SESSIONS_DIR, file);
    const sessionId = path.basename(file, '.jsonl');
    const entry = getLastJsonlEntry(filePath);
    if (entry && entry.timestamp) {
      const activityTime = new Date(entry.timestamp).getTime();
      sessionActivity.set(sessionId, {
        lastActivity: activityTime,
        model: entry.modelId || entry.model || null
      });
    }
  }
  console.log(`[WATCHER] Seeded ${sessionActivity.size} sessions from existing JSONL files`);
} catch (err) {
  console.error('[WATCHER] Error seeding sessions:', err.message);
}

console.log('[WATCHER] File watcher initialized for real-time status');

const REALTIME_WINDOW_MS = 15000;
const RECENTLY_ACTIVE_MS = 30000; // Show "working" for 30s after activity
const CLI_ACTIVE_MS = 300000; // 5 minutes window based on CLI session age

// CLI session polling for accurate status detection
let cliSessionCache = null;
let cliSessionCacheTime = 0;
const CLI_POLL_MS = 1000;

function getOpenClawSessions() {
  const now = Date.now();
  if (cliSessionCache && (now - cliSessionCacheTime) < CLI_POLL_MS) {
    return cliSessionCache;
  }
  
  const clawCmd = process.env.OPENCLAW_BIN || '/opt/homebrew/bin/openclaw';
  try {
    const envPath = process.env.PATH ? `${process.env.PATH}` : '';
    const safePath = `/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:${envPath}`;
    const result = execSync(`${clawCmd} sessions list --active-minutes 2 --json`, {
      timeout: 5000,
      encoding: 'utf8',
      env: { ...process.env, PATH: safePath }
    });
    const parsed = JSON.parse(result);
    cliSessionCache = parsed.sessions || [];
    cliSessionCacheTime = now;
  } catch (err) {
    console.error('[CLI] command failed:', err.message);
    if (err.stderr) console.error('[CLI] stderr:', err.stderr.toString());
    if (!cliSessionCache) cliSessionCache = [];
  }
  
  return cliSessionCache;
}

function getActiveAgentStatus() {
  const status = {
    Flint: false,
    Cipher: false,
    Atlas: false
  };

  const now = Date.now();
  
  // Load agent â†’ sessionId mapping
  const agentSessionMap = loadAgentSessionMap();
  const sessionIdToAgent = {};
  for (const [agentName, info] of Object.entries(agentSessionMap)) {
    if (info.sessionId) {
      sessionIdToAgent[info.sessionId] = agentName;
    }
  }

  // PRIMARY: Check CLI sessions (more accurate - knows about active generation)
  try {
    const cliSessions = getOpenClawSessions();
    for (const session of cliSessions) {
      const key = session.key || '';
      const sessionId = session.sessionId || '';
      const ageMs = session.ageMs || 0;
      
      if (ageMs < CLI_ACTIVE_MS) {
        // Check agent-sessions.json mapping first
        const mappedAgent = sessionIdToAgent[sessionId];
        if (mappedAgent && status.hasOwnProperty(mappedAgent)) {
          status[mappedAgent] = true;
          recentlyActive.set(mappedAgent, Date.now());
          continue;
        }
        
        // Fallback to key patterns (exclude main session; rely on file watcher)
        const label = (session.label || '').toLowerCase();
        if (key.includes('cipher') || sessionId.includes('cipher') || label.includes('cipher')) {
          status.Cipher = true;
          recentlyActive.set('Cipher', Date.now());
        } else if (key.includes('atlas') || label.includes('atlas')) {
          status.Atlas = true;
          recentlyActive.set('Atlas', Date.now());
        }
      }
    }
  } catch (err) {
    // CLI failed - continue to file watcher fallback
  }

  // SECONDARY: File watcher (catches activity CLI might miss)
  for (const [sessionId, data] of sessionActivity) {
    const age = now - data.lastActivity;
    if (age < REALTIME_WINDOW_MS) {
      const mappedAgent = sessionIdToAgent[sessionId];
      if (mappedAgent && !status[mappedAgent]) { // Don't override CLI
        status[mappedAgent] = true;
        recentlyActive.set(mappedAgent, Date.now());
        continue;
      }
      if (sessionId.includes('cipher') && !status.Cipher) {
        status.Cipher = true;
        recentlyActive.set('Cipher', Date.now());
      } else if (sessionId === 'agent:main:main' && !status.Flint) {
        status.Flint = true;
        recentlyActive.set('Flint', Date.now());
      }
    }
  }

  // Grace period using recentlyActive
  for (const [agent, lastTs] of recentlyActive.entries()) {
    if (!status[agent] && (now - lastTs) < RECENTLY_ACTIVE_MS) {
      status[agent] = true;
    }
    if ((now - lastTs) >= RECENTLY_ACTIVE_MS) {
      recentlyActive.delete(agent);
    }
  }

  return status;
}

const server = http.createServer((req, res) => {
  const url = new URL(req.url, `http://localhost:${PORT}`);
  
  // CORS headers for all responses
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, X-Requester');
  
  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  // API endpoints
  if (url.pathname === '/api/employee-status') {
    const agentsData = loadAgentsData();
    const agentStatus = getActiveAgentStatus();
    
    const agents = [];
    if (agentsData && agentsData.agents) {
      for (const [name, data] of Object.entries(agentsData.agents)) {
        const isActive = !!agentStatus[data.name];
        const computedStatus = isActive ? 'working' : 'idle';
        agents.push({
          name: data.name,
          role: data.rank,
          status: computedStatus,
          color: data.color,
          level: data.level,
          exp: data.exp,
          nextLevel: data.nextLevel,
          expProgress: Math.round((data.exp / data.nextLevel) * 100)
        });
      }
    }
    
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', agents }));
    return;
  }

  if (url.pathname === '/api/todos' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(todos));
    return;
  }

  if (url.pathname === '/api/todos' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => {
      try {
        const { action, text, id, assignedTo, requester } = JSON.parse(body);
        const requsterName = requester || 'Flint';
        
        if (action === 'add' && text) {
          const newTodo = {
            id: Date.now(),
            text,
            done: false,
            createdAt: new Date().toISOString(),
            createdBy: requsterName,
            assignedTo: assignedTo || null,
            completedAt: null
          };
          todos.push(newTodo);
          saveTodos(todos);
          logActivity(requsterName, 'added task', text);
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(todos));
          return;
        }
        
        if (action === 'complete' && id) {
          const todo = todos.find(t => t.id == id);
          if (todo) {
            logActivity(requsterName, 'completed task', todo.text, { exp: 50 });
            updateAgentExp(requsterName, 50);
            todos = todos.filter(t => t.id != id);
            saveTodos(todos);
          }
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(todos));
          return;
        }

        if (action === 'delete' && id) {
          const todo = todos.find(t => t.id == id);
          const taskText = todo ? todo.text : '';
          todos = todos.filter(t => t.id != id);
          saveTodos(todos);
          logActivity(requsterName, 'deleted task', taskText, { exp: -25 });
          updateAgentExp(requsterName, -25);
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(todos));
          return;
        }

        if (action === 'toggle' && id) {
          const todo = todos.find(t => t.id == id);
          if (todo) {
            todo.done = !todo.done;
            todo.completedAt = todo.done ? new Date().toISOString() : null;
            saveTodos(todos);
            if (todo.done) {
              logActivity(requsterName, 'completed task', todo.text);
            } else {
              logActivity(requsterName, 'reopened task', todo.text);
            }
          }
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(todos));
          return;
        }

        if (action === 'assign' && id && assignedTo) {
          const todo = todos.find(t => t.id == id);
          if (todo) {
            const oldAssignee = todo.assignedTo;
            todo.assignedTo = assignedTo;
            saveTodos(todos);
            if (oldAssignee !== assignedTo) {
              logActivity(requsterName, 'assigned task', todo.text, { target: assignedTo });
            }
          }
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(todos));
          return;
        }
        
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Unknown action' }));
      } catch (err) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: err.message }));
      }
    });
    return;
  }

  if (url.pathname === '/api/todos/activity' && req.method === 'GET') {
    const activity = loadActivity();
    const formatted = activity.slice().reverse().map(a => {
      const d = new Date(a.time);
      const ts = d.toLocaleTimeString('en-US', { hour12: false });
      return { ...a, time: ts, expChange: a.exp > 0 ? `+${a.exp}` : (a.exp < 0 ? `${a.exp}` : '') };
    });
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(formatted));
    return;
  }

  if (url.pathname === '/api/agent-sessions' && req.method === 'POST') {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => {
      try {
        const { agent, sessionId, sessionKey, task, action } = JSON.parse(body);
        let map = loadAgentSessionMap();
        
        if (action === 'start' && agent && sessionId) {
          map[agent] = { sessionId, sessionKey: sessionKey || null, task: task || null, startedAt: new Date().toISOString() };
          console.log(`[AGENT-MAP] ${agent} â†’ ${sessionId} (${task || 'no task'})`);
          saveAgentSessionMap(map);
        } else if (action === 'stop' && agent) {
          delete map[agent];
          console.log(`[AGENT-MAP] ${agent} stopped`);
          saveAgentSessionMap(map);
        }
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(map));
      } catch (err) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: err.message }));
      }
    });
    return;
  }

  if (url.pathname === '/api/agent-sessions' && req.method === 'GET') {
    const map = loadAgentSessionMap();
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(map));
    return;
  }

  // Static files
  let filePath = url.pathname === '/' ? '/index.html' : url.pathname;
  const fullPath = path.join(__dirname, filePath);
  
  if (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {
    const ext = path.extname(fullPath);
    const contentType = mimeTypes[ext] || 'text/plain';
    res.writeHead(200, { 'Content-Type': contentType });
    res.end(fs.readFileSync(fullPath));
    return;
  }

  res.writeHead(404);
  res.end('Not found');
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`âœ… Server running on http://${MESHNET_IP}:${PORT}`);
  console.log(`ðŸ“± Access from your iPhone: http://${MESHNET_IP}:${PORT}`);
  console.log('ðŸ”Œ Real-time agent status: ENABLED (cache: 2000ms)');
  console.log('ðŸ“Š Dashboard endpoints:');
  console.log('   - /api/employee-status (agents with EXP/levels)');
  console.log('   - /api/todos (task management)');
  console.log('   - /api/todos/activity (activity feed)');
});
